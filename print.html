<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Firefox Data Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="dtmo.css">
        
        <link rel="stylesheet" href="mermaid.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introduction.html">Firefox Data Documentation</a></li><li><a href="concepts/reporting_a_problem.html"><strong aria-hidden="true">1.</strong> Reporting a problem</a></li><li><a href="concepts/terminology.html"><strong aria-hidden="true">2.</strong> Terminology</a></li><li><a href="concepts/getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li><a href="concepts/analysis_intro.html"><strong aria-hidden="true">3.1.</strong> Analysis Quick Start</a></li><li><a href="concepts/choosing_a_dataset.html"><strong aria-hidden="true">3.2.</strong> Choosing a Dataset</a></li><li><a href="tools/stmo.html"><strong aria-hidden="true">3.3.</strong> Intro to STMO</a></li><li><a href="concepts/analysis_gotchas.html"><strong aria-hidden="true">3.4.</strong> Common Analysis Gotchas</a></li><li><a href="concepts/sql_optimization.html"><strong aria-hidden="true">3.5.</strong> Optimizing Queries</a></li><li><a href="concepts/review.html"><strong aria-hidden="true">3.6.</strong> Getting Review</a></li><li><a href="datasets/new_data.html"><strong aria-hidden="true">3.7.</strong> Collecting New Data</a></li></ol></li><li><a href="tools/index.html"><strong aria-hidden="true">4.</strong> Tools</a></li><li><ol class="section"><li><a href="tools/projects.html"><strong aria-hidden="true">4.1.</strong> Project Glossary</a></li><li><a href="concepts/pipeline/data_pipeline.html"><strong aria-hidden="true">4.2.</strong> Overview of Mozilla's Data Pipeline</a></li><li><ol class="section"><li><a href="concepts/pipeline/data_pipeline_detail.html"><strong aria-hidden="true">4.2.1.</strong> In-depth Data Pipeline Detail</a></li><li><a href="concepts/pipeline/http_edge_spec.html"><strong aria-hidden="true">4.2.2.</strong> HTTP Edge Server Specification</a></li><li><a href="concepts/pipeline/event_pipeline.html"><strong aria-hidden="true">4.2.3.</strong> Event Pipeline Detail</a></li></ol></li><li><a href="tools/interfaces.html"><strong aria-hidden="true">4.3.</strong> Analysis Interfaces</a></li><li><a href="tools/spark.html"><strong aria-hidden="true">4.4.</strong> Custom analysis with Spark</a></li><li><a href="concepts/sql_style.html"><strong aria-hidden="true">4.5.</strong> SQL Style Guide</a></li></ol></li><li><a href="cookbooks/index.html"><strong aria-hidden="true">5.</strong> Cookbooks</a></li><li><ol class="section"><li><a href="tools/alerts.html"><strong aria-hidden="true">5.1.</strong> Alerts</a></li><li><a href="cookbooks/parquet.html"><strong aria-hidden="true">5.2.</strong> Working with Parquet Data on ATMO Clusters</a></li><li><a href="cookbooks/create_a_dataset.html"><strong aria-hidden="true">5.3.</strong> Creating a custom Re:dash dataset</a></li><li><a href="cookbooks/new_ping.html"><strong aria-hidden="true">5.4.</strong> Sending a Custom Ping</a></li><li><a href="cookbooks/hll_zeppelin.html"><strong aria-hidden="true">5.5.</strong> Using HyperLogLog in Zeppelin</a></li><li><a href="cookbooks/dataset_specific.html"><strong aria-hidden="true">5.6.</strong> Dataset Specific</a></li><li><ol class="section"><li><a href="cookbooks/longitudinal_examples.html"><strong aria-hidden="true">5.6.1.</strong> Longitudinal Examples</a></li><li><a href="cookbooks/crash_pings.html"><strong aria-hidden="true">5.6.2.</strong> Working with Crash Pings</a></li></ol></li><li><a href="cookbooks/realtime.html"><strong aria-hidden="true">5.7.</strong> Real-time</a></li><li><ol class="section"><li><a href="cookbooks/realtime_analysis_plugin.html"><strong aria-hidden="true">5.7.1.</strong> Creating a Real-time Analysis Plugin</a></li><li><a href="cookbooks/view_pings_cep.html"><strong aria-hidden="true">5.7.2.</strong> Seeing Your Own Pings</a></li><li><a href="tools/cep_matcher.html"><strong aria-hidden="true">5.7.3.</strong> CEP Matcher</a></li></ol></li><li><a href="cookbooks/metrics.html"><strong aria-hidden="true">5.8.</strong> Metrics</a></li><li><ol class="section"><li><a href="cookbooks/active_dau.html"><strong aria-hidden="true">5.8.1.</strong> Active DAU Definition</a></li><li><a href="cookbooks/retention.html"><strong aria-hidden="true">5.8.2.</strong> Retention Analysis</a></li><li class="spacer"></li></ol></li></ol></li><li><a href="datasets/reference.html"><strong aria-hidden="true">6.</strong> Dataset Reference</a></li><li><ol class="section"><li><a href="datasets/pings.html"><strong aria-hidden="true">6.1.</strong> Pings</a></li><li><a href="datasets/derived.html"><strong aria-hidden="true">6.2.</strong> Derived Datasets</a></li><li><ol class="section"><li><a href="datasets/batch_view/addons/reference.html"><strong aria-hidden="true">6.2.1.</strong> Addons</a></li><li><a href="datasets/mozetl/churn/reference.html"><strong aria-hidden="true">6.2.2.</strong> Churn</a></li><li><a href="datasets/batch_view/client_count_daily/reference.html"><strong aria-hidden="true">6.2.3.</strong> Client Count Daily</a></li><li><a href="datasets/batch_view/client_count/reference.html"><strong aria-hidden="true">6.2.4.</strong> Client Count</a></li><li><a href="datasets/batch_view/clients_daily/reference.html"><strong aria-hidden="true">6.2.5.</strong> Clients Daily</a></li><li><a href="datasets/batch_view/crash_aggregates/reference.html"><strong aria-hidden="true">6.2.6.</strong> Crash Aggregate</a></li><li><a href="datasets/batch_view/crash_summary/reference.html"><strong aria-hidden="true">6.2.7.</strong> Crash Summary</a></li><li><a href="datasets/batch_view/cross_sectional/reference.html"><strong aria-hidden="true">6.2.8.</strong> Cross Sectional</a></li><li><a href="datasets/streaming/error_aggregates/reference.html"><strong aria-hidden="true">6.2.9.</strong> Error Aggregates</a></li><li><a href="datasets/batch_view/events/reference.html"><strong aria-hidden="true">6.2.10.</strong> Events</a></li><li><a href="datasets/batch_view/first_shutdown_summary/reference.html"><strong aria-hidden="true">6.2.11.</strong> First Shutdown Summary</a></li><li><a href="datasets/batch_view/longitudinal/reference.html"><strong aria-hidden="true">6.2.12.</strong> Longitudinal</a></li><li><a href="datasets/batch_view/main_summary/reference.html"><strong aria-hidden="true">6.2.13.</strong> Main Summary</a></li><li><a href="datasets/batch_view/new_profile/reference.html"><strong aria-hidden="true">6.2.14.</strong> New Profile</a></li><li><a href="datasets/batch_view/retention/reference.html"><strong aria-hidden="true">6.2.15.</strong> Retention</a></li><li><a href="datasets/other/socorro_crash/reference.html"><strong aria-hidden="true">6.2.16.</strong> Socorro Crash Reports</a></li><li><a href="datasets/other/ssl/reference.html"><strong aria-hidden="true">6.2.17.</strong> SSL Ratios (public)</a></li><li><a href="datasets/batch_view/sync_summary/reference.html"><strong aria-hidden="true">6.2.18.</strong> Sync Summary</a></li><li><a href="datasets/batch_view/update/reference.html"><strong aria-hidden="true">6.2.19.</strong> Update</a></li></ol></li><li><a href="tools/experiments.html"><strong aria-hidden="true">6.3.</strong> Experimental Datasets</a></li><li><ol class="section"><li><a href="datasets/shield.html"><strong aria-hidden="true">6.3.1.</strong> Accessing Shield Study data</a></li></ol></li><li><a href="datasets/search.html"><strong aria-hidden="true">6.4.</strong> Search Datasets</a></li><li><ol class="section"><li><a href="datasets/mozetl/search_aggregates/reference.html"><strong aria-hidden="true">6.4.1.</strong> Search Aggregates</a></li><li><a href="datasets/mozetl/search_clients_daily/reference.html"><strong aria-hidden="true">6.4.2.</strong> Search Clients Daily</a></li></ol></li><li><a href="datasets/other.html"><strong aria-hidden="true">6.5.</strong> Other Datasets</a></li><li><ol class="section"><li><a href="datasets/other/hgpush/reference.html"><strong aria-hidden="true">6.5.1.</strong> hgpush</a></li></ol></li><li><a href="datasets/obsolete.html"><strong aria-hidden="true">6.6.</strong> Obsolete Datasets</a></li><li><ol class="section"><li><a href="datasets/obsolete/heavy_users/reference.html"><strong aria-hidden="true">6.6.1.</strong> Heavy Users</a></li><li class="spacer"></li></ol></li></ol></li><li><a href="concepts/index.html"><strong aria-hidden="true">7.</strong> Telemetry Behavior Reference</a></li><li><ol class="section"><li><a href="concepts/profile/index.html"><strong aria-hidden="true">7.1.</strong> Profile Behavior</a></li><li><ol class="section"><li><a href="concepts/profile/profile_creation.html"><strong aria-hidden="true">7.1.1.</strong> Profile Creation</a></li><li><a href="concepts/profile/realworldusage.html"><strong aria-hidden="true">7.1.2.</strong> Real World Usage</a></li><li><a href="concepts/profile/profilehistory.html"><strong aria-hidden="true">7.1.3.</strong> Profile History</a></li><li class="spacer"></li></ol></li></ol></li><li><a href="meta/index.html"><strong aria-hidden="true">8.</strong> About this Documentation</a></li><li><ol class="section"><li><a href="meta/contributing.html"><strong aria-hidden="true">8.1.</strong> Contributing</a></li><li><a href="meta/structure.html"><strong aria-hidden="true">8.2.</strong> Structure</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Firefox Data Documentation</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#firefox-data-documentation" id="firefox-data-documentation"><h1>Firefox Data Documentation</h1></a>
<p>This document will teach you how to use Firefox data
to answer questions about how users interact with our products. The source for this documentation
can be found in <a href="https://github.com/mozilla/firefox-data-docs">this repo</a>.</p>
<a class="header" href="#using-this-document" id="using-this-document"><h2>Using this document</h2></a>
<p>This documentation is divided into four main sections:</p>
<a class="header" href="#a-hrefconceptsgetting_startedhtmlgetting-starteda" id="a-hrefconceptsgetting_startedhtmlgetting-starteda"><h3><a href="concepts/getting_started.html">Getting Started</a></h3></a>
<p>This section provides a <strong>quick introduction</strong> to analyzing telemetry data.
After reading these articles, you will be able to confidently perform analysis
over telemetry data.</p>
<a class="header" href="#a-hreftoolsreadmehtmltoolsa" id="a-hreftoolsreadmehtmltoolsa"><h3><a href="tools/README.html">Tools</a></h3></a>
<p>Describes the tools we maintain to access and analyze product data.</p>
<a class="header" href="#a-hrefcookbooksreadmehtmlcookbooks--tutorialsa" id="a-hrefcookbooksreadmehtmlcookbooks--tutorialsa"><h3><a href="cookbooks/README.html">Cookbooks &amp; Tutorials</a></h3></a>
<p>This section contains tutorials presented in a simple problem/solution format.</p>
<a class="header" href="#a-hrefdatasetsreferencehtmldata-collection-and-datasetsa" id="a-hrefdatasetsreferencehtmldata-collection-and-datasetsa"><h3><a href="datasets/reference.html">Data Collection and Datasets</a></h3></a>
<p>Describes all available data we have from our products.
For each dataset, we include a description of the dataset's purpose,
what data is included, how the data is collected,
and how you can change or augment the dataset.
You do not need to read this section end-to-end.</p>
<a class="header" href="#missing-documentation" id="missing-documentation"><h2>Missing Documentation</h2></a>
<p>We're writing documentation as fast as we can,
but there's always going to be confusing or missing documentation.
If you can't find what you need, please
<a href="https://bugzilla.mozilla.org/enter_bug.cgi?assigned_to=nobody%40mozilla.org&amp;bug_file_loc=http%3A%2F%2F&amp;bug_ignored=0&amp;bug_severity=normal&amp;bug_status=NEW&amp;cf_fx_iteration=---&amp;cf_fx_points=---&amp;component=Documentation%20and%20Knowledge%20Repo%20%28RTMO%29&amp;contenttypemethod=autodetect&amp;contenttypeselection=text%2Fplain&amp;defined_groups=1&amp;flag_type-4=X&amp;flag_type-607=X&amp;flag_type-800=X&amp;flag_type-803=X&amp;flag_type-916=X&amp;form_name=enter_bug&amp;maketemplate=Remember%20values%20as%20bookmarkable%20template&amp;op_sys=Linux&amp;priority=--&amp;product=Data%20Platform%20and%20Tools&amp;rep_platform=x86_64&amp;target_milestone=---&amp;version=unspecified">file a bug</a>.</p>
<a class="header" href="#reporting-a-problem" id="reporting-a-problem"><h1>Reporting a problem</h1></a>
<p>If you have a problem with data tools, datasets, or other pieces of infrastructure,
please help us out by reporting it.</p>
<p>Most of our work is tracked in Bugzilla in the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools">Data Platform and Tools</a> product.</p>
<p>Bugs should be filed in the closest-matching component in the Data Platform and Tools
product, but if there is no component for the item in question, please file an issue
in the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=General">General component</a>.</p>
<p>Components are triaged at least weekly by the component owner(s). For issues needing
urgent attention, it is recommended that you use the <code>needinfo</code> flag to attract attention
from a specific person. If an issue doesn't receive the appropriate attention within a
week, you can send email to the <code>fx-data-dev</code> mailing list or reach out on IRC
in <code>#datapipeline</code>.</p>
<p>When a bug is triaged, it will be assigned a <strong>priority</strong> and <strong>points</strong>. <strong>Priorities</strong> have the
following meanings:</p>
<ul>
<li><strong><code>P1</code></strong>: in active development in the current sprint</li>
<li><strong><code>P2</code></strong>: planned to be worked on in the current quarter</li>
<li><strong><code>P3</code></strong>: planned to be worked on next quarter</li>
<li><strong><code>P4</code></strong> and beyond: nice to have, we would accept a patch, but not actively being worked on.</li>
</ul>
<p><strong>Points</strong> reflect the amount of effort required for a bug and are assigned as follows:</p>
<ul>
<li><strong>1 point</strong>: one day or less of effort</li>
<li><strong>2 points</strong>: two days of effort</li>
<li><strong>3 points</strong>: three days to a week of effort</li>
<li><strong>5 points</strong> or more: SO MUCH EFFORT, major project.</li>
</ul>
<a class="header" href="#problems-with-the-data" id="problems-with-the-data"><h3>Problems with the data</h3></a>
<p>There are bugzilla components for several of core datasets.
described in this documentation, so if possible, please use a specific component.</p>
<p>If there is a problem with a dataset that does not have its own component, please
file an issue in the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=Datasets%3A%20General">Datasets: General component</a>.</p>
<a class="header" href="#problems-with-tools" id="problems-with-tools"><h3>Problems with tools</h3></a>
<p>There are bugzilla components for several of the <a href="../tools/interfaces.html">tools</a> that
comprise the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools">Data Platform</a>,
so please file a bug in the specific component that most closely matches the
tool in question.</p>
<p>Operational bugs, such as services being unavailable, should be filed either in
the component for the service itself or in the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=Operations">Operations component</a>.</p>
<a class="header" href="#other-problems" id="other-problems"><h3>Other problems</h3></a>
<p>When in doubt, please file issues in the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=General">General component</a>.</p>
<a class="header" href="#terminology" id="terminology"><h1>Terminology</h1></a>
<ul>
<li><strong>Analyst</strong>: Someone performing analysis.
This is more general than <strong>data scientist</strong>.</li>
<li><strong>Ping</strong>: A message sent from the Firefox browser to our telemetry servers containing information on browser state, user actions, etc...
(<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/common-ping.html">more details</a>)</li>
<li><strong>Dataset</strong>: A set of data, includes ping data, derived datasets, etc...</li>
<li><strong>Derived Dataset</strong>: A processed dataset, such as <code>main_summary</code> or the
<code>longitudinal</code> dataset</li>
<li><strong>Session</strong>: The time from when a Firefox browser starts until it shuts down</li>
<li><strong>Subsession</strong>: <code>Sessions</code> are split into <code>subsessions</code> when a 24 hour threshold is crossed or an environment change occurs
(<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/concepts/sessions.html?highlight=subsession">more details</a>)</li>
<li>...</li>
</ul>
<a class="header" href="#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<p>This document is meant to be a complete guide to using Firefox Data,
so it can look overwhelming at first.
These readings will <strong>get you up and running quickly</strong>
After these readings you should be able to produce simple analyses
but you should definitely get your analyses reviewed.</p>
<p>This section is meant to introduce new analysts to our data.
I consider a &quot;new analyst&quot; to be an employee
who is interested in working with our data
but doesn't have previous experience with our tools/data.
They could be technical or non-technical: engineer, PM, or data scientist.</p>
<a class="header" href="#getting-started-with-firefox-data" id="getting-started-with-firefox-data"><h1>Getting Started with Firefox Data</h1></a>
<p>Firefox clients out in the wild send us data as <em>pings</em>. <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">Main pings</a> contain some combination of <em>environment</em> data (e.g. operating system, hardware, Firefox version), <em>measurements</em> (e.g. max number of open tabs, time spent running in JavaScript garbage collection), and <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html"><em>events</em></a>. We have quite a few different pings, but most of our data for Firefox Desktop comes in from main pings.</p>
<a class="header" href="#measurement-types" id="measurement-types"><h2>Measurement Types</h2></a>
<p>When we need to measure specific things about clients, we use probes. A single ping will send in many different probes. There are two types of probes that we are interested in here: <em>Histograms</em> and <em>Scalars</em>.</p>
<p>Histograms are bucketed counts. The <a href="https://github.com/mozilla/gecko-dev/blob/master/toolkit/components/telemetry/Histograms.json"><code>Histograms.json</code></a> file has the definitions for all histograms, which includes the minimum, maximum, and number of buckets. Any recorded value instead just increments its associated bucket. We have four main types of histograms:</p>
<ol>
<li>Boolean - Only two buckets, associated with true and false.</li>
<li>Enumerated - Integer buckets, where usually each bucket has a label.</li>
<li>Linear - Buckets are divided evenly between the minimum and maximum; e.g. [1-2] is a bucket, and so is [100-101].</li>
<li>Exponential - Larger valued buckets cover a larger range; e.g. [1-2] is a bucket, and so is [100-200].</li>
</ol>
<p>To see some of these in action, take a look at the <a href="https://telemetry.mozilla.org/histogram-simulator">Histogram Simulator</a>.</p>
<p>Scalars are simply a single value. The <a href="https://dxr.mozilla.org/mozilla-central/rev/tip/toolkit/components/telemetry/Scalars.yaml"><code>Scalars.yaml</code></a> file has the definitions for all scalars. These values can be integers, strings, or booleans.</p>
<a class="header" href="#tmo" id="tmo"><h2>TMO</h2></a>
<p>The simplest way to start looking at probe data is to head over to <a href="https://telemetry.mozilla.org/"><code>telemetry.mozilla.org</code></a> or <a href="https://telemetry.mozilla.org/">TMO</a> for short.</p>
<p>From there, you will likely want either <a href="https://telemetry.mozilla.org/new-pipeline/dist.html">the Measurement Dashboard</a> or <a href="https://telemetry.mozilla.org/new-pipeline/evo.html">the Evolution Dashboard</a>. Using these dashboards you can compare a probe's value between populations, e.g. <code>GC_MS</code> for 64 bit vs. 32 bit, and even track it across builds.</p>
<p>The <a href="https://telemetry.mozilla.org/new-pipeline/dist.html">Measurement Dashboard</a> is a snapshot, aggregating all the data from all chosen dimensions. The Y axis is % of samples, and the X axis is the bucket. You can compare between dimensions, but it does not give you the ability to see how data is changing over time. To investigate that you must use the <a href="https://telemetry.mozilla.org/new-pipeline/evo.html">Evolution Dashboard</a>.</p>
<p>The <a href="https://telemetry.mozilla.org/new-pipeline/evo.html">Evolution Dashboard</a> shows how the data changes over time. Choose which statistics you'd like to plot over time, e.g. Median or 95th percentile. The X axis is time, and the Y axis is the value for whichever statistic you've chosen. <a href="https://telemetry.mozilla.org/new-pipeline/evo.html#!aggregates=median!95th-percentile&amp;cumulative=0&amp;end_date=2017-06-13&amp;keys=!__none__!__none__&amp;max_channel_version=nightly%252F56&amp;measure=GC_MS&amp;min_channel_version=nightly%252F53&amp;processType=*&amp;product=Firefox&amp;sanitize=1&amp;sort_keys=submissions&amp;start_date=2017-06-12&amp;trim=1&amp;use_submission_date=0">This dashboard</a>, for example, shows how <code>GC_MS</code> is improving from nightly 53 to nightly 56! While the median is not changing much, the 95th percentile is trending down, indicating that long garbage collections are being shortened.</p>
<p>The X axis on the Evolution Dashboard shows either Build ID (a date), or Submission Date. The difference is that on any single date we might receive submissions from lots of builds, but aggregating by Build ID means we can be sure a change was because of a new build.</p>
<p>The second plot on the Evolution View is the number of pings we saw containing that probe (Metric Count).</p>
<a class="header" href="#tmo-caveats" id="tmo-caveats"><h3>TMO Caveats</h3></a>
<ul>
<li>Data is aggregated on a per-ping basis, meaning <em>these dashboards cannot be used to say something definitive about users</em>. Please repeat that to yourself. A trend in the evolution view may be caused not by a change affecting lots of users, but a change affecting <em>one</em> single user who is now sending 50% of the pings we see. <a href="http://reports.telemetry.mozilla.org/post/projects%2Fproblematic_client.kp">And yes, that does happen.</a></li>
<li>Sometimes it looks like no data is there, but you think there should be. Check under advanced settings and check &quot;Don't Sanitize&quot; and &quot;Don't Trim Buckets&quot;. If it's still not there, let us know in IRC on #telemetry.</li>
<li>TMO Measurement Dashboards do not currently show release-channel data. Release-channel data <a href="https://medium.com/georg-fritzsche/data-preference-changes-in-firefox-58-2d5df9c428b5">ceased being aggregated</a> as of Firefox 58. We're looking into ways of doing this correctly in the near future.</li>
</ul>
<a class="header" href="#where-to-go-next" id="where-to-go-next"><h2>Where to go next</h2></a>
<ul>
<li><a href="../tools/stmo.html">Analysis using STMO</a></li>
<li><a href="../tools/spark.html">Advanced analysis with ATMO</a></li>
<li><a href="../tools/experiments.html">Experimental data</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Adding_a_new_Telemetry_probe">Adding probes, collecting more data</a></li>
<li><a href="../datasets/derived.html">Augmenting the derived datasets</a></li>
</ul>
<a class="header" href="#choosing-a-dataset" id="choosing-a-dataset"><h1>Choosing a Dataset</h1></a>
<p>This document will help you find the best data source for a given analysis.</p>
<p>This guide focuses on descriptive datasets and does not cover experimentation.
For example, this guide will help if you need to answer questions like:</p>
<ul>
<li>How many users do we have in Germany, how many crashes we see per day?</li>
<li>How many users have a given addon installed?</li>
</ul>
<p>If you're interested in figuring out whether there's a causal link between two events
take a look at our <a href="../tools/experiments.html">tools for experimentation</a>.</p>
<a class="header" href="#table-of-contents" id="table-of-contents"><h2>Table of Contents</h2></a>
<ul>
<li><a href="#raw-pings">Raw Pings</a></li>
<li><a href="#main-ping-derived-datasets">Main Ping Derived Datasets</a>
<ul>
<li><a href="#longitudinal">longitudinal</a></li>
<li><a href="#main_summary">main_summary</a></li>
<li><a href="#first_shutdown_summary">first_shutdown_summary</a></li>
<li><a href="#client_count_daily">client_count_daily</a></li>
<li><a href="#churn">churn</a></li>
<li><a href="#retention">retention</a></li>
<li><a href="#clients_daily">clients_daily</a></li>
</ul>
</li>
<li><a href="#crash-ping-derived-datasets">Crash Ping Derived Datasets</a>
<ul>
<li><a href="#crash_aggregates">crash_aggregates</a></li>
<li><a href="#crash_summary">crash_summary</a></li>
</ul>
</li>
<li><a href="#new-profile-derived-datasets">New-Profile Derived Datasets</a></li>
<li><a href="#update-derived-dataset">Update Derived Dataset</a></li>
<li><a href="#other-datasets">Other Datasets</a></li>
<li><a href="#obsolete-datasets">Obsolete Datasets</a>
<ul>
<li><a href="#heavy_users">heavy_users</a></li>
</ul>
</li>
<li><a href="#appendix">Appendix</a>
<ul>
<li><a href="#mobile-metrics">Mobile Metrics</a></li>
</ul>
</li>
</ul>
<a class="header" href="#raw-pings" id="raw-pings"><h1>Raw Pings</h1></a>
<p>We receive data from our users via <strong>pings</strong>.
There are several types of pings,
each containing different measurements and sent for different purposes.
To review a complete list of ping types and their schemata, see
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/index.html">this section of the Mozilla Source Tree Docs</a>.</p>
<p>Many pings are also described by a JSONSchema specification which can be found in <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/tree/master/schemas/telemetry">this repository</a>.</p>
<a class="header" href="#background-and-caveats" id="background-and-caveats"><h4>Background and Caveats</h4></a>
<p>The large majority of analyses can be completed using only the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">main ping</a>.
This ping includes histograms, scalars, events, and other performance and diagnostic data.</p>
<p>Few analyses actually rely directly on the raw ping data.
Instead, we provide <strong>derived datasets</strong> which are processed versions of these data,
made to be:</p>
<ul>
<li>Easier and faster to query</li>
<li>Organized to make the data easier to analyze</li>
<li>Cleaned of erroneous or misleading data</li>
</ul>
<p>Before analyzing raw ping data,
<strong>check to make sure there isn't already a derived dataset</strong> made for your purpose.
If you do need to work with raw ping data, be aware that loading the data can take a while.
Try to limit the size of your data by controlling the date range, etc.</p>
<a class="header" href="#accessing-the-data" id="accessing-the-data"><h4>Accessing the Data</h4></a>
<p>You can access raw ping data from an <a href="https://analysis.telemetry.mozilla.org/">ATMO cluster</a> using the <a href="https://python-moztelemetry.readthedocs.io/en/stable/api.html#module-moztelemetry.dataset">Dataset API</a>.
Raw ping data are not available in <a href="https://sql.telemetry.mozilla.org/">re:dash</a>.</p>
<a class="header" href="#further-reading" id="further-reading"><h4>Further Reading</h4></a>
<p>You can find <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/index.html">the complete ping documentation</a>.
To augment our data collection, see <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Adding_a_new_Telemetry_probe">Collecting New Data</a> and the
<a href="https://wiki.mozilla.org/Firefox/Data_Collection">Data Collection Policy</a>.</p>
<a class="header" href="#main-ping-derived-datasets" id="main-ping-derived-datasets"><h1>Main Ping Derived Datasets</h1></a>
<p>The <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">main ping</a>
contains most of the measurements used to track performance and health of Firefox in the wild.
This ping includes histograms, scalars, and events.</p>
<p>This section describes the derived datasets we provide to make analyzing this data easier.</p>
<a class="header" href="#longitudinal" id="longitudinal"><h2><code>longitudinal</code></h2></a>
<p>The <code>longitudinal</code> dataset is a 1% sample of main ping data
organized so that each row corresponds to a <code>client_id</code>.
If you're not sure which dataset to use for your analysis,
this is probably what you want.</p>
<a class="header" href="#contents" id="contents"><h4>Contents</h4></a>
<p>Each row in the <code>longitudinal</code> dataset represents one <code>client_id</code>,
which is approximately a user.
Each column represents a field from the main ping.
Most fields contain <strong>arrays of values</strong>, with one value for each ping associated with a <code>client_id</code>.
Using arrays give you access to the raw data from each ping,
but can be difficult to work with from SQL.
Here's a <a href="https://sql.telemetry.mozilla.org/queries/4188#table">query showing some sample data</a>
to help illustrate.
Take a look at the <a href="../../../cookbooks/longitudinal.html">longitudinal examples</a> if you get stuck.</p>
<a class="header" href="#background-and-caveats-1" id="background-and-caveats-1"><h4>Background and Caveats</h4></a>
<p>Think of the longitudinal table as wide and short.
The dataset contains more columns than <code>main_summary</code>
and down-samples to 1% of all clients to reduce query computation time and save resources.</p>
<p>In summary, the longitudinal table differs from <code>main_summary</code> in two important ways:</p>
<ul>
<li>The longitudinal dataset groups all data so that one row represents a <code>client_id</code></li>
<li>The longitudinal dataset samples to 1% of all <code>client_id</code>s</li>
</ul>
<p>Please note that this dataset only contains release (or opt-out) histograms and scalars.</p>
<a class="header" href="#accessing-the-data-1" id="accessing-the-data-1"><h4>Accessing the Data</h4></a>
<p>The <code>longitudinal</code> is available in re:dash,
though it can be difficult to work with the array values in SQL.
Take a look at this <a href="https://sql.telemetry.mozilla.org/queries/4189/source">example query</a>.</p>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data
in <a href="http://spark.apache.org/docs/latest/quick-start.html">Spark</a>.</p>
<pre><code>s3://telemetry-parquet/longitudinal/
</code></pre>
<a class="header" href="#main_summary" id="main_summary"><h2><code>main_summary</code></h2></a>
<p>The <code>main_summary</code> table is the most direct representation of a main ping
but can be difficult to work with due to its size.
Prefer the <code>longitudinal</code> dataset unless using the sampled data is prohibitive.</p>
<a class="header" href="#contents-1" id="contents-1"><h4>Contents</h4></a>
<p>The <code>main_summary</code> table contains one row for each ping.
Each column represents one field from the main ping payload,
though only a subset of all main ping fields are included.
This dataset <strong>does not include histograms</strong>.</p>
<a class="header" href="#background-and-caveats-2" id="background-and-caveats-2"><h4>Background and Caveats</h4></a>
<p>This table is massive, and due to its size, it can be difficult to work with.
You should <strong>avoid querying <code>main_summary</code></strong> from <a href="https://sql.telemetry.mozilla.org">re:dash</a>.
Your queries will be <strong>slow to complete</strong> and can <strong>impact performance for other users</strong>,
since re:dash on a shared cluster.</p>
<p>Instead, we recommend using the <code>longitudinal</code> or <code>clients_daily</code> dataset where possible.
If these datasets do not suffice, consider using Spark on an
<a href="https://analysis.telemetry.mozilla.org">ATMO</a> cluster.
In the odd case where these queries are necessary,
make use of the <code>sample_id</code> field and limit to a short submission date range.</p>
<a class="header" href="#accessing-the-data-2" id="accessing-the-data-2"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://telemetry-parquet/main_summary/v4/
</code></pre>
<p>Though <strong>not recommended</strong> <code>main_summary</code> is accessible through re:dash.
Here's an <a href="https://sql.telemetry.mozilla.org/queries/4201/source">example query</a>.
Your queries will be slow to complete and can <strong>impact performance for other users</strong>,
since re:dash is on a shared cluster.</p>
<a class="header" href="#further-reading-1" id="further-reading-1"><h4>Further Reading</h4></a>
<p>The technical documentation for <code>main_summary</code> is located in the
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/docs/MainSummary.md">telemetry-batch-view documentation</a>.</p>
<p>The code responsible for generating this dataset is
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/MainSummaryView.scala">here</a></p>
<a class="header" href="#first_shutdown_summary" id="first_shutdown_summary"><h2><code>first_shutdown_summary</code></h2></a>
<p>The <code>first_shutdown_summary</code> table is a summary of the <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/first-shutdown-ping.html"><code>first-shutdown</code>
ping</a>.</p>
<a class="header" href="#contents-2" id="contents-2"><h4>Contents</h4></a>
<p>The first shutdown ping contains first session usage data. The
dataset has rows similar to the
<a href="../new_profile/reference.html"><code>telemetry_new_profile_parquet</code></a>,
but in the shape of
<a href="../main_summary/reference.html"><code>main_summary</code></a>.</p>
<a class="header" href="#background-and-caveats-3" id="background-and-caveats-3"><h4>Background and Caveats</h4></a>
<p>Ping latency was reduced through the
shutdown ping-sender mechanism in Firefox 55. To maintain consistent historical
behavior, the first main ping is not sent until the second start up. In Firefox 57, a
separate first-shutdown ping was created to evaluate first-shutdown behavior while maintaining backwards compatibility.</p>
<p>In many cases, the first-shutdown ping is a duplicate of the main ping. The first-shutdown summary can be used in conjunction with the main summary by taking the union and deduplicating on the <code>document_id</code>.</p>
<a class="header" href="#accessing-the-data-3" id="accessing-the-data-3"><h4>Accessing the Data</h4></a>
<p>The data can be accessed as <code>first_shutdown_summary</code>. It is currently stored in the following path.</p>
<pre><code>s3://telemetry-parquet/first_shutdown_summary/v4/
</code></pre>
<p>The data is backfilled to 2017-09-22, the date of its first nightly appearance. This data should be available to all releases on and after Firefox 57.</p>
<a class="header" href="#client_count_daily" id="client_count_daily"><h2><code>client_count_daily</code></h2></a>
<p>The <code>client_count_daily</code> dataset is useful for estimating user counts over a few
<a href="https://github.com/mozilla/telemetry-airflow/blob/master/jobs/client_count_daily_view.sh">pre-defined dimensions</a>.</p>
<p>The <code>client_count_daily</code> dataset is similar to the deprecated
<a href="../client_count/reference.html"><code>client_count</code> dataset</a>
except that is aggregated by submission date and not activity date.</p>
<a class="header" href="#content" id="content"><h4>Content</h4></a>
<p>This dataset includes columns for a dozen factors and an HLL variable.
The <code>hll</code> column contains a
<a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>
variable, which is an approximation to the exact count.
The factor columns include <strong>submission</strong> date and the dimensions listed
<a href="https://github.com/mozilla/telemetry-airflow/blob/master/jobs/client_count_daily_view.sh">here</a>.
Each row represents one combinations of the factor columns.</p>
<a class="header" href="#background-and-caveats-4" id="background-and-caveats-4"><h4>Background and Caveats</h4></a>
<p>It's important to understand that the <code>hll</code> column is <strong>not a standard count</strong>.
The <code>hll</code> variable avoids double-counting users when aggregating over multiple days.
The HyperLogLog variable is a far more efficient way to count distinct elements of a set,
but comes with some complexity.
To find the cardinality of an HLL use <code>cardinality(cast(hll AS HLL))</code>.
To find the union of two HLL's over different dates, use <code>merge(cast(hll AS HLL))</code>.
The <a href="https://sql.telemetry.mozilla.org/queries/81/source#129">Firefox ER Reporting Query</a>
is a good example to review.
Finally, Roberto has a relevant write-up
<a href="https://robertovitillo.com/2016/04/12/measuring-product-engagment-at-scale/">here</a>.</p>
<a class="header" href="#accessing-the-data-4" id="accessing-the-data-4"><h4>Accessing the Data</h4></a>
<p>The data is available in Re:dash.
Take a look at this
<a href="https://sql.telemetry.mozilla.org/queries/81/source#129">example query</a>.</p>
<p>I don't recommend accessing this data from ATMO.</p>
<a class="header" href="#further-reading-2" id="further-reading-2"><h4>Further Reading</h4></a>
<a class="header" href="#churn" id="churn"><h2><code>churn</code></h2></a>
<p>The churn dataset tracks the 7-day churn rate of telemetry profiles. This
dataset is generally used for analyzing cohort churn across segments and time.</p>
<a class="header" href="#content-1" id="content-1"><h4>Content</h4></a>
<p>Churn is the rate of attrition defined by <code>(clients seen in week N)/(clients seen in week 0)</code>
for groups of clients with some shared attributes. A group of clients with
shared attributes is called a <em>cohort</em>. The cohorts in this dataset are created
every week and can be tracked over time using the <code>acquisition_date</code> and the
weeks since acquisition or <code>current_week</code>.</p>
<p>The following example demonstrates the current logic for generating this
dataset. Each column represents the days since some arbitrary starting date.</p>
<table><thead><tr><th>   client </th><th> 00 </th><th> 01 </th><th> 02 </th><th> 03 </th><th> 04 </th><th> 05 </th><th> 06 </th><th> 07 </th><th> 08 </th><th> 09 </th><th> 10 </th><th> 11 </th><th> 12 </th><th> 13 </th><th> 14 </th></tr></thead><tbody>
<tr><td> A        </td><td> X  </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td> X  </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td></tr>
<tr><td> B        </td><td>    </td><td> X  </td><td> X  </td><td> X  </td><td> X  </td><td> X  </td><td> X  </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td></tr>
<tr><td> C        </td><td> X  </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td> X  </td></tr>
</tbody></table>
<p>All three clients are part of the same cohort. Client A is retained for weeks 0
and 1 since there is activity in both periods. A client only needs to show up
once in the period to be counted as retained. Client B is acquired in week 0 and
is active frequently but does not appear in following weeks. Client B is
considered churned on week 1. However, a client that is churned can become
retained again. Client C is considered churned on week 1 but retained on week 3.</p>
<p>The following table summarizes the above daily activity into the following view
where every column represents the current week since acquisition date..</p>
<table><thead><tr><th>   client </th><th> 0 </th><th> 1 </th><th>  2 </th></tr></thead><tbody>
<tr><td> A        </td><td> X </td><td> X </td><td>    </td></tr>
<tr><td> B        </td><td> X </td><td>   </td><td>    </td></tr>
<tr><td> C        </td><td> X </td><td>   </td><td> X  </td></tr>
</tbody></table>
<p>The clients are then grouped into cohorts by attributes. An attribute describes
a property about the cohort such as the country of origin or the binary
distribution channel. Each group also contains descriptive aggregates of
engagement. Each metric describes the activity of a cohort such as size and
overall usage at a given time instance.</p>
<a class="header" href="#background-and-caveats-5" id="background-and-caveats-5"><h4>Background and Caveats</h4></a>
<ul>
<li>Each row in this dataset describes a unique segment of users
<ul>
<li>The number of rows is exponential with the number of dimensions</li>
<li>New fields should be added sparing to account for data-set size</li>
</ul>
</li>
<li>The dataset lags by 10 days in order account for submission latency
<ul>
<li>This value was determined to be time for 99% of main pings to arrive at the
server. With the shutdown-ping sender, this has been reduced to 4 days.
However, <code>churn_v3</code> still tracks releases older than Firefox 55.</li>
</ul>
</li>
<li>The start of the period is fixed to Sundays. Once it has been aggregated, the
period cannot be shifted due to the way clients are counted.
<ul>
<li>A supplementary 1-day <code>retention</code> dataset using HyperLogLog for client
counts is available for counting over arbitrary retention periods and date
offsets. Additionally, calculating churn or retention over specific cohorts
is tractable in STMO with <code>main_summary</code> or <code>clients_daily</code> datasets.</li>
</ul>
</li>
</ul>
<a class="header" href="#accessing-the-data-5" id="accessing-the-data-5"><h4>Accessing the Data</h4></a>
<p><code>churn</code> is available in Re:dash under Athena and Presto. The data is also
available in parquet for consumption by columnar data engines at
<code>s3://telemetry-parquet/churn/v3</code>.</p>
<a class="header" href="#retention" id="retention"><h2><code>retention</code></h2></a>
<p>The <code>retention</code> table provides client counts relevant to client retention at a
1-day granularity. The project is tracked in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1381840">Bug 1381840</a></p>
<a class="header" href="#contents-3" id="contents-3"><h3>Contents</h3></a>
<p>The <code>retention</code> table contains a set of attribute columns used to specify a
cohort of users and a set of metric columns to describe cohort activity. Each
row contains a permutation of attributes, an approximate set of clients in a
cohort, and the aggregate engagement metrics.</p>
<p>This table uses the HyperLogLog (HLL) sketch to create an approximate set of
clients in a cohort. HLL allows counting across overlapping cohorts in a single
pass while avoiding the problem of double counting. This data-structure has the
benefit of being compact and performant in the context of retention analysis,
at the expense of precision. For example, calculating a 7-day retention period
can be obtained by aggregating over a week of retention data using the union
operation. With SQL primitive, this requires a recalculation of COUNT DISTINCT
over <code>client_id</code>'s in the 7-day window.</p>
<a class="header" href="#background-and-caveats-6" id="background-and-caveats-6"><h4>Background and Caveats</h4></a>
<ol>
<li>The data starts at 2017-03-06, the <a href="https://wiki.mozilla.org/RapidRelease/Calendar">merge date where Nightly started to
track Firefox 55 in Mozilla-Central</a>. However, there was
not a consistent view into the behavior of first session profiles until the
<a href="../new_profile/reference.html"><code>new_profile</code> ping</a>. This means much of the data is inaccurate
before 2017-06-26.</li>
<li>This dataset uses 4 day reporting latency to aggregate at least 99% of the
data in a given submission date. This figure is derived from the
<a href="https://sql.telemetry.mozilla.org/dashboard/telemetry-health">telemetry-health measurements on submission latency</a>, with
the discussion in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1407410">Bug 1407410</a>. This latency metric was reduced
Firefox 55 with the introduction of the shutdown ping-sender mechanism.</li>
<li>Caution should be taken before adding new columns. Additional attribute
columns will grow the number of rows exponentially.</li>
<li>The number of HLL bits chosen for this dataset is 13. This means the default
size of the HLL object is 2^13 bits or 1KiB. This maintains about a 1% error
on average. See <a href="https://github.com/twitter/algebird/blob/develop/algebird-core/src/main/scala/com/twitter/algebird/HyperLogLog.scala#L230-L255">this table from Algebird's HLL implementation</a> for
more details.</li>
</ol>
<a class="header" href="#accessing-the-data-6" id="accessing-the-data-6"><h4>Accessing the Data</h4></a>
<p>The data is primarily available through <a href="https://sql.telemetry.mozilla.org/">Re:dash on STMO</a> via
the Presto source. This service has been configured to use predefined HLL
functions.</p>
<p>The column should first be cast to the HLL type. The scalar
<code>cardinality(&lt;hll_column&gt;)</code> function will approximate the number of unique
items per HLL object. The aggregate <code>merge(&lt;hll_column&gt;)</code> function will perform
the set union between all objects in a column.</p>
<p>Example: Cast the count column into the appropriate type.</p>
<pre><code class="language-sql">SELECT cast(hll as HLL) as n_profiles_hll FROM retention
</code></pre>
<p>Count the number of clients seen over all attribute combinations.</p>
<pre><code class="language-sql">SELECT cardinality(cast(hll as HLL)) FROM retention
</code></pre>
<p>Group-by and aggregate client counts over different release channels.</p>
<pre><code class="language-sql">SELECT channel, cardinality(merge(cast(hll AS HLL))
FROM retention
GROUP BY channel
</code></pre>
<p>The HyperLogLog library wrappers are available for use outside of the
configured STMO environment, <a href="https://github.com/mozilla/spark-hyperloglog"><code>spark-hyperloglog</code></a> and
<a href="https://github.com/vitillo/presto-hyperloglog"><code>presto-hyperloglog</code></a>.</p>
<p>Also see the <a href="../client_count_daily/reference.html"><code>client_count_daily</code> dataset</a>.</p>
<a class="header" href="#clients_daily" id="clients_daily"><h2><code>clients_daily</code></h2></a>
<p>The <code>clients_daily</code> table is intended as the first stop for asking questions
about how people use Firefox. It should be easy to answer simple questions.
Each row in the table is a (<code>client_id</code>, <code>submission_date</code>) and contains a
number of aggregates about that day's activity.</p>
<a class="header" href="#contents-4" id="contents-4"><h4>Contents</h4></a>
<p>Many questions about Firefox take the form &quot;What did clients with
characteristics X, Y, and Z do during the period S to E?&quot; The
<code>clients_daily</code> table is aimed at answer those questions.</p>
<a class="header" href="#accessing-the-data-7" id="accessing-the-data-7"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.</p>
<pre><code>s3://telemetry-parquet/clients_daily/v6/
</code></pre>
<p>The <code>clients_daily</code> table is accessible through re:dash using the <code>Athena</code>
data source. It is also available via the <code>Presto</code> data source, though
<code>Athena</code> should be preferred for performance and stability reasons.</p>
<p>Here's an <a href="https://sql.telemetry.mozilla.org/queries/23746#61771">example query</a>.</p>
<a class="header" href="#crash-ping-derived-datasets" id="crash-ping-derived-datasets"><h1>Crash Ping Derived Datasets</h1></a>
<p>The <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/crash-ping.html">crash ping</a>
is captured after the main Firefox process crashes or after a content process crashes,
whether or not the crash report is submitted to <code>crash-stats.mozilla.org</code>.
It includes non-identifying metadata about the crash.</p>
<p>This section describes the derived datasets we provide to make analyzing this data easier.</p>
<a class="header" href="#crash_aggregates" id="crash_aggregates"><h2><code>crash_aggregates</code></h2></a>
<p>The <code>crash_aggregates</code> dataset compiles crash statistics over various dimensions for each day.</p>
<a class="header" href="#rows-and-columns" id="rows-and-columns"><h4>Rows and Columns</h4></a>
<p>There's one column for each of the stratifying dimensions and the crash statistics.
Each row is a distinct set of dimensions, along with their associated crash stats.
Example stratifying dimensions include channel and country,
example statistics include usage hours and plugin crashes.
See the <a href="https://github.com/mozilla/telemetry-batch-view/blob/master/docs/CrashAggregateView.md">complete documentation</a>
for all available dimensions
and statistics.</p>
<a class="header" href="#accessing-the-data-8" id="accessing-the-data-8"><h4>Accessing the Data</h4></a>
<p>This dataset is accessible via re:dash.</p>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://telemetry-parquet/crash_aggregates/v1/
</code></pre>
<a class="header" href="#further-reading-3" id="further-reading-3"><h4>Further Reading</h4></a>
<p>The technical documentation for this dataset can be found in the
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/docs/CrashAggregateView.md">telemetry-batch-view documentation</a></p>
<a class="header" href="#crash_summary" id="crash_summary"><h2><code>crash_summary</code></h2></a>
<p>The <code>crash_summary</code> table is the most direct representation of a crash ping.</p>
<a class="header" href="#contents-5" id="contents-5"><h4>Contents</h4></a>
<p>The <code>crash_summary</code> table contains one row for each crash ping.
Each column represents one field from the crash ping payload,
though only a subset of all crash ping fields are included.</p>
<a class="header" href="#accessing-the-data-9" id="accessing-the-data-9"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://telemetry-parquet/crash_summary/v1/
</code></pre>
<p><code>crash_summary</code> is accessible through re:dash.
Here's an <a href="https://sql.telemetry.mozilla.org/queries/4793/source">example query</a>.</p>
<a class="header" href="#further-reading-4" id="further-reading-4"><h4>Further Reading</h4></a>
<p>The technical documentation for <code>crash_summary</code> is located in the
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/docs/CrashSummary.md">telemetry-batch-view documentation</a>.</p>
<p>The code responsible for generating this dataset is
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/CrashSummaryView.scala">here</a></p>
<a class="header" href="#new-profile-derived-datasets" id="new-profile-derived-datasets"><h1>New-Profile Derived Datasets</h1></a>
<p>The <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/new-profile-ping.html">new-profile ping</a>
is sent from Firefox Desktop on the first session of a newly created profile and contains the initial
information about the user environment.</p>
<p>This data is available in the <code>telemetry_new_profile_parquet</code> dataset.</p>
<p>The <code>telemetry_new_profile_parquet</code> table is the most direct representation of a new-profile ping.</p>
<a class="header" href="#contents-6" id="contents-6"><h4>Contents</h4></a>
<p>The table contains one row for each ping. Each column represents one field from the new-profile ping payload, though only a subset of all fields are included.</p>
<a class="header" href="#accessing-the-data-10" id="accessing-the-data-10"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://net-mozaws-prod-us-west-2-pipeline-data/telemetry-new-profile-parquet/v2/
</code></pre>
<p>The <code>telemetry_new_profile_parquet</code> is accessible through re:dash.
Here's an <a href="https://sql.telemetry.mozilla.org/queries/5888#table">example query</a>.</p>
<a class="header" href="#further-reading-5" id="further-reading-5"><h4>Further Reading</h4></a>
<p>This dataset is generated automatically using direct to parquet. The configuration responsible for generating this dataset was introduced in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1360256">bug 1360256</a>.</p>
<a class="header" href="#update-derived-dataset" id="update-derived-dataset"><h1>Update Derived Dataset</h1></a>
<p>The <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/update-ping.html">update ping</a>
is sent from Firefox Desktop when a browser update is ready to be applied and after it was correctly applied.
It contains the build information and the update blob information, in addition to some information about the
user environment.
The <code>telemetry_update_parquet</code> table is the most direct representation of an update ping.</p>
<a class="header" href="#contents-7" id="contents-7"><h4>Contents</h4></a>
<p>The table contains one row for each ping. Each column represents one field from the update ping payload, though only a subset of all fields are included.</p>
<a class="header" href="#accessing-the-data-11" id="accessing-the-data-11"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://net-mozaws-prod-us-west-2-pipeline-data/telemetry-update-parquet/v1/
</code></pre>
<p>The <code>telemetry_update_parquet</code> is accessible through re:dash.
Here's an <a href="https://sql.telemetry.mozilla.org/queries/31267#table">example query</a>.</p>
<a class="header" href="#further-reading-6" id="further-reading-6"><h4>Further Reading</h4></a>
<p>This dataset is generated automatically using direct to parquet. The configuration responsible for generating this dataset was introduced in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1384861">bug 1384861</a>.</p>
<a class="header" href="#other-datasets" id="other-datasets"><h1>Other Datasets</h1></a>
<p>Public crash statistics for Firefox are available through the Data Platform in a <code>socorro_crash</code> dataset.
The crash data in <a href="https://wiki.mozilla.org/Socorro">Socorro</a> is sanitized and made available to ATMO and STMO.
A nightly import job converts batches of JSON documents into a columnar format using the associated JSON Schema.</p>
<a class="header" href="#contents-8" id="contents-8"><h3>Contents</h3></a>
<a class="header" href="#accessing-the-data-12" id="accessing-the-data-12"><h4>Accessing the Data</h4></a>
<p>The dataset is available in parquet at <code>s3://telemetry-parquet/socorro_crash/v2</code>.
It is also indexed with Athena and Presto with the table name <code>socorro_crash</code>.</p>
<a class="header" href="#obsolete-datasets" id="obsolete-datasets"><h1>Obsolete Datasets</h1></a>
<a class="header" href="#heavy_users" id="heavy_users"><h2><code>heavy_users</code></h2></a>
<p>The <code>heavy_users</code> table provides information about whether a given <code>client_id</code> is
considered a &quot;heavy user&quot; on each day (using submission date).</p>
<a class="header" href="#contents-9" id="contents-9"><h4>Contents</h4></a>
<p>The <code>heavy_users</code> table contains one row per client-day, where day is
<code>submission_date</code>. A client has a row for a specific <code>submission_date</code> if
they were active at all in the 28 day window ending on that <code>submission_date</code>.</p>
<p>A user is a &quot;heavy user&quot; as of day N if, for the 28 day period ending
on day N, the sum of their <code>active_ticks</code> is in the 90th percentile (or
above) of all clients during that period. For more analysis on this,
and a discussion of new profiles, see
<a href="https://metrics.mozilla.com/protected/sguha/heavy/heavycutoffs5.html">this link</a>.</p>
<a class="header" href="#background-and-caveats-7" id="background-and-caveats-7"><h4>Background and Caveats</h4></a>
<ol>
<li>Data starts at 20170801. There is technically data in the table before
this, but the <code>heavy_user</code> column is <code>NULL</code> for those dates because it
needed to bootstrap the first 28 day window.</li>
<li>Because it is top the 10% of clients for each 28 day period, more
than 10% of clients active on a given <code>submission_date</code> will be
considered heavy users. If you join with another data source
(<code>main_summary</code>, for example), you may see a larger proportion of heavy
users than expected.</li>
<li>Each day has a separate, but related, set of heavy users. Initial
investigations show that approximately 97.5% of heavy users as of a
certain day are still considered heavy users as of the next day.</li>
<li>There is no &quot;fixing&quot; or weighting of new profiles - days before the
profile was created are counted as zero <code>active_ticks</code>. Analyses may
need to use the included <code>profile_creation_date</code> field to take this
into account.</li>
</ol>
<a class="header" href="#accessing-the-data-13" id="accessing-the-data-13"><h4>Accessing the Data</h4></a>
<p>The data is available both via <code>sql.t.m.o</code> and Spark.</p>
<p>In Spark:</p>
<pre><code class="language-python">spark.read.parquet(&quot;s3://telemetry-parquet/heavy_users/v1&quot;)
</code></pre>
<p>In SQL:</p>
<pre><code class="language-sql">SELECT * FROM heavy_users LIMIT 3
</code></pre>
<a class="header" href="#further-reading-7" id="further-reading-7"><h4>Further Reading</h4></a>
<p>The code responsible for generating this dataset is
<a href="BROKEN:https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/HeavyUsersView.scala">here</a></p>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="#mobile-metrics" id="mobile-metrics"><h2>Mobile Metrics</h2></a>
<p>There are several tables owned by the mobile team documented
<a href="https://wiki.mozilla.org/Mobile/Metrics/Redash">here</a>:</p>
<ul>
<li><code>android_events</code></li>
<li><code>android_clients</code></li>
<li><code>android_addons</code></li>
<li><code>mobile_clients</code></li>
</ul>
<a class="header" href="#introduction" id="introduction"><h2>Introduction</h2></a>
<p>STMO is shorthand for
<a href="https://sql.telemetry.mozilla.org"><code>sql.telemetry.mozilla.org</code></a>, an installation
of the excellent <a href="https://redash.io/">Re:dash</a> data analysis and dashboarding
tool that has been customized and configured for use with a number of the
Firefox organization's data sets. As the name and URL imply, effective use of
this tool requires familiarity with the
<a href="https://en.wikipedia.org/wiki/SQL">SQL</a> query language, with which all of the
tool's data extraction and analysis are performed.</p>
<a class="header" href="#concepts" id="concepts"><h2>Concepts</h2></a>
<p>There are three building block from which analyses in STMO are constructed:
queries, visualizations, and dashboards.</p>
<a class="header" href="#queries" id="queries"><h4>Queries</h4></a>
<p>STMO's basic unit of analysis is the query. A query is a block of SQL code that
extracts and (optionally) transforms data from a single data source. Queries
can vary widely in complexity. Some queries are trivial one liners
(e.g. <code>SELECT * FROM tablename LIMIT 10</code>), while others are many pages long,
small programs in their own right.</p>
<p>The raw output from a query is tabular data, where each row is one set of
return values for the query's output columns. A query can be run manually or it
can be specified to have a refresh schedule, where it will execute
automatically after a specified interval of time.</p>
<a class="header" href="#visualizations" id="visualizations"><h4>Visualizations</h4></a>
<p>Tabular data is great, but rarely is a grid of values the best way to make
sense of your data. Each query can be associated with multiple visualizations,
each visualization rendering the extracted data in some more useful
format. There are many visualization types, including charts (line, bar, area,
pie, etc.), counters, maps, pivot tables, and more. Each visualization type
provides a set of configuration parameters that allow you to specify how to map
from the raw query output to the desired visualization. Some visualization types
make demands of the query output; a map visualization requires each row to contain
a longitude value and a latitude value, for instance.</p>
<a class="header" href="#dashboards" id="dashboards"><h4>Dashboards</h4></a>
<p>A dashboard is a collection of visualizations, combined into a single visual
presentation for convenient perusal. A dashboard is decoupled from any
particular queries. While it is possible to include multiple visualizations
from a single query in one dashboard, it is not required; users can add any
visualizations they can access to the dashboards they create.</p>
<a class="header" href="#data-sources" id="data-sources"><h2>Data Sources</h2></a>
<p>SQL provides the ability to extract and manipulate the data, but you won't get
very far without having some familiarity with what data is actually available,
and how that data is structured. Each query in STMO is associated with exactly
one data source, and you have to know ahead of time which data source contains
the information that you need. One of the most commonly used data sources is
called <em>Athena</em> (referring to Amazon's <a href="https://aws.amazon.com/athena/">Athena</a>
query service, on which it is built), which contains most of the data that is
obtained from telemetry pings received from Firefox clients. The <em>Athena</em>
source is slowly replacing the <em>Presto</em> data source. <em>Presto</em> contains all of
the data that's exposed via <em>Athena</em> and more, but returns query results much
more slowly.</p>
<p>Other available data sources include <em>Crash DB</em>, <em>Tiles</em>, <em>Sync Stats</em>, <em>Push</em>,
<em>Test Pilot</em>, <em>ATMO</em>, and even a <em>Re:dash metadata</em> which connects to STMO's
own Re:dash database. You can learn more about the available data sets and how
to find the one that's right for you on the <a href="../concepts/choosing_a_dataset.html">Choosing a
dataset</a> page. If you have data set
questions, or would like to know if specific data is or can be made available
in STMO, please inquire in the <code>#datapipeline</code> or <code>#datatools</code> channels on
<code>irc.mozilla.org</code>.</p>
<a class="header" href="#creating-an-example-dashboard" id="creating-an-example-dashboard"><h2>Creating an Example Dashboard</h2></a>
<p>The rest of this document will take you through the process of creating a
simple dashboard using STMO.</p>
<a class="header" href="#creating-a-query" id="creating-a-query"><h4>Creating A Query</h4></a>
<p>We start by creating a query. Our first query will count the number of client
ids that we have coming from each country, for the top N countries. Clicking on
the 'New Query' button near the top left of the site will bring you to the
query editing page:</p>
<p><img src="../assets/STMO_screenshots/new_query.png" alt="New Query Page" title="New Query page" /></p>
<p>For this (and most queries where we're counting distinct client IDs) we'll want
to use the <a href="../datasets/batch_view/client_count_daily/reference.html"><code>client_count_daily</code> data
set</a> that is generated from
Firefox telemetry pings.</p>
<ul>
<li>
<p>Check if the data set is in Athena</p>
<p>As mentioned above, Athena is faster than Presto, but not all data sets are
yet available in Athena. We can check to see if the one we want is available
in the by typing <code>client_count_daily</code> into the &quot;Search schema...&quot;  search box above
the schema browser interface to the left of the main query edit box. As of
this writing, alas, there are no matches for <code>client_count_daily</code>, which means this
data set is not available in <em>Athena</em>.</p>
</li>
<li>
<p>Verify the data set exists in Presto</p>
<p>It's not in Athena, so now we should check to see if it's in Presto. If you
click on the 'Data Source' drop-down and change the selection from 'Athena' to
'Presto' (with <code>client_count_daily</code> still populating the filter input), you should
see that there is, in fact, a <code>client_count_daily</code> data set (showing up as
<code>default.client_count_daily</code>), as well as versioned <code>client_count_daily</code> data
sets (showing up as <code>default.client_count_daily_v&lt;VERSION&gt;</code>).</p>
</li>
<li>
<p>Introspect the available columns</p>
<p>Clicking on the <code>default.client_count_daily</code> in the schema browser exposes the
columns that are available in the data set. Two of the columns are of
interest to us for this query: <code>country</code> (for obvious reasons) and <code>hll</code>.</p>
</li>
</ul>
<p>The <code>hll</code> column bears some explanation. <code>hll</code> stands for
<a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>, a sophisticated
algorithm that allows for the counting of extremely high numbers of items,
sacrificing a small amount of accuracy in exchange for using much less memory
than a simple counting structure. The <code>client_count_daily</code> data set uses the <code>hll</code>
column for all of its counting functionality. Converting the <code>hll</code> value back
to a regular numeric value requires the use of the following magic SQL
incantation:</p>
<p><code>cardinality(merge(cast(hll as HLL)))</code></p>
<p>So a query that extracts all of the unique country values and the count for
each one, sorted from highest count to lowest count looks like this:</p>
<pre><code class="language-sql">SELECT country,
       cardinality(merge(cast(hll AS HLL))) AS client_count
FROM client_count_daily
GROUP BY 1
ORDER BY 2 DESC
</code></pre>
<p>If you type that into the main query edit box and then click on the &quot;Execute&quot;
button, you should see a blue bar appear below the edit box containing the text
&quot;Executing query...&quot; followed by a timer indicating how long the query has been
running. After a reasonable (for some definition of &quot;reasonable&quot;, usually about
one to two minutes) amount of time the query should complete, resulting in a
table showing a client count value for each country. Congratulations, you've
just created and run your first STMO query!</p>
<p>Now would be a good time to click on the large &quot;New Query&quot; text near the top of
the page; it should turn into an edit box, allowing you to rename the
query. For this exercise, you should use a unique prefix (such as your name)
for your query name, so it will be easy to find your query later; I used
<code>rmiller:Top Countries</code>.</p>
<a class="header" href="#creating-a-visualization" id="creating-a-visualization"><h4>Creating A Visualization</h4></a>
<p>Now that the query is created, we'll want to provide a simple
visualization. The table with results from the first query execution should be
showing up underneath the query edit box. Next to the <code>TABLE</code> heading should be
another heading entitled <code>+NEW VISUALIZATION</code>.</p>
<p><img src="../assets/STMO_screenshots/new_visualization.png" alt="New Visualization" title="New Visualization" /></p>
<p>Clicking on the <code>+NEW VISUALIZATION</code> link should bring you to the
&quot;Visualization Editor&quot; screen, where you can specify a visualization name (&quot;Top
Countries bar chart&quot;), a chart type (&quot;Bar&quot;), an x-axis column (<code>country</code>), and
a y-axis column (<code>client_count</code>).:</p>
<p><img src="../assets/STMO_screenshots/vis_editor.png" alt="Visualization Editor" title="Visualization Editor" /></p>
<p>After the <code>GENERAL</code> settings have been specified, we'll want to tweak a few
more settings on the <code>X AXIS</code> tab. You'll want to click on this tab and then
change the 'Scale' setting to 'Category', and un-check the 'Sort Values'
check-box to allow the query's sort order to take precedence:</p>
<p><img src="../assets/STMO_screenshots/x_axis_editor.png" alt="Visualization X Axis" title="Visualization X Axis" /></p>
<a class="header" href="#a-note-about-limits" id="a-note-about-limits"><h4>A Note About Limits</h4></a>
<p>Once you save the visualization settings and return to the query source page,
you should have a nice bar graph near the bottom of the page. You may notice,
however, that the graph has quite a long tail. Rather than seeing <em>all</em> of
the countries, it might be nicer to only see the top 20. We can do this by adding
a <code>LIMIT</code> clause to the end of our query:</p>
<p><code>SELECT country, cardinality(merge(cast(hll AS HLL))) AS client_count FROM client_count_daily GROUP BY 1 ORDER BY 2 DESC LIMIT 20</code></p>
<p>If you edit the query to add a limit clause and again hit the 'Execute' button,
you should get a new bar graph that only shows the 20 countries with the
highest number of unique clients. In this case, the full data set has
approximately 250 return values, and so limiting the result count improves
readability. In other cases, however, an unlimited query might return thousands
or even millions of rows. When those queries are run, readability is not the
only problem; queries that return millions of rows can tax the system, failing
to return the desired results, and negatively impacting the performance of all
of the other users of the system. Thus, a very important warning:</p>
<p><strong>ALL QUERIES SHOULD INCLUDE A &quot;LIMIT&quot; STATEMENT BY DEFAULT!</strong></p>
<p>You should be in the habit of adding a &quot;LIMIT 100&quot; clause to the end of all new
queries, to prevent your query from returning a gigantic data set that causes
UI and performance problems. You may learn that the total result set is small
enough that the limit is unnecessary, but unless you're certain that is the
case specifying an explicit LIMIT helps prevent unnecessary issues.</p>
<a class="header" href="#query-parameters" id="query-parameters"><h4>Query Parameters</h4></a>
<p>We got our chart under control by adding a &quot;LIMIT 20&quot; clause at the end. But
what if we only want the top 10? Or maybe sometimes we want to see the top 30?
We don't always know how many results our users will want. Is it possible to
allow users to specify how many results they want to see?</p>
<p>As you've probably guessed, I wouldn't be asking that question if the answer
wasn't &quot;yes&quot;. STMO allows queries to accept user arguments by the use of double
curly-braces around a variable name. So our query now becomes the following:</p>
<p><code>SELECT country, cardinality(merge(cast(hll AS HLL))) AS client_count FROM client_count_daily GROUP BY 1 ORDER BY 2 DESC LIMIT {{country_count}}</code></p>
<p>Once you replace the hard coded limit value with <code>{{country_count}}</code> you should
see an input field show up directly above the bar chart. If you enter a numeric
value into this input box and click on 'Execute' the query will run with the
specified limit. Clicking on the 'Save' button will then save the query, using
the entered parameter value as the default.</p>
<a class="header" href="#creating-a-dashboard" id="creating-a-dashboard"><h4>Creating A Dashboard</h4></a>
<p>Now we can create a dashboard to display our visualization. Do this by clicking
on the 'Dashboards' drop-down near the top left of the page, and then clicking
the 'New Dashboard' option. Choose a name for your dashboard, and you will be
brought to a mostly empty page. Clicking on the '...' button near the top right
of the page will give you the option to 'Add Widget'. This displays the
following dialog:</p>
<p><img src="../assets/STMO_screenshots/add_widget.png" alt="Add Widget" title="Add Widget" /></p>
<p>The &quot;Search a query by name&quot; field is where you can enter in the unique prefix
used in your query name to find the query you created. This will not yet work,
however, because your query isn't published. Publishing a query makes it show
up in searches and on summary pages. Since this is only an exercise, we won't
want to leave our query published, but it must be published briefly in order to
add it to our dashboard. You can publish your query by returning to the query
source page and clicking the &quot;Publish&quot; button near the top right of the screen.</p>
<p>Once your query is published, it should show up in the search results when you
type your unique prefix into the &quot;Search a query by name&quot; field on the &quot;Add
Widget&quot; dialog. When you select your query, a new &quot;Choose Visualization&quot;
drop-down will appear, allowing you to choose which of the query's
visualizations to use. Choose the bar chart you created and then click on the
&quot;Add to Dashboard&quot; button. Voila! Now your dashboard should have a bar chart,
and you should be able to edit the <code>country_count</code> value and click the refresh
button to change the number of countries that show up on the chart.</p>
<a class="header" href="#completing-the-dashboard" id="completing-the-dashboard"><h4>Completing the Dashboard</h4></a>
<p>A dashboard with just one graph is a bit sad, so let's flesh it out by adding a
handful of additional widgets. We're going to create three more queries, each
with a very similar bar chart. The text of the queries will be provided here,
but creating the queries and the visualizations and wiring them up to the
dashboard will be left as an exercise to the user. The queries are as follows:</p>
<ul>
<li>
<p>Top OSes (recommended <code>os_count</code> value == 6)</p>
<p><code>SELECT os, cardinality(merge(cast(hll AS HLL))) AS client_count FROM client_count_daily GROUP BY 1 ORDER BY 2 DESC LIMIT {{os_count}}</code></p>
</li>
<li>
<p>Channel Counts</p>
<p><code>SELECT normalized_channel AS channel, cardinality(merge(cast(hll AS HLL))) AS client_count FROM client_count_daily GROUP BY 1 ORDER BY 2 DESC</code></p>
</li>
<li>
<p>App Version Counts (recommended <code>app_version_count value</code> == 20)</p>
<p><code>SELECT app_name, app_version, cardinality(merge(cast(hll AS HLL))) AS client_count FROM client_count_daily GROUP BY 1, 2 ORDER BY 3 DESC LIMIT {{app_version_count}}</code></p>
</li>
</ul>
<p>Creating bar charts for these queries and adding them to the original dashboard
can result in a dashboard resembling this:</p>
<p><img src="../assets/STMO_screenshots/finished_dashboard.png" alt="Completed Dashboard" title="Completed Dashboard" /></p>
<p>Some final notes to help you create your dashboards:</p>
<ul>
<li>
<p>Don't forget that you'll need to publish each of your queries before you can
add its visualizations to your dashboard.</p>
</li>
<li>
<p>Similarly, it's a good idea to un-publish any test queries after you've used
them in a dashboard so as not to permanently pollute everyone's search results
with your tests and experiments. Queries that are the result of actual
work-related analysis should usually remain published, so others can see and
learn from them.</p>
</li>
<li>
<p>The 'Firefox' label on the 'App Version counts' graph is related to the use
of the 'Group by' visualization setting. I encourage you to experiment with
the use of 'Group by' in your graphs to learn more about how this can be
used.</p>
</li>
<li>
<p>This tutorial has only scratched the surface of the wide variety of very
sophisticated visualizations supported by STMO. You can see a great many much
more sophisticated queries and dashboards by browsing around and exploring
the work that has been published by others.</p>
</li>
<li>
<p>The <a href="https://redash.io/help/">Re:dash help center</a> is useful for further deep
diving into Re:dash and all of its capabilities.</p>
</li>
</ul>
<a class="header" href="#prototyping-queries" id="prototyping-queries"><h4>Prototyping Queries</h4></a>
<p>Sometimes you want to start working on your query before the data is available.
You can do this with most of the data sources by selecting a static test data
set, then working with it as usual. You can also use this method to explore
how a given SQL backend behaves.</p>
<p>Note that <code>UNION ALL</code> will retain duplicate rows while <code>UNION</code> will discard them.</p>
<p>Here are a couple of examples:</p>
<p><strong>Simple three-column test dataset</strong></p>
<pre><code class="language-sql">WITH test AS (
 SELECT 1 AS client_id, 'foo' AS v1, 'bar' AS v2 UNION ALL
 SELECT 2 AS client_id, 'bla' AS v1, 'baz' AS v2 UNION ALL
 SELECT 3 AS client_id, 'bla' AS v1, 'bar' AS v2 UNION ALL
 SELECT 2 AS client_id, 'bla' AS v1, 'baz' AS v2 UNION ALL
 SELECT 3 AS client_id, 'bla' AS v1, 'bar' AS v2
)

SELECT * FROM test
</code></pre>
<p><strong>Convert a semantic version string to a sortable array field</strong></p>
<pre><code class="language-sql">WITH foo AS (
 SELECT '1.0.1' AS v UNION
 SELECT '1.10.3' AS v UNION
 SELECT '1.0.2' AS v UNION
 SELECT '1.1' AS v UNION
 -- Doesn't work with these type of strings due to casting
 -- SELECT '1.3a1' AS v UNION
 SELECT '1.2.1' AS v
)

SELECT cast(split(v, '.') AS array&lt;bigint&gt;) FROM foo ORDER BY 1
</code></pre>
<p><strong>How do boolean fields get parsed from strings?</strong></p>
<pre><code class="language-sql">WITH bar AS (
 SELECT '1' AS b UNION
 SELECT '0' UNION
 SELECT 't' UNION
 SELECT 'f' UNION
 SELECT 'true' UNION
 SELECT 'false' UNION
 SELECT 'turkey'
)
SELECT b, try(cast(b AS boolean)) from bar
</code></pre>
<a class="header" href="#analysis-gotchas" id="analysis-gotchas"><h1>Analysis Gotchas</h1></a>
<p>When performing analysis on any data there are some mistakes that are easy to make and details that are easy to overlook. Do you know exactly what question you hope to answer? Is your sample representative of your population? Is your result &quot;real&quot;? How precisely can you state your conclusion?</p>
<p>This document is not about those traps. Instead, it is about quirks and pitfalls specific to <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/index.html">Telemetry</a>.</p>
<a class="header" href="#pseudo-replication" id="pseudo-replication"><h3>Pseudo-replication</h3></a>
<p>Telemetry data is a collection of pings. A single main-ping represents a single subsession. Some clients have more subsessions than others.</p>
<p>So when you say <a href="https://mzl.la/2q75dbF">&quot;63% of beta 53 has Firefox set as its default browser&quot;</a>, make sure you specify it is 63% of <em>pings</em>, since it is only around 46% of clients. (Apparently users with Firefox Beta 53 set as their default browser submit more main-pings than users who don't).</p>
<a class="header" href="#profiles-vs-users" id="profiles-vs-users"><h3>Profiles vs Users</h3></a>
<p>In the section above you'll notice I said &quot;clients&quot; not &quot;users.&quot; That is because of all the things we're able to count, users isn't one of them.</p>
<p>Users can have multiple Firefox profiles running on the same computer at the same time (like developers).</p>
<p>Users can have the same Firefox profile running on several computers on different days of the week (also developers).</p>
<p>The only things we can count are pings and clients. Clients we can count because we send a <code>client_id</code> with each ping that uniquely identifies the profile from which it came. This is generally close enough to our idea of &quot;user&quot; that we can get away with counting profiles and calling them users, but you may run into some instances where the distinction matters.</p>
<p>When in doubt, be precise. You're counting <em>clients</em>.</p>
<a class="header" href="#opt-in-vs-opt-out" id="opt-in-vs-opt-out"><h3>Opt-in vs Opt-out</h3></a>
<p>We don't collect the same information from everyone.</p>
<p>Every profile that doesn't have Telemetry disabled sends us &quot;opt-out&quot; Telemetry. This includes:</p>
<ul>
<li>Nearly everything in the <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/environment.html">Environment</a></li>
<li>Some very specific <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/histograms.html">Histograms</a>, <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/scalars.html">Scalars</a>, and <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html">Events</a> that are marked <code>&quot;releaseChannelCollection&quot;: &quot;opt-out&quot;</code></li>
</ul>
<p>Most probes are &quot;opt-in&quot;: we do not get information from them unless the user opts into sending us this information. Users can opt-in in two ways:</p>
<ol>
<li>Using Firefox's Options UI to tick the box that gives us permission</li>
<li>Installing any pre-release version of Firefox</li>
</ol>
<p>The nature of selection bias is such that the population in #1 is useless for analysis. If you want to encourage users to collect good information for us, ask them to install Beta: it's only slightly harder than finding and checking the opt-in check-box in Firefox.</p>
<a class="header" href="#trusting-dates" id="trusting-dates"><h3>Trusting Dates</h3></a>
<p>Don't trust client times.</p>
<p>Any timestamp recorded by the user is subject to &quot;clock skew.&quot; The user's clock can be set (purposefully or accidentally) to any time at all. The nature of SSL certificates tends to keep this within a certain relatively-accurate window, because a user who's clock is too far in the past or too far in the future might confuse certain expiration-date-checking code.</p>
<p>Examples of client times: <code>crashDate</code>, <code>crashTime</code>, <code>meta/Date</code>, <code>sessionStartDate</code>, <code>subsessionStartDate</code>, <code>profile/creationDate</code></p>
<p>Examples of server times you can trust: <code>Timestamp</code>, <code>submission_date</code></p>
<p><em>Note that <code>submissionDate</code> does not appear in the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/common-ping.html">ping documentation</a>
because it is added in post-processing.
It can be found in the <code>meta</code> field of the ping as in the
<a href="https://dbc-caf9527b-e073.cloud.databricks.com/#notebook/30598/">Databricks Example</a>.</em></p>
<a class="header" href="#date-formats" id="date-formats"><h3>Date Formats</h3></a>
<p>Not all dates and times are created equal. Most of the dates and times in Telemetry pings are <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. Most are full timestamps, though their resolution may differ from being per-second to being per-day.</p>
<p>Then there's <code>profile/creationDate</code> which is just a number of days since epoch. Like <code>17177</code> for the date 2017-01-11.</p>
<p><strong>Tip:</strong> To convert <code>profile/creationDate</code> to a usable date in SQL: <code>DATE_ADD('day', profile_created, DATE '1970-01-01')</code></p>
<p>In derived datasets ISO dates are sometimes converted to strings in one of two formats: <code>%Y-%m-%d</code> or <code>%Y%m%d</code>.</p>
<p>The date formats for different rows in <code>main_summary</code> are described on the <a href="../datasets/batch_view/main_summary/reference.html#time-formats"><code>main_summary</code> reference page</a>.</p>
<p>Build ids look like dates but aren't. If you take the first eight characters you can use that as a proxy for the day the build was released.</p>
<p><code>metadata/Date</code> is an HTTP Date header in a <a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>-compatible format.</p>
<p><strong>Tip:</strong> To parse <code>metadata/Date</code> to a usable date in SQL: <code>DATE_PARSE(SUBSTR(client_submission_date, 1, 25), '%a, %d %b %Y %H:%i:%s')</code></p>
<a class="header" href="#delays" id="delays"><h3>Delays</h3></a>
<p>Telemetry data takes a while to get into our hands. The largest data mule in Telemetry is the main-ping. It is (pending <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1336360">bug 1336360</a>) sent at the beginning of a client's <em>next</em> Firefox session. If the user shuts down their Firefox for the weekend, we won't get their Friday data until Monday morning.</p>
<p>A rule of thumb is data from two days ago is usually fairly representative.</p>
<p>If you'd like to read more about this subject and look at pretty graphs, there are a series of blog posts <a href="https://chuttenblog.wordpress.com/2017/02/09/data-science-is-hard-client-delays-for-crash-pings/">here</a>, <a href="https://chuttenblog.wordpress.com/2017/07/12/latency-improvements-or-yet-another-satisfying-graph/">here</a> and <a href="https://chuttenblog.wordpress.com/2017/09/12/two-days-or-how-long-until-the-data-is-in/">here</a>.</p>
<a class="header" href="#pingsender" id="pingsender"><h4>Pingsender</h4></a>
<p>Pingsender greatly reduces delay in sending pings to Mozilla, but only some types of pings are sent by Pingsender. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1310703">Bug 1310703</a> introduced Pingsender for crash pings and was merged in Firefox 54, which hit release on June 13, 2017. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1336360">Bug 1336360</a> moved shutdown pings to Pingsender and was merged in Firefox 55, which hit release on August 8, 2017. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1374270">Bug 1374270</a> added sending health pings on shutdown via Pingsender and was merged in Firefox 56, which hit release on Sept 28, 2017. Other types of pings are not sent with Pingsender. This is usually okay because Firefox is expected to continue running long enough to send those pings.</p>
<p>Mobile clients do not have Pingsender, so they suffer delay as given in <a href="https://sql.telemetry.mozilla.org/queries/49867#134105">this query</a>.</p>
<a class="header" href="#submission-date" id="submission-date"><h3>Submission Date</h3></a>
<p><code>submission_date</code> is the server time at which a ping is received from the client. We use it to
partition many of our data sets.</p>
<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1422892">bug 1422892</a> we decided to standardize
on <code>submission_date</code>.</p>
<p>TL;DR</p>
<ul>
<li>not subject to client clock skew</li>
<li>doesn't require normalization</li>
<li>good for backfill</li>
<li>good for daily processing</li>
<li>and usually good enough</li>
</ul>
<a class="header" href="#optimizing-sql-queries" id="optimizing-sql-queries"><h1>Optimizing SQL Queries</h1></a>
<p>After you write a query in <a href="https://sql.telemetry.mozilla.org">STMO</a>, you can make big steps to improve performance by
understanding how data is stored, what databases are doing under the covers, and what you can change about your query to
take advantage of those two pieces.</p>
<p>Note that this advice is most relevant for the <code>Presto</code>, <code>Athena</code>, and <code>Presto-Search</code> data sources, as well as <code>Spark SQL</code>
and Spark notebooks in general.</p>
<a class="header" href="#tldr-what-to-do-for-quick-improvements" id="tldr-what-to-do-for-quick-improvements"><h2>TL;DR: What to do for quick improvements</h2></a>
<ul>
<li>Switch to <a href="https://aws.amazon.com/athena/">Athena</a></li>
<li>Filter on a partitioned column† (<em>even</em> if you have a <code>LIMIT</code>)</li>
<li>Select the columns you want explicitly (Don't use <code>SELECT *</code>)</li>
<li>Use approximate algorithms: e.g. <code>approx_distinct(...)</code> instead of <code>COUNT(DISTINCT ...)</code></li>
</ul>
<p>† Partitioned columns can be identified in the Schema Explorer in <a href="https://sql.telemetry.mozilla.org">re:dash</a>.
They are the first few columns under a table name, and their name is preceded by a <code>[P]</code>.</p>
<a class="header" href="#some-explanations" id="some-explanations"><h2>Some Explanations</h2></a>
<p>There are a few key things to understand about our data storage and these databases to
learn how to properly optimize queries.</p>
<a class="header" href="#what-are-these-databases" id="what-are-these-databases"><h3>What are these databases?</h3></a>
<p>The databases we use are not traditional relational databases like PostgreSQL or MySQL. They are
distributed SQL engines, where the data is stored separately from the cluster itself. They
include multiple machines all working together in a coordinated fashion. This is why the
clusters can get slow when there are lots of competing queries - because the queries are
sharing resources.</p>
<p>Note that Athena is serverless, which is why we recommend people use that when they can.</p>
<a class="header" href="#how-does-this-impact-my-queries" id="how-does-this-impact-my-queries"><h4>How does this impact my queries?</h4></a>
<p>What that means is that multiple machines will be working together to get the result of your
query. Because there is more than one machine, we worry a lot about <em>Data Shuffles</em>: when all
of the machines have to send data around to all of the other machines.</p>
<p>For example, consider the following query, which gives the number of rows present for each
<code>client_id</code>:</p>
<pre><code>SELECT client_id, COUNT(*)
FROM main_summary
GROUP BY client_id
</code></pre>
<p>The steps that would happen are this:</p>
<ol>
<li>Each machine reads a different piece of the data, and parses out the <code>client_id</code> for
each row. Internally, it then computes the number of rows seen for each <code>client_id</code>,
<em>but only for the data that it read</em>.</li>
<li>Each machine is then given a set of <code>client_id</code>s to aggregate. For example, the first
machine may be told to get the count of <code>client1</code>. It will then have to ask every other
machine for the total seen for <code>client1</code>. It can then aggregate the total.</li>
<li>Given that every <code>client_id</code> has now been aggregated, each machine reports to the coordinator
the <code>client_id</code>s that it was responsible for, as well as the count of rows seen for each.
The coordinator is responsible for returning the result of the query to the client,
which in our example is STMO.</li>
</ol>
<p>A similar process happens on data joins, where different machines are told to join on
different keys. In that case, data from both tables needs to be shuffled to every machine.</p>
<a class="header" href="#why-do-we-have-multiple-databases-why-not-use-athena-for-everything" id="why-do-we-have-multiple-databases-why-not-use-athena-for-everything"><h4>Why do we have multiple databases? Why not use Athena for everything?</h4></a>
<p>Great question! Presto is something we control, and can upgrade it at-will. Athena is currently
a serverless version of Presto, and as such doesn't have all of the bells and whistles. For example,
it doesn't support <a href="https://prestodb.io/docs/current/functions/lambda.html">lambda expressions</a> or
UDFs, the latter of which we use in the <a href="../datasets/batch_view/client_count_daily/intro.html">Client Count Daily dataset</a>.</p>
<a class="header" href="#key-takeaways" id="key-takeaways"><h4>Key Takeaways</h4></a>
<ul>
<li>Use Athena, since it doesn't have the resource constraints that <code>Presto</code> or <code>Spark</code> do.</li>
<li>Use <code>LIMIT</code>. At the end of a query all the data needs to be sent to a single machine, using <code>LIMIT</code>
will reduce that amount and possible prevent an out of memory situation.</li>
<li>Use approximate algorithms. These mean less data needs to be shuffled, since we can use
probabilistic data structures instead of the raw data itself.</li>
<li>Specify large tables first in a <code>JOIN</code> operation. In this case, small tables can be sent to
every machine, eliminating one data shuffle operation. Note that Spark supports a <code>broadcast</code>
command explicitly.</li>
</ul>
<a class="header" href="#how-is-the-data-stored" id="how-is-the-data-stored"><h3>How is the data stored?</h3></a>
<p>The data is stored in columnar format. Let's try and understand that with an example.</p>
<a class="header" href="#traditional-row-stores" id="traditional-row-stores"><h4>Traditional Row Stores</h4></a>
<p>Consider a completely normal CSV file, which is actually an example of a row store.</p>
<pre><code>name,age,height
&quot;Ted&quot;,27,6.0
&quot;Emmanuel&quot;,45,5.9
&quot;Cadence&quot;,5,3.5
</code></pre>
<p>When this data is stored to disk, you could read an entire record in a consecutive order. For example if
the first <code>&quot;</code> was stored at block 1 on disk, then a sequential scan from 1 will give the first row of
data: <code>&quot;ted&quot;,27,6.0</code>. Keep scanning and you'll get <code>\n&quot;Emm</code>... and so on.</p>
<p>So for the above, the following query will be fast:</p>
<pre><code>SELECT *
FROM people
WHERE name == 'Ted'
</code></pre>
<p>Since the database can just scan the first row of data. However, the following is more difficult:</p>
<pre><code>SELECT name
FROM people
</code></pre>
<p>Now the database has to read <em>all</em> of the rows, and then pick out the <code>name</code> column. This is a lot
more overhead!</p>
<a class="header" href="#columnar-stores" id="columnar-stores"><h4>Columnar Stores</h4></a>
<p>Columnar turns the data sideways. For example, we can make a columnar version of the above data,
and still store it in CSV:</p>
<pre><code>name,&quot;Ted&quot;,&quot;Emmanuel&quot;,&quot;Cadence&quot;
age,27,45,5
height,6.0,5.9,3.5
</code></pre>
<p>Pretty easy! Now let's consider how we can query the data when it's stored this way.</p>
<pre><code>SELECT *
FROM people
WHERE name == &quot;ted&quot;
</code></pre>
<p>This query is pretty hard! We have to read all of the data now, because the
<code>(name, age, height)</code> isn't stored together.</p>
<p>Now let's consider our other query:</p>
<pre><code>SELECT name
FROM people
</code></pre>
<p>Suddenly, this is easy! We don't have to check in as many places for data,
we can just read the first few blocks of disks sequentially.</p>
<a class="header" href="#data-partitions" id="data-partitions"><h4>Data Partitions</h4></a>
<p>We can improve performance even further by taking advantage of partitions. These are entire files of data
that share a value for a column. So for example, if everyone in the <code>people</code> table lived in <code>DE</code>, then we
could add that to the filename: <code>/country=DE/people.csv</code>.</p>
<p>From there, our query engine would have to know how to read that path, and understand that it's telling us
that all of those people share a country. So if we were to query for this:</p>
<pre><code>SELECT *
FROM people
WHERE country == 'US'
</code></pre>
<p>The database wouldn't have to even read the file! It could just look at the path and realize there was
nothing of interest.</p>
<p>Our tables are often partitioned by date, e.g. <code>submission_date_s3</code>.</p>
<a class="header" href="#key-takeaways-1" id="key-takeaways-1"><h4>Key Takeaways</h4></a>
<ul>
<li>Limit queries to a specific few columns you need, to reduce the amount of data that has to be read</li>
<li>Filter on partitions to prune down the data you need</li>
</ul>
<a class="header" href="#getting-analysis-review" id="getting-analysis-review"><h1>Getting Analysis Review</h1></a>
<p>The current process for getting analysis review has not been optimized.
If you run into problems, feel free to ask in the <code>#datapipeline</code> channel on IRC.</p>
<a class="header" href="#table-of-contents-1" id="table-of-contents-1"><h2>Table of Contents</h2></a>
<ul>
<li><a href="#finding-a-reviewer">Finding a Reviewer</a>
<ul>
<li><a href="#data-reviewers">Data Reviewers</a></li>
</ul>
</li>
<li><a href="#jupyter-notebooks">Jupyter Notebooks</a>
<ul>
<li><a href="#rtmo">RTMO</a></li>
<li><a href="#start-a-repository">Start a Repository</a></li>
</ul>
</li>
</ul>
<a class="header" href="#finding-a-reviewer" id="finding-a-reviewer"><h1>Finding a Reviewer</h1></a>
<p>There are two major types of review for most analyses:
<strong>Data review</strong> and <strong>Methodology review</strong>.</p>
<p>A <strong>data reviewer</strong> has <strong>expert understanding of the dataset</strong> your analysis is based upon.
During data review, your reviewer will try to identify
any issues with your analysis that come from misapplying the data.
For example, sampling issues or data collection oddities.</p>
<p><strong>Methodology review</strong> primarily covers <strong>statistical concepts</strong>.
For example, if you're training regressions, forecasting data, or doing complex
statistical tests, you should probably get Methodology review.
Many (most?) analyses at Mozilla use simple aggregations and little to no statistical inference.
These analyses only require data review.</p>
<p>Accordingly, we suggest you <strong>first find a data reviewer for your analysis</strong>.
Your data reviewer will tell you if you should get methodology review
and will help you find a reviewer.</p>
<a class="header" href="#data-reviewers" id="data-reviewers"><h2>Data Reviewers</h2></a>
<p>To get review for your analysis,
contact one of the data reviewers listed for the dataset your analysis is based upon:</p>
<table><thead><tr><th align="left"> Dataset            </th><th align="left"> Reviewers   </th></tr></thead><tbody>
<tr><td align="left"> Longitudinal       </td><td align="left">             </td></tr>
<tr><td align="left"> Cross Sectional    </td><td align="left">             </td></tr>
<tr><td align="left"> Main Summary       </td><td align="left">             </td></tr>
<tr><td align="left"> Crash Summary      </td><td align="left">             </td></tr>
<tr><td align="left"> Crash Aggregate    </td><td align="left">             </td></tr>
<tr><td align="left"> Events             </td><td align="left">             </td></tr>
<tr><td align="left"> Sync Summary       </td><td align="left">             </td></tr>
<tr><td align="left"> Addons             </td><td align="left">             </td></tr>
<tr><td align="left"> Client Count Daily </td><td align="left">             </td></tr>
</tbody></table>
<a class="header" href="#jupyter-notebooks" id="jupyter-notebooks"><h1>Jupyter Notebooks</h1></a>
<p>It's difficult to review Jupyter notebooks on Github.
The notebook is stored as a JSON object, with python code stored in strings.
This makes <strong>commenting on particular lines very difficult</strong>.
Because the output is stored next to the code,
it's also very <strong>difficult to review the diff</strong> for a given notebook.</p>
<a class="header" href="#rtmo" id="rtmo"><h2>RTMO</h2></a>
<p>For simple notebooks, the best way to get review is through the
<a href="https://github.com/mozilla/mozilla-reports">knowledge repo</a>.
The knowledge repo renders your Jupyter notebooks to markdown
while keeping the original source code next to the document.
This gives your reviewer an <strong>easy-to-review markdown file</strong>.
Your analysis will also be available at
<a href="http://reports.telemetry.mozilla.org/feed">RTMO</a>.
This will aid discoverability and help others find your analysis.
Note that RTMO is public so your <strong>analysis will also be public</strong>.</p>
<a class="header" href="#start-a-repository" id="start-a-repository"><h2>Start a Repository</h2></a>
<p>Notebooks are great for presenting information,
but are not a good medium for storing code.
If your notebook contains complicated logic or a significant amount of custom code,
you should consider moving most of the logic to a python package.
Your reviewer may ask you for tests,
which also requires moving the code out of a notebook.</p>
<a class="header" href="#where-to-store-the-package" id="where-to-store-the-package"><h3>Where to store the package</h3></a>
<p>The data platform team maintains a python repository of analyses and ETL called
<a href="https://github.com/mozilla/python_mozetl"><code>python_mozetl</code></a>.
Feel free to file a pull request against that repository.
Your reviewer will provide analysis review during the code review.
You'll need review for each commit to <code>python_mozetl</code>'s master branch.</p>
<p>If you are still prototyping your job but want to move out of a Jupyter notebook,
take a look at
<a href="https://github.com/harterrt/cookiecutter-python-etl"><code>cookiecutter-python-etl</code></a>.
This tool will help you configure a new python repository
so you can hack quickly without getting review.</p>
<a class="header" href="#nbconvert" id="nbconvert"><h3>nbconvert</h3></a>
<p>The easiest way to get your code out of a Jupyter notebook
is to use <code>nbconvert</code> command from Jupyter.
If you have a notebook called <code>analysis.ipynb</code>
you can dump your analysis to a python script using the following command:</p>
<pre><code class="language-python">jupyter nbconvert --to python analysis.ipynb
</code></pre>
<p>You'll need to clean up some formatting in the resulting <code>analysis.py</code> file,
but most of the work has been done for you.</p>
<a class="header" href="#collecting-new-data" id="collecting-new-data"><h1>Collecting New Data</h1></a>
<a class="header" href="#guidelines" id="guidelines"><h2>Guidelines</h2></a>
<p>For information about what sorts of data may be collected,
and for information on getting a data collection request reviewed,
please read the <a href="https://wiki.mozilla.org/Firefox/Data_Collection">Data Collection Guidelines.</a></p>
<a class="header" href="#mechanics" id="mechanics"><h2>Mechanics</h2></a>
<p>The mechanics of how to instrument new data collection in Firefox are covered in
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/start/adding-a-new-probe.html">Adding a new Telemetry probe</a>.</p>
<p>For non-Telemetry data collection, we have a mechanism for streamlining
ingestion of structured (JSON) data that utilizes the same underlying
infrastructure. See <a href="../cookbooks/new_ping.html">this cookbook</a> for details on using it.</p>
<a class="header" href="#tools" id="tools"><h1>Tools</h1></a>
<p>This section describes tools we recommend using to analyze Firefox data.</p>
<a class="header" href="#projects" id="projects"><h1>Projects</h1></a>
<p>Below are a number of trailheads that lead into the projects and code that comprise the Firefox Data Platform.</p>
<a class="header" href="#telemetry-apis" id="telemetry-apis"><h2>Telemetry APIs</h2></a>
<table><thead><tr><th> Name and repo                      </th><th> Description                       </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/mozilla/python_moztelemetry"><code>python_moztelemetry</code></a>      </td><td> Python APIs for Mozilla Telemetry</td></tr>
<tr><td> <a href="https://github.com/mozilla/moztelemetry"><code>moztelemetry</code></a>               </td><td> Scala APIs for Mozilla Telemetry</td></tr>
<tr><td> <a href="https://github.com/mozilla/spark-hyperloglog"><code>spark-hyperloglog</code></a>   </td><td> Algebird's HyperLogLog support for Apache Spark</td></tr>
</tbody></table>
<a class="header" href="#etl-code-and-datasets" id="etl-code-and-datasets"><h2>ETL code and Datasets</h2></a>
<table><thead><tr><th> Name and repo                   </th><th> Description                           </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/mozilla/telemetry-batch-view"><code>telemetry-batch-view</code></a>   </td><td> Scala ETL code for derived datasets</td></tr>
<tr><td> <a href="https://github.com/mozilla/python_mozetl"><code>python_mozetl</code></a>        </td><td> Python ETL code for derived datasets</td></tr>
<tr><td> <a href="https://github.com/mozilla/telemetry-airflow"><code>telemetry-airflow</code></a>  </td><td> Airflow configuration and DAGs for scheduled jobs</td></tr>
<tr><td> <a href="https://github.com/mozilla/python_mozaggregator"><code>python_mozaggregator</code></a> </td><td> Aggregation job for <code>telemetry.mozilla.org</code> aggregates</td></tr>
<tr><td> <a href="https://github.com/mozilla/telemetry-streaming"><code>telemetry-streaming</code></a> </td><td> Spark Streaming ETL jobs for Mozilla Telemetry</td></tr>
</tbody></table>
<p>See also <a href="https://docs.telemetry.mozilla.org"><code>firefox-data-docs</code></a> for documentation on datasets.</p>
<a class="header" href="#infrastructure" id="infrastructure"><h2>Infrastructure</h2></a>
<table><thead><tr><th> Name and repo                         </th><th> Description                             </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas"><code>mozilla-pipeline-schemas</code></a> </td><td> JSON and Parquet Schemas for Mozilla Telemetry and other structured data</td></tr>
<tr><td> <a href="https://github.com/mozilla-services/hindsight"><code>hindsight</code></a>                     </td><td> Real-time data processing</td></tr>
<tr><td> <a href="https://github.com/mozilla-services/lua_sandbox"><code>lua_sandbox</code></a>                  </td><td> Generic sandbox for safe data analysis</td></tr>
<tr><td> <a href="https://github.com/mozilla-services/lua_sandbox_extensions"><code>lua_sandbox_extensions</code></a>      </td><td> Modules and packages that extend the Lua sandbox</td></tr>
<tr><td> <a href="https://github.com/mozilla-services/nginx_moz_ingest"><code>nginx_moz_ingest</code></a>             </td><td> Nginx module for Telemetry data ingestion</td></tr>
<tr><td> <a href="https://github.com/mozilla-services/puppet-config/tree/master/pipeline"><code>puppet-config</code></a>             </td><td> Cloud services puppet config for deploying infrastructure</td></tr>
<tr><td> <a href="https://github.com/mozilla/parquet2hive"><code>parquet2hive</code></a>                 </td><td> Hive import statement generator for Parquet datasets</td></tr>
</tbody></table>
<a class="header" href="#emr-bootstrap-scripts" id="emr-bootstrap-scripts"><h3>EMR Bootstrap scripts</h3></a>
<table><thead><tr><th> Name and repo                       </th><th> Description                             </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/mozilla/emr-bootstrap-spark"><code>emr-bootstrap-spark</code></a>   </td><td> AWS bootstrap scripts for Spark.</td></tr>
<tr><td> <a href="https://github.com/mozilla/emr-bootstrap-presto"><code>emr-bootstrap-presto</code></a> </td><td> AWS bootstrap scripts for Presto.</td></tr>
</tbody></table>
<a class="header" href="#data-applications" id="data-applications"><h2>Data applications</h2></a>
<table><thead><tr><th> Name and repo                     </th><th> Description                             </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/mozilla/telemetry-dashboard"><code>telemetry.mozilla.org</code></a> </td><td> Main entry point for viewing <a href="https://telemetry.mozilla.org">aggregate Telemetry data</a></td></tr>
<tr><td> <a href="https://github.com/mozilla/cerberus">Cerberus</a> &amp; <a href="https://github.com/mozilla/medusa">Medusa</a>   </td><td> Automatic alert system for telemetry aggregates</td></tr>
<tr><td> <a href="https://github.com/mozilla/telemetry-analysis-service"><code>analysis.t.m.o</code></a>       </td><td> <a href="https://analysis.telemetry.mozilla.org">Self serve data analysis platform</a></td></tr>
<tr><td> <a href="https://github.com/mozilla/missioncontrol">Mission Control</a>             </td><td> Low latency dashboard for stability and health metrics</td></tr>
<tr><td> <a href="https://github.com/mozilla/experiments-viewer">Experiments Viewer</a>          </td><td> Visualization for <a href="https://wiki.mozilla.org/index.php?title=Firefox/Shield">Shield</a> experiment results</td></tr>
<tr><td> <a href="https://github.com/mozilla/redash">Re:dash</a>                 </td><td> Mozilla's fork of the <a href="https://sql.telemetry.mozilla.org">data query / visualization system</a></td></tr>
<tr><td> <a href="https://github.com/mozilla/taar">TAAR</a>                      </td><td> Telemetry-aware addon recommender</td></tr>
<tr><td> <a href="https://github.com/mozilla/ensemble">Ensemble</a>              </td><td> A minimalist platform for publishing data</td></tr>
<tr><td> <a href="https://github.com/mozilla/firefox-hardware-report">Hardware Report</a>    </td><td> Firefox Hardware Report, <a href="https://hardware.metrics.mozilla.com/">available here</a></td></tr>
<tr><td> <a href="https://github.com/mozilla/python-zeppelin"><code>python-zeppelin</code></a>        </td><td> Convert Zeppelin notebooks to Markdown</td></tr>
<tr><td> <a href="https://github.com/mozilla/stmocli">St. Mocli</a>              </td><td> A command-line interface to <a href="https://sql.telemetry.mozilla.org">STMO</a></td></tr>
<tr><td> <a href="https://github.com/mozilla/probe-scraper">probe-scraper</a>                   </td><td> Scrape and publish Telemetry probe data from Firefox</td></tr>
<tr><td> <a href="https://github.com/mozilla/firefox-test-tube">test-tube</a>                       </td><td> Compare data across branches in experiments</td></tr>
<tr><td> <a href="https://github.com/mozilla/experimenter">experimenter</a>                    </td><td> A web application for managing experiments</td></tr>
<tr><td> <a href="https://github.com/mozilla/stmoab">St. Moab</a>                </td><td> Automatically generate Re:dash dashboard for A/B experiments</td></tr>
</tbody></table>
<a class="header" href="#reference-materials" id="reference-materials"><h2>Reference materials</h2></a>
<a class="header" href="#public" id="public"><h3>Public</h3></a>
<table><thead><tr><th> Name and repo                  </th><th> Description                             </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/mozilla/firefox-data-docs"><code>firefox-data-docs</code></a> </td><td> All the info you need to <a href="https://docs.telemetry.mozilla.org">answer questions about Firefox users with data</a></td></tr>
<tr><td> Firefox source docs            </td><td> <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/">Mozilla Source Tree Docs - Telemetry section</a></td></tr>
<tr><td> <a href="https://github.com/mozilla/mozilla-reports"><code>reports.t.m.o</code></a>     </td><td> Knowledge repository for <a href="https://reports.telemetry.mozilla.org">public reports</a></td></tr>
</tbody></table>
<a class="header" href="#non-public" id="non-public"><h3>Non-public</h3></a>
<table><thead><tr><th> Name and repo                  </th><th> Description                             </th></tr></thead><tbody>
<tr><td> <a href="https://github.com/mozilla/Fx-Data-Planning"><code>Fx-Data-Planning</code></a> </td><td> Quarterly goals and internal documentation</td></tr>
</tbody></table>
<a class="header" href="#an-overview-of-mozillas-data-pipeline" id="an-overview-of-mozillas-data-pipeline"><h1>An overview of Mozilla’s Data Pipeline</h1></a>
<p>This post describes the architecture of Mozilla’s data pipeline, which is used to collect Telemetry data from our users and logs from various services. One of the cool perks of working at Mozilla is that most of what we do is out in the open and because of that I can do more than just show you some diagram with arrows of our architecture; I can point you to the code, script &amp; configuration that underlies it!</p>
<p>To make the examples concrete, the following description is centered around the collection of Telemetry data. The same tool-chain is used to collect, store and analyze data coming from disparate sources though, such as service logs.</p>
<div class="mermaid">graph TD
  firefox((fa:fa-firefox Firefox))-->|JSON| elb
  elb[Load Balancer]-->|JSON| nginx
  nginx-->|JSON| landfill(fa:fa-database S3 Landfill)
  nginx-->|protobuf| kafka[fa:fa-files-o Kafka]
  kafka-->|protobuf| cep(Hindsight CEP)
  kafka-->|protobuf| dwl(Hindsight DWL)
  cep--> hsui(Hindsight UI)
  dwl-->|protobuf| datalake(fa:fa-database S3 Data Lake)
  dwl-->|parquet| datalake
  datalake-->|parquet| prestodb
  prestodb-->redash[fa:fa-line-chart Re:dash]
  datalake-->spark
  spark-->datalake
  airflow[fa:fa-clock-o Airflow]-->|Scheduled tasks|spark{fa:fa-star Spark}
  spark-->|aggregations|rdbms(fa:fa-database PostgreSQL)
  rdbms-->tmo[fa:fa-bar-chart TMO]
  rdbms-->cerberus[fa:fa-search-plus Cerberus]
<p>style firefox fill:#f61
style elb fill:#777
style nginx fill:green
style landfill fill:tomato
style datalake fill:tomato
style kafka fill:#aaa
style cep fill:palegoldenrod
style dwl fill:palegoldenrod
style hsui fill:palegoldenrod
style prestodb fill:cornflowerblue
style redash fill:salmon
style spark fill:darkorange
style airflow fill:lawngreen
style rdbms fill:cornflowerblue
style tmo fill:lightgrey
style cerberus fill:royalblue</p>
</div>
<a class="header" href="#firefox" id="firefox"><h1>Firefox</h1></a>
<p>There are different APIs and formats to <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/index.html">collect data</a> in Firefox, all suiting different use cases:</p>
<ul>
<li><a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/histograms.html">histograms</a> – for recording multiple data points;</li>
<li><a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/scalars.html">scalars</a> – for recording single values;</li>
<li><a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/measuring-time.html">timings</a> – for measuring how long operations take;</li>
<li><a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html">events</a> – for recording time-stamped events.</li>
</ul>
<p>These are commonly referred to as <em><a href="../../datasets/new_data.html">probes</a></em>. Each probe must declare the <a href="https://wiki.mozilla.org/Firefox/Data_Collection">collection policy</a> it conforms to: either <em>release</em> or <em>prerelease</em>. When adding a new measurement data-reviewers carefully inspect the probe and eventually approve the requested collection policy:</p>
<ul>
<li>Release data is collected from all Firefox users.</li>
<li>Prerelease data is collected from users on Firefox Nightly and Beta channels.</li>
</ul>
<p>Users may choose to turn the data collection off in preferences.</p>
<p>A <em>session</em> begins when Firefox starts up and ends when it shuts down. As a session could be long-running and last weeks, it gets sliced into smaller logical units called <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/concepts/sessions.html#subsessions">subsessions</a>. Each subsession generates a batch of data containing the current state of all probes collected so far, i.e. a <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">main ping</a>, which is sent to our servers. The main ping is just one of the many <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/concepts/pings.html#ping-types">ping types</a> we support. Developers can <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/custom-pings.html">create their own ping types</a> if needed.</p>
<p><em>Pings</em> are submitted via an <a href="https://dxr.mozilla.org/mozilla-central/rev/6a23526fe5168087d7e4132c0705aefcaed5f571/toolkit/components/telemetry/TelemetryController.jsm#202">API</a> that performs a HTTP POST request to our edge servers. If a ping fails to successfully <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/concepts/submission.html#submission">submit</a> (e.g. because of missing internet connection), Firefox will store the ping on disk and retry to send it until the maximum ping age is exceeded.</p>
<a class="header" href="#kafka" id="kafka"><h1>Kafka</h1></a>
<p>HTTP submissions coming in from the wild hit a <a href="https://aws.amazon.com/elasticloadbalancing/">load balancer</a> and then an NGINX <a href="https://github.com/mozilla-services/nginx_moz_ingest">module</a>. The <a href="https://github.com/mozilla-services/nginx_moz_ingest">module</a> accepts data via a <a href="https://wiki.mozilla.org/CloudServices/DataPipeline/HTTPEdgeServerSpecification">HTTP request</a> which it wraps in a Hindsight protobuf message and forwards to two places: a Kafka cluster and a short-lived S3 bucket (landfill) which acts as a fail-safe in case there is a processing error and/or data loss within the rest of the pipeline. The deployment scripts and configuration files of NGINX and Kafka live in a <a href="https://github.com/mozilla-services/puppet-config/tree/02f716a3e0df1117fc2494b41e85a1416f8e2a64/pipeline">private repository</a>.</p>
<p>The data from Kafka is read from the Complex Event Processors (CEP) and the Data Warehouse Loader (DWL), both of which use Hindsight.</p>
<a class="header" href="#hindsight" id="hindsight"><h1>Hindsight</h1></a>
<p><a href="https://github.com/mozilla-services/hindsight">Hindsight</a>, an open source stream processing software system developed by Mozilla as <a href="https://github.com/mozilla-services/heka">Heka</a>’s successor, is useful for a wide variety of different tasks, such as:</p>
<ul>
<li>converting data from one format to another;</li>
<li>shipping data from one location to another;</li>
<li>performing real time analysis, graphing, and anomaly detection.</li>
</ul>
<p>Hindsight’s core is a lightweight data processing kernel written in C that controls a set of Lua <a href="https://github.com/mozilla-services/hindsight/blob/9593668e84a642aff9dd95ccc648b6585948abfe/docs/index.md">plugins</a> executed inside a sandbox.</p>
<p>The CEP are custom plugins that are created, configured and deployed from an <a href="https://github.com/mozilla-services/hindsight_admin">UI</a> which produce real-time plots like the number of pings matching a certain criteria.  Mozilla employees can <a href="https://pipeline-cep.prod.mozaws.net/">access the UI</a> and create/deploy their own custom plugin in real-time without interfering with other plugins running.</p>
<p><img src="../../assets/CEP_custom_plugin.jpeg" alt="CEP Custom Plugin" title="CEP – a custom plugin in action" /></p>
<p>The DWL is composed of a set of plugins that transform, convert &amp; finally shovel pings into S3 for long term storage. In the specific case of Telemetry data, an input plugin <a href="https://github.com/mozilla-services/lua_sandbox_extensions/blob/0895238e32d25241ef46f561e43039beb201c7cd/kafka/sandboxes/heka/input/kafka.lua">reads pings from Kafka</a>, <a href="https://github.com/mozilla-services/lua_sandbox_extensions/blob/5d8907ee9f1a20e3a02bfe5b57d4312b173487a3/moz_telemetry/io_modules/decoders/moz_telemetry/ping.lua">pre-processes</a> them and <a href="https://github.com/mozilla-services/lua_sandbox_extensions/blob/5d8907ee9f1a20e3a02bfe5b57d4312b173487a3/moz_telemetry/sandboxes/heka/output/moz_telemetry_s3.lua">sends batches to S3</a>, our data lake, for long term storage. The data is compressed and partitioned by a set of dimensions, like date and application.</p>
<p>The data has traditionally been serialized to <a href="https://hekad.readthedocs.io/en/latest/message/index.html#stream-framing">Protobuf</a> sequence files which contain some nasty “free-form” JSON fields. Hindsight gained recently the ability to <a href="https://github.com/mozilla-services/lua_sandbox_extensions/pull/48">dump data directly in Parquet form</a> though.</p>
<p>The deployment scripts and configuration files of the CEP &amp; DWL live in a <a href="https://github.com/mozilla-services/puppet-config/tree/02f716a3e0df1117fc2494b41e85a1416f8e2a64/pipeline">private repository</a>.</p>
<a class="header" href="#spark" id="spark"><h1>Spark</h1></a>
<p>Once the data reaches our data lake on S3 it can be processed with Spark. We provide a portal (<a href="https://analysis.telemetry.mozilla.org/">ATMO</a>) that allows Mozilla employees to create their own Spark cluster pre-loaded with a set of libraries &amp; tools, like Jupyter, NumPy, SciPy, Pandas etc., and <a href="https://python-moztelemetry.readthedocs.io/en/stable/api.html#module-moztelemetry.dataset">an API</a> to conveniently read data stored in Protobuf form on S3 in a Spark RDD using a ORM-like interface. Behind the scenes we use <a href="https://github.com/mozilla/emr-bootstrap-spark/">EMR</a> to create Spark clusters, which are then monitored by ATMO.</p>
<p><img src="../../assets/ATMO_example.jpeg" alt="ATMO" title="ATMO – monitoring clusters" /></p>
<p>ATMO is mainly used to write custom analyses; since our users aren’t necessary data engineers/scientists we chose Python as the main supported language to interface with Spark. From ATMO it’s also possible to schedule periodic notebook runs and inspect the results from a web UI.</p>
<p>As mentioned earlier, most of our data lake contains data serialized to Protobuf with free-form JSON fields. Needless to say, parsing JSON is terribly slow when ingesting Terabytes of data per day. A set of <a href="https://github.com/mozilla/telemetry-batch-view">ETL jobs</a>, written in Scala by Data Engineers and scheduled with <a href="https://github.com/mozilla/telemetry-airflow/">Airflow</a>, create <a href="../choosing_a_dataset.html">Parquet views</a> of our raw data. We have a Github repository <a href="https://github.com/mozilla/telemetry-batch-view/">telemetry-batch-view</a> that showcases this.</p>
<a class="header" href="#aggregates-dataset" id="aggregates-dataset"><h1>Aggregates Dataset</h1></a>
<div class="mermaid">graph TD
%% Data Flow Diagram for mozaggregator/TMO-adjacent services
firefox((fa:fa-firefox Firefox)) --> |main ping| pipeline
fennec((fa:fa-firefox Fennec)) --> |saved-session ping| pipeline
pipeline((Telemetry Pipeline))
<p>subgraph mozaggregator
service(service)
aggregator
rdbms(fa:fa-database PostgreSQL)
end</p>
<p>pipeline --&gt; aggregator
pipeline --&gt; spark{fa:fa-star Spark}
pipeline --&gt; redash[fa:fa-line-chart Re:dash]</p>
<p>subgraph telemetry.mozilla.org
telemetry.js(telemetry.js) --&gt; dist
telemetry.js --&gt; evo
orphan[Update Orphaning]
crashdash[tmo/crashes]
end</p>
<p>redash --&gt; crashdash
service --&gt; telemetry.js
spark --&gt; orphan</p>
<p>telemetry.js --&gt; telemetry-next-node(telemetry-next-node)
subgraph alerts.tmo
cerberus[fa:fa-search-plus Cerberus] --&gt;medusa
medusa --&gt; html
medusa --&gt; email
end</p>
<p>telemetry-next-node --&gt; cerberus</p>
<p>style redash fill:salmon
style spark fill:darkorange
style rdbms fill:cornflowerblue
style cerberus fill:royalblue
style firefox fill:#f61
style fennec fill:#f61
style telemetry.js fill:lightgrey
style dist fill:lightgrey
style evo fill:lightgrey</p>
</div>
<p>A dedicated Spark job feeds daily aggregates to a PostgreSQL database which powers a <a href="https://github.com/mozilla/python_mozaggregator/#api">HTTP service</a> to easily retrieve faceted roll-ups. The service is mainly used by <a href="https://telemetry.mozilla.org/">TMO</a>, a dashboard that visualizes distributions and time-series, and <a href="https://github.com/mozilla/cerberus/">Cerberus</a>, an anomaly detection tool that detects and alerts developers of changes in the distributions. Originally the sole purpose of the Telemetry pipeline was to feed data into this dashboard but in time its scope and flexibility grew to support more general use-cases.</p>
<p><img src="../../assets/TMO_example.jpeg" alt="TMO" title="TMO – timeseries" /></p>
<a class="header" href="#presto--redash" id="presto--redash"><h1>Presto &amp; re:dash</h1></a>
<p>We maintain a couple of <a href="https://github.com/mozilla/emr-bootstrap-presto">Presto clusters</a> and a centralized Hive metastore to query Parquet data with SQL. The Hive metastore provides an universal view of our Parquet dataset to both Spark and Presto clusters.</p>
<p>Presto, and other databases, are behind a <a href="https://sql.telemetry.mozilla.org/">re:dash</a> service (<a href="https://sql.telemetry.mozilla.org/">STMO</a>) which provides a convenient &amp; powerful interface to query SQL engines and build dashboards that can be shared within the company. Mozilla maintains its own <a href="https://github.com/mozilla/redash">fork of re:dash</a> to iterate quickly on new features, but as good open source citizen we push our changes upstream.</p>
<p><img src="../../assets/STMO_example.jpeg" alt="STMO" title="STMO – who doesn’t love SQL?" /></p>
<a class="header" href="#is-that-it" id="is-that-it"><h1>Is that it?</h1></a>
<p>No, not really. If you want to read more, check out <a href="data_pipeline_detail.html">this article</a>. For example, the DWL pushes some of the Telemetry data to Redshift and other tools that satisfy more niche needs. The pipeline ingests logs from services as well and there are many specialized dashboards out there I haven’t mentioned. We also use <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1369519">Zeppelin</a> as a means to create interactive data analysis notebooks that supports Spark, SQL, Scala and more.</p>
<p>There is a vast ecosystem of tools for processing data at scale, each with their pros &amp; cons. The pipeline grew organically and we added new tools as new use-cases came up that we couldn’t solve with our existing stack. There are still scars left from that growth though which require some effort to get rid of, like ingesting data from schema-less format.</p>
<a class="header" href="#a-detailed-look-at-the-data-platform" id="a-detailed-look-at-the-data-platform"><h1>A Detailed Look at the Data Platform</h1></a>
<p>For a more gentle introduction to the data platform, please read the <a href="data_pipeline.html">Pipeline Overview</a> article.</p>
<p>This article goes into more depth about the architecture and flow of data in the platform.</p>
<a class="header" href="#the-entire-platform" id="the-entire-platform"><h2>The Entire Platform</h2></a>
<p>The full detail of the platform can get quite complex, but at a high level the structure is fairly simple.</p>
<div class="mermaid">graph LR
  Producers[Data Producers] --> Ingestion
  Ingestion --> Storage[Long-term Storage]
  Ingestion --> Stream[Stream Processing]
  Stream --> Storage
  Batch[Batch Processing] --> Storage
  Storage --> Batch
  Self[Self Serve] -.- Stream
  Self -.- Batch
  Stream -.-> Visualization
  Batch -.-> Visualization
  Stream --> Export
  Batch --> Export
</div>
<p>Each of these high-level parts of the platform are described in more detail below.</p>
<a class="header" href="#data-producers" id="data-producers"><h2>Data Producers</h2></a>
<p>By far most data handled by the Data Platform is <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">produced by Firefox</a>. There are other producers, though, and the eventual aim is to generalize data production using a client SDK or set of standard tools.</p>
<p>Most data is submitted via HTTP POST, but data is also produced in the form of service logs and <code>statsd</code> messages.</p>
<p>If you would like to locally test a new data producer, the <a href="https://github.com/mozilla/gzipServer"><code>gzipServer</code></a> project provides a simplified server that makes it easy to inspect submitted messages.</p>
<a class="header" href="#ingestion" id="ingestion"><h2>Ingestion</h2></a>
<div class="mermaid">graph LR
  subgraph HTTP
    tee
    lb[Load Balancer]
    mozingest
  end
  subgraph Kafka
    kafka_unvalidated[Kafka unvalidated]
    kafka_validated[Kafka validated]
    zookeeper[ZooKeeper] -.- kafka_unvalidated
    zookeeper -.- kafka_validated
  end
  subgraph Storage
    s3_heka[S3 Heka Protobuf Storage]
    s3_parquet[S3 Parquet Storage]
  end
  subgraph Data Producers
    Firefox --> lb
    more_producers[Other Producers] --> lb
  end
<p>lb --&gt; tee
tee --&gt; mozingest
mozingest --&gt; kafka_unvalidated
mozingest --&gt; Landfill
kafka_unvalidated --&gt; dwl[Data Store Loader]
kafka_validated --&gt; cep[Hindsight CEP]
kafka_validated --&gt; sparkstreaming[Spark Streaming]
Schemas -.-&gt;|validation| dwl
dwl --&gt; kafka_validated
dwl --&gt; s3_heka
dwl --&gt; s3_parquet
sparkstreaming --&gt; s3_parquet</p>
</div>
<p>Data arrives as an HTTP POST of an optionally gzipped payload of JSON. See the common <a href="http_edge_spec.html">Edge Server</a> specification for details.</p>
<p>Submissions hit a load balancer which handles the SSL connection, then forwards to a &quot;tee&quot; server, which may direct some or all submissions to alternate backends. In the past, the tee was used to manage the <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1302265">cutover between different versions of the backend</a> infrastructure. It is implemented as an <a href="http://openresty.org/en/"><code>OpenResty</code></a> plugin.</p>
<p>From there, the <a href="https://github.com/mozilla-services/nginx_moz_ingest"><code>mozingest</code></a> HTTP Server receives submissions from the tee and batches and stores data durably on Amazon S3 as a fail-safe (we call this &quot;Landfill&quot;). Data is then passed along via <a href="https://kafka.apache.org/">Kafka</a> for validation and further processing. If there is a problem with decoding, validation, or any of the code described in the rest of this section, data can be re-processed from this fail-safe store. The <code>mozingest</code> server is implemented as an <code>nginx</code> module.</p>
<p>Validation, at a minimum, ensures that a payload is valid JSON (possibly compressed). Many document types also have a <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas">JSONSchema specification</a>, and are further validated against that.</p>
<p>Invalid messages are redirected to a separate &quot;errors&quot; stream for debugging and inspection.</p>
<p>Valid messages proceed for further decoding and processing. This involves things like doing GeoIP lookup and discarding the IP address, and attaching some HTTP header info as annotated metadata.</p>
<p>Validated and annotated messages become available for stream processing.</p>
<p>They are also batched and stored durably for later batch processing and ad-hoc querying.</p>
<p>See also the &quot;<a href="https://docs.google.com/document/d/1PqiF1rF2fCk_kQuGSwGwildDf4Crg9MJTY44E6N5DSk/edit">generic ingestion</a>&quot; proposal which aims to make ingestion, validation, storage, and querying available as self-serve for platform users.</p>
<a class="header" href="#data-flow-for-valid-submissions" id="data-flow-for-valid-submissions"><h5>Data flow for valid submissions</h5></a>
<div class="mermaid">sequenceDiagram
    participant Fx as Firefox
    participant lb as Load Balancer
    participant mi as mozingest
    participant lf as Landfill
    participant k as Kafka
    participant dwl as Data Store Loader
    participant dl as Data Lake
<pre><code>Fx-&gt;&gt;lb: HTTPS POST
lb-&gt;&gt;mi: forward
mi--&gt;&gt;lf: failsafe store
mi-&gt;&gt;k: enqueue
k-&gt;&gt;dwl: validate, decode
dwl-&gt;&gt;k: enqueue validated
dwl-&gt;&gt;dl: store durably
</code></pre>
</div>
<a class="header" href="#other-ingestion-methods" id="other-ingestion-methods"><h5>Other ingestion methods</h5></a>
<p>Hindsight is used for <a href="https://mozilla-services.github.io/lua_sandbox_extensions/moz_logging/">ingestion of logs</a> from applications and services, it supports parsing of log lines and appending similar metadata as the HTTP ingestion above (timestamp, source, and so on).</p>
<p><a href="https://github.com/etsy/statsd"><code>Statsd</code></a> messages are ingested in the usual way.</p>
<a class="header" href="#storage" id="storage"><h2>Storage</h2></a>
<div class="mermaid">graph TD
  subgraph RDBMS
    PostgreSQL
    Redshift
    MySQL
    BigQuery
  end
  subgraph NoSQL
    DynamoDB
  end
  subgraph S3
    landfill[Landfill]
    s3_heka[Heka Data Lake]
    s3_parquet[Parquet Data Lake]
    s3_analysis[Analysis Outputs]
    s3_public[Public Outputs]
  end
<p>Ingestion --&gt; s3_heka
Ingestion --&gt; s3_parquet
Ingestion --&gt; landfill
Ingestion -.-&gt; stream[Stream Processing]
stream --&gt; s3_parquet
batch[Batch Processing] --&gt; s3_parquet
batch --&gt; PostgreSQL
batch --&gt; DynamoDB
batch --&gt; s3_public
selfserve[Self Serve] --&gt; s3_analysis
s3_analysis --&gt; selfserve
Hive --&gt;|Presto| redash[Re:dash]
PostgreSQL --&gt; redash
Redshift --&gt; redash
MySQL --&gt; redash
BigQuery --&gt; redash</p>
<p>s3_parquet -.- Hive</p>
</div>
<p><a href="https://aws.amazon.com/s3/">Amazon S3</a> forms the backbone of the platform storage layer. The primary format used in the Data Lake is <a href="http://parquet.apache.org/">parquet</a>, which is a strongly typed columnar storage format that can easily be read and written by <a href="https://spark.apache.org/docs/latest/index.html">Spark</a>, as well as being compatible with SQL interfaces such as <a href="https://cwiki.apache.org/confluence/display/Hive/Home">Hive</a> and <a href="http://prestodb.io/">Presto</a>. Some data is also stored in <a href="https://hekad.readthedocs.io/en/dev/message/index.html#stream-framing">Heka-framed protobuf</a> format. This custom format is usually reserved for data where we do not have a complete <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas">JSONSchema specification</a>.</p>
<p>Using S3 for storage avoids the need for an always-on cluster, which means that data at rest is inexpensive. S3 also makes it very easy to automatically expire (delete) objects after a certain period of time, which is helpful for implementing data retention policies.</p>
<p>Once written to S3, the data is typically treated as immutable - data is not appended to existing files, nor is data normally updated in place. The exception here is when data is back-filled, in which case previous data may be overwritten.</p>
<p>There are a number of other types of storage used for more specialized applications, including relational databases (such as PostgreSQL for the <a href="https://github.com/mozilla/python_mozaggregator/#api">Telemetry Aggregates</a>) and NoSQL databases (DynamoDB is used for a backing store for the <a href="https://github.com/mozilla/python_mozetl/blob/master/mozetl/taar/taar_dynamo.py">TAAR project</a>). Reading data from a variety of RDBMS sources is also supported via Re:dash.</p>
<p>The data stored in Heka format is <a href="../../tools/spark.html">readable from Spark</a> using libraries in <a href="https://github.com/mozilla/moztelemetry/blob/master/src/main/scala/com/mozilla/telemetry/heka/Dataset.scala">Scala</a> or <a href="https://python-moztelemetry.readthedocs.io/en/latest/api.html#dataset">Python</a>.</p>
<p>Parquet data can be read and written natively from Spark, and many datasets are indexed in a <a href="https://cwiki.apache.org/confluence/display/Hive/Home">Hive</a> Metastore, making them available through a SQL interface on Re:dash and in notebooks via Spark SQL. Many other SQL data sources are also made available via Re:dash, see <a href="../../tools/stmo.html">this article</a> for more information on accessing data using SQL.</p>
<p>There is a separate data store for self-serve <strong>Analysis Outputs</strong>, intended to keep ad-hoc, temporary data out of the Data Lake. This is implemented as a separate S3 location, with personal output locations prefixed with each person's user id, similar to the layout of the <code>/home</code> directory on a Unix system. See the <a href="https://docs.telemetry.mozilla.org/cookbooks/parquet.html#where-to-save-data">Working with Parquet data</a> cookbook for more details.</p>
<p>Analysis outputs can also be made public using the <strong>Public Outputs</strong> bucket. This is a web-accessible S3 location for powering public dashboards. This public data is available at <code>https://analysis-output.telemetry.mozilla.org/&lt;job name&gt;/data/&lt;files&gt;</code>.</p>
<a class="header" href="#stream-processing" id="stream-processing"><h2>Stream Processing</h2></a>
<p>Stream processing is done using <a href="https://github.com/mozilla-services/hindsight">Hindsight</a> and <a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html">Spark Streaming</a>.</p>
<p>Hindsight allows you to run <a href="http://mozilla-services.github.io/lua_sandbox/">plugins written in Lua inside a sandbox</a>. This gives a safe, performant way to do self-serve streaming analysis. See <a href="../../cookbooks/realtime_analysis_plugin.html">this article</a> for an introduction. Hindsight plugins do the initial data validation and decoding, as well as writing out to long-term storage in both <a href="https://hekad.readthedocs.io/en/dev/message/index.html#stream-framing">Heka-framed protobuf</a> and <a href="https://mozilla-services.github.io/lua_sandbox_extensions/parquet/">parquet</a> forms.</p>
<p>Spark Streaming is used to read from Kafka and perform <a href="https://github.com/mozilla/telemetry-streaming">low-latency ETL and aggregation tasks</a>. These aggregates are currently used by <a href="https://data-missioncontrol.dev.mozaws.net">Mission Control</a> and are also available for querying via <a href="https://sql.telemetry.mozilla.org">Re:dash</a>.</p>
<a class="header" href="#batch-processing" id="batch-processing"><h2>Batch Processing</h2></a>
<p>Batch processing is done using <a href="https://spark.apache.org/docs/latest/index.html">Spark</a>. Production ETL code is written in both <a href="https://github.com/mozilla/python_mozetl">Python</a> and <a href="https://github.com/mozilla/telemetry-batch-view">Scala</a>.</p>
<p>There are <a href="https://python-moztelemetry.readthedocs.io/en/latest/api.html#dataset">Python</a> and <a href="https://github.com/mozilla/moztelemetry/blob/master/src/main/scala/com/mozilla/telemetry/heka/Dataset.scala">Scala</a> libraries for reading data from the Data Lake in <a href="https://hekad.readthedocs.io/en/dev/message/index.html#stream-framing">Heka-framed protobuf</a> form, though it is much easier and more performant to make use of a <a href="../../concepts/choosing_a_dataset.html">derived dataset</a> whenever possible.</p>
<p>Datasets in parquet format can be read natively by Spark, either using Spark SQL or by reading data directly from S3.</p>
<p>Data produced by production jobs go into the Data Lake, while output from ad-hoc jobs go into Analysis Outputs.</p>
<p>Job scheduling and dependency management is done using <a href="https://github.com/mozilla/telemetry-airflow">Airflow</a>. Most jobs run once a day, processing data from &quot;yesterday&quot; on each run. A typical job launches a cluster, which fetches the specified ETL code as part of its bootstrap on startup, runs the ETL code, then shuts down upon completion. If something goes wrong, a job may time out or fail, and in this case it is retried automatically.</p>
<a class="header" href="#self-serve-data-analysis" id="self-serve-data-analysis"><h2>Self Serve Data Analysis</h2></a>
<div class="mermaid">graph TD
  subgraph Storage
    lake[Data Lake]
    s3_output_public[Public Outputs]
    s3_output_private[Analysis Outputs]
  end
  subgraph ATMO
    Jupyter -->|runs on| emr_cluster[Ad hoc EMR Cluster]
    Zeppelin -->|runs on| emr_cluster
    atmo_service[ATMO Service] -->|launch| emr_cluster
    atmo_service -->|schedule| emr_job[fa:fa-clock-o Scheduled EMR Job]
    emr_cluster -->|mount| EFS
    emr_cluster -->|read + write| lake
    emr_job -->|read + write| s3_output_public
    emr_job -->|read + write| s3_output_private
  end
  subgraph STMO
    redash[Re:dash] -->|read| lake
  end
  subgraph TMO
    evo[Evolution Dashboard]
    histo[Histogram Dashboard]
    agg[Telemetry Aggregates]
    evo -.- agg
    histo -.- agg
  end
  subgraph Databricks
    db_notebook[Notebook]
    db_notebook -->|read + write| lake
  end
</div>
<p>Most of the data analysis tooling has been developed with the goal of being &quot;self-serve&quot;. This means that people should be able to access and analyze data on their own, without involving data engineers or operations. Thus can data access scale beyond a small set of people with specialized knowledge of the entire pipeline.</p>
<p>The use of these self-serve tools is described in the <a href="../../concepts/analysis_intro.html">Getting Started</a> article. This section focuses on how these tools integrate with the platform infrastructure.</p>
<a class="header" href="#atmo-spark-analysis" id="atmo-spark-analysis"><h5>ATMO: Spark Analysis</h5></a>
<p><a href="https://analysis.telemetry.mozilla.org">ATMO</a> is a service for managing Spark clusters for data analysis. Clusters can be launched on demand, or can be scheduled to run a job on an ongoing basis. These clusters can read from the Data Lake described in the <strong>Storage</strong> section above, and can write results to either public (web-accessible) or private output locations.</p>
<p>Jupyter or Zeppelin notebooks are the usual interface to getting work done using a cluster, though you get full SSH access to the cluster.</p>
<p>Clusters launched via ATMO are automatically killed after a user-defined period of time (by default, 8 hours), though their lifetime can be extended as needed. Each cluster has a user-specific <strong><code>EFS</code></strong> volume mounted on the <code>/home/hadoop</code> directory, which means that data stored locally on the cluster persists from one cluster to the next. This volume is shared by all clusters launched by a given ATMO user.</p>
<a class="header" href="#stmo-sql-analysis" id="stmo-sql-analysis"><h5>STMO: SQL Analysis</h5></a>
<p><a href="../../tools/stmo.html">STMO</a> is a customized <a href="https://sql.telemetry.mozilla.org">Re:dash</a> installation that provides self-serve access to a a variety of different <a href="../../concepts/choosing_a_dataset.html">datasets</a>. From here, you can query data in the Parquet Data Lake as well as various RDBMS data sources.</p>
<p>STMO interfaces with the data lake using both <a href="http://prestodb.io/">Presto</a> and Amazon <a href="https://aws.amazon.com/athena/">Athena</a>. Each has its own data source in Re:dash. Since Athena does not support user-defined functions, datasets with HyperLogLog columns, such as <a href="../../datasets/batch_view/client_count_daily/intro.html"><code>client_count_daily</code></a>, are only available via Presto..</p>
<p>Different <strong>Data Sources</strong> in STMO connect to different backends, and each backend might use a slightly different flavor of SQL. You should find a link to the documentation for the expected SQL variant next to the Data Sources list.</p>
<p>Queries can be run just once, or scheduled to run periodically to keep data up-to-date.</p>
<p>There is a command-line interface to STMO called <a href="https://github.com/mozilla/stmocli">St. Mocli</a>, if you prefer writing SQL using your own editor and tools.</p>
<a class="header" href="#databricks-managed-spark-analysis" id="databricks-managed-spark-analysis"><h5>Databricks: Managed Spark Analysis</h5></a>
<p>Our <a href="https://dbc-caf9527b-e073.cloud.databricks.com">Databricks instance</a> (see <a href="https://docs.databricks.com/user-guide/notebooks/index.html">Databricks docs</a>) offers another notebook interface for doing analysis in Scala, SQL, Python and R.</p>
<p>Databricks provides an always-on shared server which is nice for quick data investigations. ATMO clusters take some time to start up, usually on the order of tens of minutes. The shared server allows you to avoid this start-up cost. Prefer ATMO for heavy analyses since you will have dedicated resources.</p>
<a class="header" href="#tmo-aggregate-graphs" id="tmo-aggregate-graphs"><h5>TMO: Aggregate Graphs</h5></a>
<p><a href="https://telemetry.mozilla.org">TMO</a> provides easy visualizations of histogram and scalar measures over time. Time can be in terms of either builds or submission dates. This is the most convenient interface to the Telemetry data, as it does not require any custom code.</p>
<a class="header" href="#visualization" id="visualization"><h2>Visualization</h2></a>
<p>There are a number of visualization libraries and tools being used to display data.</p>
<a class="header" href="#tmo-dashboards" id="tmo-dashboards"><h5>TMO Dashboards</h5></a>
<p>The landing page at <a href="https://telemetry.mozilla.org"><code>telemetry.mozilla.org</code></a> is a good place to look for existing graphs, notably the <a href="https://telemetry.mozilla.org/new-pipeline/dist.html">measurement dashboard</a> which gives a lot of information about histogram and scalar measures collected on pre-release channels.</p>
<a class="header" href="#notebooks" id="notebooks"><h5>Notebooks</h5></a>
<p>Use of interactive notebooks has become a standard in the industry, and Mozilla makes heavy use of this approach. <a href="https://analysis.telemetry.mozilla.org">ATMO</a> makes it easy to run, share, and schedule <a href="https://jupyter.org/">Jupyter</a> and <a href="https://zeppelin.apache.org/">Zeppelin</a> notebooks.</p>
<p><a href="https://docs.databricks.com/user-guide/notebooks/index.html">Databricks notebooks</a> are also an option.</p>
<a class="header" href="#others" id="others"><h5>Others</h5></a>
<p><a href="https://sql.telemetry.mozilla.org">Re:dash</a> lets you query the data using SQL, but it also supports a number of useful visualizations.</p>
<p><a href="http://pipeline-cep.prod.mozaws.net/">Hindsight's web interface</a> has the ability to visualize time-series data.</p>
<p><a href="https://data-missioncontrol.dev.mozaws.net">Mission Control</a> gives a low-latency view into release health.</p>
<p>Many bespoke visualizations are built using the <a href="http://metricsgraphicsjs.org/">Metrics Graphics</a> library as a display layer.</p>
<a class="header" href="#monitoring-and-alerting" id="monitoring-and-alerting"><h2>Monitoring and Alerting</h2></a>
<p>There are multiple layers of monitoring and alerting.</p>
<p>At a low level, the system is monitored to ensure that it is functioning as expected. This includes things like machine-level resources (network capacity, disk space, available RAM, CPU load) which are typically monitored using <a href="http://datadoghq.com/">DataDog</a>.</p>
<p>Next, we monitor the &quot;transport&quot; functionality of the system. This includes monitoring incoming submission rates, payload sizes, traffic patterns, schema validation failure rates, and alerting if anomalies are detected. This type of anomaly detection and alerting is handled by <a href="https://github.com/mozilla-services/hindsight">Hindsight</a>.</p>
<p>Once data has been safely ingested and stored, we run some automatic regression detection on all Telemetry <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/histograms.html">histogram measures</a> using <a href="https://github.com/mozilla/cerberus">Cerberus</a>. This code looks for changes in the distribution of a measure, and emails probe owners if a significant change is observed.</p>
<p>Production ETL jobs are run via <a href="https://github.com/mozilla/telemetry-airflow">Airflow</a>, which monitors batch job progress and alerts if there are failures in any job. Self-serve batch jobs run via ATMO also generate alerts upon failure.</p>
<p>Scheduled <a href="https://sql.telemetry.mozilla.org">Re:dash</a> queries may also be configured to generate alerts, which is used to monitor the last-mile user facing status of derived datasets. Re:dash may also be used to monitor and alert on high-level characteristics of the data, or really anything you can think of.</p>
<a class="header" href="#data-exports" id="data-exports"><h2>Data Exports</h2></a>
<p>Data is exported from the pipeline to a few other tools and systems. Examples include integration with <a href="https://amplitude.com/">Amplitude</a> for mobile and product analytics, publishing reports and visualizations to the <a href="https://www.mozdatacollective.com/home">Mozilla Data Collective</a>, and shipping data to other parts of the Mozilla organization.</p>
<p>There are also a few data sets which are made publicly available, such as the <a href="https://hardware.metrics.mozilla.com/">Firefox Hardware Report</a>.</p>
<a class="header" href="#bringing-it-all-together" id="bringing-it-all-together"><h2>Bringing it all together</h2></a>
<p>Finally, here is a more detailed view of the entire platform. Some connections are omitted for clarity.</p>
<div class="mermaid">graph LR
 subgraph Data Producers
  Firefox
  more_producers[...]
 end
 subgraph Storage
  Landfill
  warehouse_heka[Heka Data Lake]
  warehouse_parquet[Parquet Data Lake]
  warehouse_analysis[Analysis Outputs]
  PostgreSQL
  Redshift
  MySQL
  hive[Hive] -.- warehouse_parquet
 end
 subgraph Stream Processing
  cep[Hindsight Streaming]
  dwl[Data Store Loader] --> warehouse_heka
  dwl --> warehouse_parquet
  sparkstreaming[Spark Streaming] --> warehouse_parquet
 end
 subgraph Ingestion
  Firefox --> lb[Load Balancer]
  more_producers --> lb
  lb --> tee
  tee --> mozingest
  mozingest --> kafka
  mozingest --> Landfill
  ZooKeeper -.- kafka[Kafka]
  kafka --> dwl
  kafka --> cep
  kafka --> sparkstreaming
 end
 subgraph Batch Processing
  Airflow -.->|spark|tbv[telemetry-batch-view]
  Airflow -.->|spark|python_mozetl
  warehouse_heka --> tbv
  warehouse_parquet --> tbv
  warehouse_heka --> python_mozetl
  warehouse_parquet --> python_mozetl
  tmo_agg[Telemetry Aggregates]
 end
 subgraph Visualization
  Hindsight
  Jupyter
  Zeppelin
  TMO
  redash_graphs[Re:dash]
  MissionControl
  bespoke_viz[Bespoke Viz]
 end
 subgraph Export
  tbv --> Amplitude
  sparkstreaming --> Amplitude
 end
 subgraph Self Serve
  redash[Re:dash] -.-> Presto
  Presto --> hive
  redash -.-> Athena
  Athena --> hive
  ATMO -.-> spcluster[Spark Cluster]
  warehouse_heka --> spcluster
  warehouse_parquet --> spcluster
  spcluster --> warehouse_analysis
 end
 Schemas -.->|validation| dwl
</div>
<a class="header" href="#http-edge-server-specification" id="http-edge-server-specification"><h1>HTTP Edge Server Specification</h1></a>
<p>This document specifies the behavior of the server that accepts submissions from
any HTTP client e.g. Firefox telemetry.</p>
<p>The original implementation of the HTTP Edge Server was tracked in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1129222">Bug 1129222</a>.</p>
<a class="header" href="#general-data-flow" id="general-data-flow"><h2>General Data Flow</h2></a>
<p>HTTP submissions come in from the wild, hit a load balancer, then optionally an
Nginx proxy, then the HTTP Edge Server described in this document. Data is
accepted via a POST/PUT request from clients, which the server will wrap in a
<a href="http://mozilla-services.github.io/lua_sandbox/heka/message.html">Heka message</a>
and forward to two places: the <a href="data_pipeline.html">Services Data Pipeline</a>, where
any further processing, analysis, and storage will be handled; as well as to a
short-lived S3 bucket which will act as a fail-safe in case there is a
processing error and/or data loss within the main Data Pipeline.</p>
<a class="header" href="#namespaces" id="namespaces"><h3>Namespaces</h3></a>
<p>Namespaces are used to control the processing of data from different types of
clients, from the metadata that is collected to the destinations where the data
is written, processed and accessible. Namespaces are
<a href="https://github.com/mozilla-services/nginx_moz_ingest#example-configuration">configured</a>
in Nginx using a location directive, to request a new namespace file a bug
against the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Data%20Platform%20and%20Tools&amp;component=Pipeline%20Ingestion">Data Platform Team</a>
with a short description of what the namespace will be used for and the desired
configuration options. Data sent to a namespace that is not specifically
configured is assumed to be in the <a href="../../cookbooks/new_ping.html">non-Telemetry JSON format described here</a>.</p>
<a class="header" href="#forwarding-to-the-pipeline" id="forwarding-to-the-pipeline"><h3>Forwarding to the pipeline</h3></a>
<p>The constructed Heka protobuf message to is written to disk and the pub/sub
pipeline (currently Kafka). The messages written to disk serve as a fail-safe,
they are batched and written to S3 (landfill) when they reach a certain size or
timeout.</p>
<a class="header" href="#edge-server-heka-message-schema" id="edge-server-heka-message-schema"><h4>Edge Server Heka Message Schema</h4></a>
<ul>
<li>required binary <strong><code>Uuid</code></strong>;                   // Internal identifier randomly generated</li>
<li>required int64  <strong><code>Timestamp</code></strong>;              // Submission time (server clock)</li>
<li>required string <strong><code>Hostname</code></strong>;               // Hostname of the edge server e.g. <code>ip-172-31-2-68</code></li>
<li>required string <strong><code>Type</code></strong>;                   // Kafka topic name e.g. <code>telemetry-raw</code></li>
<li>required group  <strong><code>Fields</code></strong>
<ul>
<li>required string <strong><code>uri</code></strong>;                 // Submission URI e.g. <code>/submit/telemetry/6c49ec73-4350-45a0-9c8a-6c8f5aded0cf/main/Firefox/58.0.2/release/20180206200532</code></li>
<li>required binary <strong><code>content</code></strong>;             // POST Body</li>
<li>required string <strong><code>protocol</code></strong>;            // e.g. <code>HTTP/1.1</code></li>
<li>optional string <strong><code>args</code></strong>;                // Query parameters e.g. <code>v=4</code></li>
<li>optional string <strong><code>remote_addr</code></strong>;         // In our setup it is usually a load balancer e.g. <code>172.31.32.229</code></li>
<li>// HTTP Headers specified in the <a href="https://github.com/mozilla-services/puppet-config/blob/06ec0beae535184cc7455c3c2c32b6571160196d/pipeline/modules/pipeline/templates/edge/nginx.conf.erb#L24">production edge server configuration</a></li>
<li>optional string <strong><code>Content-Length</code></strong>;      // e.g. <code>4722</code></li>
<li>optional string <strong><code>Date</code></strong>;                // e.g. <code>Mon, 12 Mar 2018 00:02:18 GMT</code></li>
<li>optional string <strong><code>DNT</code></strong>;                 // e.g. <code>1</code></li>
<li>optional string <strong><code>Host</code></strong>;                // e.g. <code>incoming.telemetry.mozilla.org</code></li>
<li>optional string <strong><code>User-Agent</code></strong>;          // e.g. <code>pingsender/1.0</code></li>
<li>optional string <strong><code>X-Forwarded-For</code></strong>;     // Last entry is treated as the client IP for geoIP lookup e.g. <code>10.98.132.74, 103.3.237.12</code></li>
<li>optional string <strong><code>X-PingSender-Version</code></strong>;// e.g. <code>1.0</code></li>
</ul>
</li>
</ul>
<a class="header" href="#server-requestresponse" id="server-requestresponse"><h2>Server Request/Response</h2></a>
<a class="header" href="#get-request" id="get-request"><h3>GET Request</h3></a>
<p>Accept GET on <code>/status</code>, returning <code>OK</code> if all is well. This can be used to
check the health of web servers.</p>
<a class="header" href="#get-response-codes" id="get-response-codes"><h3>GET Response codes</h3></a>
<ul>
<li><em>200</em> - OK. <code>/status</code> and all’s well</li>
<li><em>404</em> - Any GET other than <code>/status</code></li>
<li><em>500</em> - All is not well</li>
</ul>
<a class="header" href="#postput-request" id="postput-request"><h3>POST/PUT Request</h3></a>
<p>Treat POST and PUT the same. Accept POST or PUT to URLs of the form</p>
<p><code>^/submit/namespace/[id[/dimensions]]$</code></p>
<p>Example Telemetry format:</p>
<p><code>/submit/telemetry/docId/docType/appName/appVersion/appUpdateChannel/appBuildID</code></p>
<p>Specific Telemetry example:</p>
<p><code>/submit/telemetry/ce39b608-f595-4c69-b6a6-f7a436604648/main/Firefox/61.0a1/nightly/20180328030202</code></p>
<p>Example non-Telemetry format:</p>
<p><code>/submit/namespace/doctype/docversion/docid</code></p>
<p>Specific non-Telemetry example:</p>
<p><code>/submit/eng-workflow/hgpush/1/2c3a0767-d84a-4d02-8a92-fa54a3376049</code></p>
<p>Note that <code>id</code> above is a unique document ID, which is used for de-duping
submissions. This is <em>not</em> intended to be the <code>clientId</code> field from Telemetry.
If <code>id</code> is omitted, we will not be able to de-dupe based on submission URLs. It
is recommended that <code>id</code> be a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>.</p>
<a class="header" href="#postput-response-codes" id="postput-response-codes"><h3>POST/PUT Response codes</h3></a>
<ul>
<li><em>200</em> - OK. Request accepted into the pipeline.</li>
<li><em>400</em> - Bad request, for example an un-encoded space in the URL.</li>
<li><em>404</em> - not found - POST/PUT to an unknown namespace</li>
<li><em>405</em> - wrong request type (anything other than POST/PUT)</li>
<li><em>411</em> - missing content-length header</li>
<li><em>413</em> - request body too large (Note that if we have badly-behaved clients that retry on <code>4XX</code>, we should send back 202 on body/path too long).</li>
<li><em>414</em> - request path too long (See above)</li>
<li><em>500</em> - internal error</li>
</ul>
<a class="header" href="#other-considerations" id="other-considerations"><h2>Other Considerations</h2></a>
<a class="header" href="#compression" id="compression"><h3>Compression</h3></a>
<p>It is not desirable to do decompression on the edge node. We want to pass along
messages from the HTTP Edge node without &quot;cracking the egg&quot; of the payload.</p>
<p>We may also receive badly formed payloads, and we will want to track the
incidence of such things within the main pipeline.</p>
<a class="header" href="#bad-messages" id="bad-messages"><h3>Bad Messages</h3></a>
<p>Since the actual message is not examined by the edge server the only failures
that occur are defined by the response status codes above. Messages are only
forwarded to the pipeline when a response code of 200 is returned to the client.</p>
<a class="header" href="#geoip-lookups" id="geoip-lookups"><h3>GeoIP Lookups</h3></a>
<p>No GeoIP lookup is performed by the edge server. If a client IP is available the
the data warehouse loader performs the lookup and then discards the IP before
the message hits long-term storage.</p>
<a class="header" href="#data-retention" id="data-retention"><h3>Data Retention</h3></a>
<p>The edge server only stores data while batching and will have a retention time
of <code>moz_ingest_landfill_roll_timeout</code> which is generally only a few minutes.
Retention time for the S3 landfill, pub/sub, and the data warehouse is outside
the scope of this document.</p>
<a class="header" href="#event-data-pipeline" id="event-data-pipeline"><h1>Event Data Pipeline</h1></a>
<p>We collect event-oriented data from different sources. This data is collected and processed in a
specific path through our data pipeline, which we will detail here.</p>
<div class="mermaid">graph TD
fx_code(fa:fa-cog Firefox code) --> firefox(fa:fa-firefox Firefox Telemetry)
fx_extensions(fa:fa-cog Mozilla extensions) --> firefox
fx_hybrid(fa:fa-cog Hybrid Content) --> firefox
mobile(fa:fa-cog Mobile products) --> mobile_telemetry(fa:fa-firefox Mobile Telemetry)
firefox -->|main ping| pipeline((fa:fa-database Firefox Data Pipeline))
firefox -.->|events ping, planned| pipeline
mobile_telemetry --> |mobile events ping| pipeline
pipeline -->|Firefox events| main_summary[fa:fa-bars main summary table]
main_summary --> events_table[fa:fa-bars events table]
pipeline -->|Mobile events| mobile_events_table[fa:fa-bars mobile events table]
main_summary --> redash(fa:fa-bar-chart Redash)
events_table --> redash
events_table -.->|planned| amplitude(fa:fa-bar-chart Amplitude)
mobile_events_table --> redash
mobile_events_table --> amplitude
<p>style fx_code fill:#f94,stroke-width:0px
style fx_extensions fill:#f94,stroke-width:0px
style fx_hybrid fill:#f94,stroke-width:0px
style mobile fill:#f94,stroke-width:0px
style firefox fill:#f61,stroke-width:0px
style mobile_telemetry fill:#f61,stroke-width:0px
style pipeline fill:#79d,stroke-width:0px
style main_summary fill:lightblue,stroke-width:0px
style events_table fill:lightblue,stroke-width:0px
style mobile_events_table fill:lightblue,stroke-width:0px
style redash fill:salmon,stroke-width:0px
style amplitude fill:salmon,stroke-width:0px</p>
</div>
<a class="header" href="#overview" id="overview"><h1>Overview</h1></a>
<p>Across the different Firefox teams there is a common need for a more fine grained understanding of
product usage, like understanding the order of interactions or how they occur over time.
To address that our data pipeline needs to support working with event-oriented data.</p>
<p>We specify a common event data format, which allows for broader, shared usage of data processing tools.
To make working with event data feasible, we provide different mechanisms to get the event data
from products to our data pipeline and make the data available in tools for analysis.</p>
<a class="header" href="#the-event-format" id="the-event-format"><h1>The event format</h1></a>
<p>Events are submitted as an array, e.g.:</p>
<pre><code class="language-javascript">[
  [2147, &quot;ui&quot;, &quot;click&quot;, &quot;back_button&quot;],
  [2213, &quot;ui&quot;, &quot;search&quot;, &quot;search_bar&quot;, &quot;google&quot;],
  [2892, &quot;ui&quot;, &quot;completion&quot;, &quot;search_bar&quot;, &quot;yahoo&quot;,
    {&quot;querylen&quot;: &quot;7&quot;, &quot;results&quot;: &quot;23&quot;}],
  [5434, &quot;dom&quot;, &quot;load&quot;, &quot;frame&quot;, null,
    {&quot;prot&quot;: &quot;https&quot;, &quot;src&quot;: &quot;script&quot;}],
  // ...
]
</code></pre>
<p>Each event is of the form:</p>
<pre><code class="language-javascript">[timestamp, category, method, object, value, extra]
</code></pre>
<p>Where the individual fields are:</p>
<ul>
<li><code>timestamp</code>: <code>Number</code>, positive integer. This is the time in ms when the event was recorded, relative to the main process start time.</li>
<li><code>category</code>: <code>String</code>, identifier. The category is a group name for events and helps to avoid name conflicts.</li>
<li><code>method</code>: <code>String</code>, identifier. This describes the type of event that occurred, e.g. <code>click</code>, <code>keydown</code> or <code>focus</code>.</li>
<li><code>object</code>: <code>String</code>, identifier. This is the object the event occurred on, e.g. <code>reload_button</code> or <code>urlbar</code>.</li>
<li><code>value</code>: <code>String</code>, optional, may be null. This is a user defined value, providing context for the event.</li>
<li><code>extra</code>: <code>Object</code>, optional, may be null. This is an object of the form <code>{&quot;key&quot;: &quot;value&quot;, ...}</code>, both keys and values need to be strings. This is used for events when additional richer context is needed.</li>
</ul>
<p>See also the <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html#serialization-format">Firefox Telemetry documentation</a>.</p>
<a class="header" href="#event-data-collection" id="event-data-collection"><h1>Event data collection</h1></a>
<a class="header" href="#firefox-event-collection" id="firefox-event-collection"><h2>Firefox event collection</h2></a>
<p>To collect this event data in Firefox there are different APIs in Firefox, all addressing different
use cases:</p>
<ul>
<li>The <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html"><em>Telemetry event API</em></a>
allows easy recording of events from Firefox code.</li>
<li>The <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html#registerevents"><em>dynamic event API</em></a>
allows code from Mozilla addons to record new events into Telemetry without shipping Firefox
code.</li>
<li>The <em>Telemetry extension API</em> (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1280234">work in progress</a>)
will allow Mozilla extensions to record new events into Telemetry.</li>
<li>The <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/hybrid-content.html"><em>Hybrid-content API</em></a>
allows specific white-listed Mozilla content code to record new events into Telemetry.</li>
</ul>
<p>For all these APIs, events will get sent to the pipeline through the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">main ping</a>,
with a hard limit of 500 events per ping.
In the future, Firefox events will be sent through a separate <em>events ping</em>, removing the hard limit.
As of Firefox 61, all events recorded through these APIs are <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1440673">automatically counted in scalars</a>.</p>
<p>Finally, <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/custom-pings.html"><em>custom pings</em></a>
can follow the event data format and potentially connect to the existing tooling with some integration work.</p>
<a class="header" href="#mobile-event-collection" id="mobile-event-collection"><h2>Mobile event collection</h2></a>
<p>Mobile events data primarily flows through the mobile events ping (<a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/tree/dev/schemas/telemetry/mobile-event">ping schema</a>), from e.g. <a href="https://github.com/mozilla-mobile/firefox-ios/wiki/Event-Tracking-with-Mozilla&#x27;s-Telemetry-Service#event-ping">Firefox iOS</a>, Firefox for Fire TV and Rocket.</p>
<p>Currently we also collect event data from Firefox Focus through the <a href="https://github.com/mozilla-mobile/focus-ios/wiki/Event-Tracking-with-Mozilla%27s-Telemetry-Service#event-ping"><code>focus-events</code> ping</a>,
using the <a href="https://github.com/mozilla-mobile/telemetry-ios"><code>telemetry-ios</code></a> and
<a href="https://github.com/mozilla-mobile/telemetry-android"><code>telemetry-android</code></a> libraries.</p>
<a class="header" href="#datasets" id="datasets"><h1>Datasets</h1></a>
<p>On the pipeline side, the event data is made available in different datasets:</p>
<ul>
<li><a href="../choosing_a_dataset.html#mainsummary"><code>main_summary</code></a> has a row for each main ping and includes
its event payload.</li>
<li><a href="../../datasets/batch_view/events/reference.html"><code>events</code></a> contains a row for each event received. See <a href="https://sql.telemetry.mozilla.org/queries/52582/source">this sample query</a>.</li>
<li><code>telemetry_mobile_event_parquet</code> contains a row for each mobile event ping. See <a href="https://sql.telemetry.mozilla.org/queries/52581/source">this sample query</a>.</li>
<li><code>focus_events_longitudinal</code> currently contains events from Firefox Focus.</li>
</ul>
<a class="header" href="#data-tooling" id="data-tooling"><h1>Data tooling</h1></a>
<p>The above datasets are all accessible through <a href="../../tools/stmo.html">Re:dash</a> and <a href="../../tools/spark.html">Spark jobs</a>.</p>
<p>For product analytics based on event data, we have <a href="https://sso.mozilla.com/amplitude">Amplitude</a>
(hosted by the IT data team). We can connect our event data sources data to Amplitude.
We have an active connector to Amplitude for mobile events, which can push event data over
daily. For Firefox Desktop events this will be available soon.</p>
<a class="header" href="#mozilla-firefox-data-analysis-tools" id="mozilla-firefox-data-analysis-tools"><h2>Mozilla Firefox Data Analysis Tools</h2></a>
<p>This is a starting point for making sense of (and gaining access to) all of the
Firefox-related data analysis tools. There are a number of different tools
available, all with their own strengths, tailored to a variety of use cases and
skill sets.</p>
<a class="header" href="#a-hrefstmohtmlsqltelemetrymozillaorga-stmo" id="a-hrefstmohtmlsqltelemetrymozillaorga-stmo"><h4><a href="stmo.html"><code>sql.telemetry.mozilla.org</code></a> (STMO)</h4></a>
<p>The <a href="https://sql.telemetry.mozilla.org"><code>sql.telemetry.mozilla.org</code></a> (STMO) site
is an instance of the very fine <a href="https://redash.io/">Re:dash</a> software, allowing
for SQL-based exploratory analysis and visualization / dashboard
construction. Requires (surprise!) familiarity with SQL, and for your data to
be explicitly exposed as an STMO data source. Bugs or feature requests can be
reported in our <a href="https://github.com/mozilla/redash/issues">issue tracker</a>.</p>
<a class="header" href="#a-hrefsparkhtmlanalysistelemetrymozillaorga-atmo" id="a-hrefsparkhtmlanalysistelemetrymozillaorga-atmo"><h4><a href="spark.html"><code>analysis.telemetry.mozilla.org</code></a> (ATMO)</h4></a>
<p>The
<a href="https://analysis.telemetry.mozilla.org"><code>analysis.telemetry.mozilla.org</code></a>
(ATMO) site can be used to launch and gain access to virtual machines running
Apache Spark clusters which have been pre-configured with access to the raw data
stored in our long term storage S3 buckets. Spark allows you to use
Python or Scala to perform arbitrary analysis and generate arbitrary
output. Once developed, ATMO can also be used to run recurring Spark jobs
for data transformation, processing, or reporting. Requires Python or Scala
programming skills and knowledge of various data APIs. Learn more by visiting
the <a href="https://wiki.mozilla.org/Telemetry">documentation</a> or
<a href="spark.html">tutorials</a>.</p>
<a class="header" href="#a-hrefhttpsdbc-caf9527b-e073clouddatabrickscomdatabricksa" id="a-hrefhttpsdbc-caf9527b-e073clouddatabrickscomdatabricksa"><h4><a href="https://dbc-caf9527b-e073.cloud.databricks.com/">Databricks</a></h4></a>
<p>Offers notebook interface with shared, always-on, autoscaling cluster
(attaching your notebooks to <code>shared_serverless</code> is the best way to start).
Convenient for quick data investigations. Users can get help on <code>#databricks</code>
channel on IRC and are advised to join the
<a href="https://groups.google.com/a/mozilla.com/forum/#!forum/databricks-discuss"><code>databricks-discuss@mozilla.com</code></a> group.</p>
<a class="header" href="#a-hrefconceptsanalysis_introhtmltelemetrymozillaorga-tmo" id="a-hrefconceptsanalysis_introhtmltelemetrymozillaorga-tmo"><h4><a href="../concepts/analysis_intro.html"><code>telemetry.mozilla.org</code></a> (TMO)</h4></a>
<p>Our <a href="https://telemetry.mozilla.org"><code>telemetry.mozilla.org</code></a> (TMO) site is the
'venerable standby' of Firefox telemetry analysis tools. It uses aggregate
telemetry data (as opposed to the collated data sets that are exposed to most
of the other tools) so it provides less latency than most but is unsuitable for
examining at the individual client level. It provides a powerful UI that allows
for sophisticated ad-hoc analysis without the need for any specialized
programming skills, but with so many options the UI can be a bit intimidating
for novice users.</p>
<a class="header" href="#a-hrefdistribution_viewerhtmldistribution-viewera" id="a-hrefdistribution_viewerhtmldistribution-viewera"><h4><a href="distribution_viewer.html">Distribution Viewer</a></h4></a>
<p>Distribution Viewer (deprecated) was a simple tool
that provides a set of <a href="http://math.stackexchange.com/questions/52400/what-is-cdf-cumulative-distribution-function">cumulative distribution
graphs</a>
for a pre-specified selection of Firefox user metrics. These metrics are
extracted from a 1% sample of the <code>clientId</code>s from Firefox Telemetry. These plots
will allow you to understand how values of different metrics are spread out
among our population of users rather than just using a one number summary (such
as a mean or median). By viewing the entire distribution, you can get a sense
of the importance of behavior at the extremes as well as anomalies within the
population that might indicate interesting behavior. Very simple to use (no
programming required) and able to provide interesting insights, but not usually
suitable for ad-hoc analysis.</p>
<a class="header" href="#a-hrefcookbooksrealtime_analysis_pluginhtmlreal-time--cepa" id="a-hrefcookbooksrealtime_analysis_pluginhtmlreal-time--cepa"><h4><a href="../cookbooks/realtime_analysis_plugin.html">Real Time / CEP</a></h4></a>
<p>The &quot;real time&quot; or &quot;complex event processing&quot; (CEP)
<a href="https://pipeline-cep.prod.mozaws.net/">system</a> is part of the ingestion
infrastructure that processes all of our Firefox telemetry data. It provides
extremely low latency access to the data as it's flowing through our ingestion
system on its way to long term storage. As a CEP system, it is unlike the rest
of our analysis tools in that it is up to the analyst to specify and maintain
state from the data that is flowing; it is non-trivial to revisit older data
that has already passed through the system. The CEP is very powerful, allowing
for sophisticated monitoring, alerting, reporting, and dashboarding. Developing
new analysis plugins requires knowledge of the Lua programming language,
relevant APIs, and a custom filter configuration syntax. Learn more about how
to do this in our <a href="../cookbooks/realtime_analysis_plugin.html">Creating a Real-time Analysis
Plugin</a> article.</p>
<a class="header" href="#introduction-1" id="introduction-1"><h2>Introduction</h2></a>
<p><a href="https://spark.apache.org/">Apache Spark</a>
is a data processing engine designed to be fast and easy to use.
We have setup
<a href="https://jupyter.org/">Jupyter notebooks</a>
that use Spark to analyze our Telemetry data.
Jupyter notebooks can be easily shared and updated among colleagues,
and, when combined with Spark, enable richer analysis than SQL alone.</p>
<p>The Spark clusters can be launched from <a href="https://analysis.telemetry.mozilla.org">ATMO</a>.
The Spark Python API is called PySpark.</p>
<p>Note that this documentation focuses on ATMO, but analysis with Spark is also possible using Databricks.
For more information please see this
<a href="https://dbc-caf9527b-e073.cloud.databricks.com/#notebook/30598/command/30599">example notebook</a>.</p>
<a class="header" href="#setting-up-a-spark-cluster-on-atmo" id="setting-up-a-spark-cluster-on-atmo"><h2>Setting Up a Spark Cluster On ATMO</h2></a>
<ol>
<li>Go to <a href="https://analysis.telemetry.mozilla.org">https://analysis.telemetry.mozilla.org</a></li>
<li>Click “Launch an ad-hoc Spark cluster”.</li>
<li>Enter some details:
<ol>
<li>The “Cluster Name” field should be a short descriptive name,
like “chromehangs analysis”.</li>
<li>Set the number of workers for the cluster. Please keep in mind
to use resources sparingly; use a single worker to write and
debug your job.</li>
<li>Upload your SSH public key.</li>
</ol>
</li>
<li>Click “Submit”.</li>
<li>A cluster will be launched on AWS pre-configured with Spark, Jupyter
and some handy data analysis libraries like <code>pandas</code> and <code>matplotlib</code>.</li>
</ol>
<p>Once the cluster is ready, you can tunnel Jupyter through SSH by
following the instructions on the dashboard.
For example:</p>
<pre><code class="language-bash">ssh -i ~/.ssh/id_rsa -L 8888:localhost:8888 hadoop@ec2-54-70-129-221.us-west-2.compute.amazonaws.com
</code></pre>
<p>Finally, you can launch Jupyter in Firefox by visiting http://localhost:8888.</p>
<a class="header" href="#the-python-jupyter-notebook" id="the-python-jupyter-notebook"><h2>The Python Jupyter Notebook</h2></a>
<p>When you access http://localhost:8888, two example Jupyter notebooks
are available to peruse.</p>
<p>Starting out, we recommend looking through the
<a href="https://github.com/mozilla/mozilla-reports/blob/master/tutorials/telemetry_hello_world.kp/orig_src/Telemetry%20Hello%20World.ipynb">Telemetry Hello World</a>
notebook.
It gives a nice overview of Jupyter and analyzing telemetry data using PySpark and the RDD API.</p>
<a class="header" href="#using-jupyter" id="using-jupyter"><h3>Using Jupyter</h3></a>
<p>Jupyter Notebooks contain a series of cells.
Each cell contains code or markdown.
To switch between the two, use the drop-down at the top.
To run a cell, use shift-enter;
this either compiles the markdown or runs the code.
To create new cell, select Insert -&gt; Insert Cell Below.</p>
<p>A cell can output text or plots.
To output plots inlined with the cell,
run <code>%pylab inline</code>, usually below your import statements:</p>
<p>The notebook is setup to work with Spark. See the &quot;Using Spark&quot; section
for more information.</p>
<a class="header" href="#schedule-a-periodic-job" id="schedule-a-periodic-job"><h3>Schedule a periodic job</h3></a>
<p>Scheduled Spark jobs allow a Jupyter notebook to be updated consistently,
making a nice and easy-to-use dashboard.</p>
<p>To schedule a Spark job:</p>
<ol>
<li>Visit the analysis provisioning dashboard at
<a href="https://analysis.telemetry.mozilla.org">https://analysis.telemetry.mozilla.org</a> and sign in</li>
<li>Click “Schedule a Spark Job”</li>
<li>Enter some details:
<ol>
<li>The “Job Name” field should be a short descriptive name, like
“chromehangs analysis”.</li>
<li>Upload your Jupyter notebook containing the analysis.</li>
<li>Set the number of workers of the cluster in the “Cluster Size”
field.</li>
<li>Set a schedule frequency using the remaining fields.</li>
</ol>
</li>
</ol>
<p>Now, the notebook will be updated automatically and the results can be
easily shared. Furthermore, all files stored in the notebook's local
working directory at the end of the job will be automatically uploaded
to S3, which comes in handy for simple ETL workloads for example.</p>
<p>For reference, see
<a href="https://robertovitillo.com/2015/03/13/simple-dashboards-with-scheduled-spark-jobs-and-plotly">Simple Dashboard with Scheduled Spark Jobs and Plotly</a>.</p>
<a class="header" href="#sharing-a-notebook" id="sharing-a-notebook"><h3>Sharing a Notebook</h3></a>
<p>Jupyter notebooks can be shared in a few different ways.</p>
<a class="header" href="#sharing-a-static-notebook" id="sharing-a-static-notebook"><h4>Sharing a Static Notebook</h4></a>
<p>An easy way to share is using a gist on Github.</p>
<ol>
<li>Download file as <code>.ipynb</code></li>
<li>Upload to a gist on <a href="https://gist.github.com"><code>gist.github.com</code></a></li>
<li>Enter the gist URL at <a href="https://nbviewer.jupyter.org/">Jupyter nbviewer</a></li>
<li>Share with your colleagues!</li>
</ol>
<a class="header" href="#sharing-a-scheduled-notebook" id="sharing-a-scheduled-notebook"><h4>Sharing a Scheduled Notebook</h4></a>
<p>Setup your scheduled notebook. After it's run, do the following:</p>
<ol>
<li>Go to the &quot;Schedule a Spark job&quot; tab in ATMO</li>
<li>Get the URL for the notebook (under 'Currently Scheduled Jobs')</li>
<li>Paste that URL into <a href="https://nbviewer.jupyter.org/">Jupyter nbviewer</a></li>
</ol>
<a class="header" href="#zeppelin-notebooks" id="zeppelin-notebooks"><h2>Zeppelin Notebooks</h2></a>
<p>We also have support for <a href="https://zeppelin.apache.org/">Apache Zeppelin</a>
notebooks. The notebook server for that is running on port 8890, so you
can connect to it just by tunnelling the port (instead of port 8888 for
Jupyter). For example:</p>
<pre><code>ssh -i \~/.ssh/id\_rsa -L 8890:localhost:8890
hadoop@ec2-54-70-129-221.us-west-2.compute.amazonaws.com
</code></pre>
<a class="header" href="#using-spark" id="using-spark"><h2>Using Spark</h2></a>
<p>Spark is a general-purpose cluster computing system - it allows users to
run general execution graphs. APIs are available in Python, Scala, and
Java. The Jupyter notebook utilizes the Python API. In a nutshell, it
provides a way to run functional code (e.g. map, reduce, etc.) on large,
distributed data.</p>
<p>Check out
<a href="https://robertovitillo.com/2015/06/30/spark-best-practices/">Spark Best Practices</a>
for tips on using Spark to its full capabilities.</p>
<a class="header" href="#sparkcontext-sc" id="sparkcontext-sc"><h3><code>SparkContext</code> (<code>sc</code>)</h3></a>
<p>Access to the Spark API is provided through <code>SparkContext</code>. In the Jupyter
notebook, this is the <code>sc</code> object. For example, to create a
distributed RDD of monotonically increasing numbers 1-1000:</p>
<pre><code class="language-python">numbers = range(1000)
# no need to initialize sc in the Jupyter notebook
numsRdd = sc.parallelize(numbers)
nums.take(10) #no guaranteed order
</code></pre>
<a class="header" href="#spark-rdd" id="spark-rdd"><h3>Spark RDD</h3></a>
<p>The Resilient Distributed Dataset (RDD) is Spark's basic data structure.
The operations that are performed on these structures are distributed to
the cluster. Only certain actions (such as collect() or take(N)) pull an
RDD in locally.</p>
<p>RDD's are nice because there is no imposed schema - whatever they
contain, they distribute around the cluster. Additionally, RDD's can be
cached in memory, which can greatly improve performance of some
algorithms that need access to data over and over again.</p>
<p>Additionally, RDD operations are all part of a directed, acyclic graph.
This gives increased redundancy, since Spark is always able to recreate
an RDD from the base data (by rerunning the graph), but also provides
lazy evaluation. No computation is performed while an RDD is just being
transformed (a la map), but when an action is taken (e.g. reduce, take)
the entire computation graph is evaluated. Continuing from our previous
example, the following gives some of the peaks of a sin wave:</p>
<pre><code class="language-python">import numpy as np
#no computation is performed on the following line!
sin_values = numsRdd.map(lambda x : np.float(x) / 10).map(lambda x : (x, np.sin(x)))
#now the entire computation graph is evaluated
sin_values.takeOrdered(5, lambda x : -x[1])
</code></pre>
<p>For jumping into working with Spark RDD's, we recommend reading the
<a href="https://spark.apache.org/docs/latest/programming-guide.html">Spark Programming Guide</a>.</p>
<a class="header" href="#spark-sql-and-spark-dataframesdatasets" id="spark-sql-and-spark-dataframesdatasets"><h3>Spark SQL and Spark DataFrames/Datasets</h3></a>
<p>Spark also supports traditional SQL, along with special data structures
that require schemas. The Spark SQL API can be accessed with the
<code>spark</code> object. For example:</p>
<p><code>   longitudinal = spark.sql('SELECT * FROM longitudinal')</code></p>
<p>creates a DataFrame that contains all the longitudinal data. A Spark
DataFrame is essentially a distributed table, a la Pandas or R
DataFrames. Under the covers they are an RDD of Row objects, and thus
the entirety of the RDD API is available for DataFrames, as well as a
DataFrame specific API. For example, a SQL-like way to get the count of
a specific OS:</p>
<p><code>   longitudinal.select(&quot;os&quot;).where(&quot;os = 'Darwin'&quot;).count()</code></p>
<p>To Transform the DataFrame object to an RDD, simply do:</p>
<p><code>  longitudinal_rdd = longitudinal.rdd</code></p>
<p>In general, however, the DataFrames are performance optimized, so it's
worth the effort to learn the DataFrame API.</p>
<p>For more overview, see the
<a href="https://spark.apache.org/docs/latest/sql-programming-guide.html">SQL Programming Guide</a>.
See also the
<a href="https://reports.telemetry.mozilla.org/post/tutorials/longitudinal_dataset.kp">Longitudinal Tutorial</a>,
one of the available example notebooks when you start a cluster.</p>
<a class="header" href="#available-data-sources-for-sparksql" id="available-data-sources-for-sparksql"><h3>Available Data Sources for <code>SparkSQL</code></h3></a>
<p>For information about data sources available for querying (e.g. Longitudinal dataset),
see <a href="../concepts/choosing_a_dataset.html">Choosing a Dataset</a>.</p>
<p>These datasets are optimized for fast access, and will far out-perform
analysis on the raw Telemetry ping data.</p>
<a class="header" href="#accessing-the-spark-ui" id="accessing-the-spark-ui"><h3>Accessing the Spark UI</h3></a>
<p>After establishing an SSH connection to the Spark cluster, go to https://localhost:8888/spark
to see the Spark UI.
It has information about job statuses and task completion,
and may help you debug your job.</p>
<a class="header" href="#the-moztelemetry-library" id="the-moztelemetry-library"><h2>The <code>MozTelemetry</code> Library</h2></a>
<p>We have provided a library that gives easy access to the raw telemetry ping data.
For example usage, see the
<a href="https://reports.telemetry.mozilla.org/post/tutorials/telemetry_hello_world.kp">Telemetry Hello World</a>
example notebook.
Detailed documentation for the library can be found at the
<a href="https://python-moztelemetry.readthedocs.io">Python MozTelemetry Documentation</a>.</p>
<a class="header" href="#using-the-raw-ping-data" id="using-the-raw-ping-data"><h3>Using the Raw Ping Data</h3></a>
<p>First off, import the <code>moztelemetry</code> library using the following:</p>
<p><code>from moztelemetry.dataset import Dataset</code></p>
<p>The ping data is an RDD of JSON elements. For example, using the
following:</p>
<pre><code class="language-python">pings = Dataset.from_source(&quot;telemetry&quot;) \
    .where(docType='main') \
    .where(submissionDate=&quot;20180101&quot;) \
    .where(appUpdateChannel=&quot;nightly&quot;) \
    .records(sc, sample=0.01)
</code></pre>
<p>returns an RDD of 1/100th of Firefox Nightly JSON pings submitted on
from January 1 2018. Now, because it's JSON, pings are easy to access.
For example, to get the count of each OS type:</p>
<pre><code class="language-python">os_names = pings.map(lambda x: (x['environment']['system']['os']['name'], 1))
os_counts = os_names.reduceByKey(lambda x, y: x + y)
os_counts.collect()
</code></pre>
<p>Alternatively, <code>moztelemetry</code> provides the <code>get_pings_properties</code>
function, which will gather the data for you:</p>
<pre><code class="language-python">from moztelemetry import get_pings_properties
subset = get_pings_properties(pings, [&quot;environment/system/os/name&quot;])
subset.map(lambda x: (x[&quot;environment/system/os/name&quot;], 1)).reduceByKey(lambda x, y: x + y).collect()
</code></pre>
<a class="header" href="#faq" id="faq"><h2>FAQ</h2></a>
<p>Please add more FAQ as questions are answered by you or for you.</p>
<a class="header" href="#how-can-i-load-parquet-datasets-in-a-jupyter-notebook" id="how-can-i-load-parquet-datasets-in-a-jupyter-notebook"><h3>How can I load parquet datasets in a Jupyter notebook?</h3></a>
<p>Use <code>spark.read.parquet</code>, e.g.:</p>
<pre><code class="language-python">dataset = spark.read.parquet(&quot;s3://the_bucket/the_prefix/the_version&quot;)`
</code></pre>
<p>For more information see <a href="../cookbooks/parquet.html">Working with Parquet</a>.</p>
<a class="header" href="#i-got-a-remote-host-identification-has-changed-error" id="i-got-a-remote-host-identification-has-changed-error"><h3>I got a REMOTE HOST IDENTIFICATION HAS CHANGED! error</h3></a>
<p>AWS recycles hostnames, so this warning is expected.
Removing the offending key from <code>$HOME/.ssh/known_hosts</code> will remove the warning.
You can find the line to remove by finding the line in the output that says</p>
<p><code>Offending key in /path/to/hosts/known_hosts:2</code></p>
<p>Where 2 is the line number of the key that can be deleted.
Just remove that line, save the file, and try again.</p>
<a class="header" href="#why-is-my-notebook-hanging" id="why-is-my-notebook-hanging"><h3>Why is my notebook hanging?</h3></a>
<p>There are a few common causes for this:</p>
<ol>
<li>Currently, our Spark notebooks can only run a single Python kernel at
a time. If you open multiple notebooks on the same cluster and try to
run both, the second notebook will hang. Be sure to close notebooks
using &quot;Close and Halt&quot; under the &quot;File&quot; drop-down.</li>
<li>The connection from PySpark to the Spark driver might be lost.
Unfortunately the best way to recover from this for the moment seems to
be spinning up a new cluster.</li>
<li>Cancelling execution of a notebook cell doesn't cancel any spark jobs
that might be running in the background. If your spark commands seem to
be hanging, try running <code>sc.cancelAllJobs()</code>.</li>
</ol>
<a class="header" href="#how-can-i-keep-running-after-closing-the-notebook" id="how-can-i-keep-running-after-closing-the-notebook"><h3>How can I keep running after closing the notebook?</h3></a>
<p>For long-running computation, it might be nice to close the notebook
(and the SSH session) and look at the results later.
Unfortunately, <strong>all cell output will be lost when a notebook is closed</strong>
(for the running cell).
To alleviate this, there are a few options:</p>
<ol>
<li>Have everything output to a variable. These values should still be
available when you reconnect.</li>
<li>Put %%capture at the beginning of the cell to store all output.
<a href="https://ipython.org/ipython-doc/3/interactive/magics.html#cellmagic-capture">See the documentation</a>.</li>
</ol>
<a class="header" href="#how-do-i-load-an-external-library-into-the-cluster" id="how-do-i-load-an-external-library-into-the-cluster"><h3>How do I load an external library into the cluster?</h3></a>
<p>Assuming you've got a URL for the repo, you can create an egg for it
this way:</p>
<pre><code class="language-python">!git clone `&lt;repo url&gt;` &amp;&amp; cd `&lt;repo-name&gt;` &amp;&amp; python setup.py bdist_egg`\
sc.addPyFile('`&lt;repo-name&gt;`/dist/my-egg-file.egg')`
</code></pre>
<p>Alternately, you could just create that egg locally, upload it to a web
server, then download and install it:</p>
<pre><code class="language-python">import requests`\
r = requests.get('`&lt;url-to-my-egg-file&gt;`')`\
with open('mylibrary.egg', 'wb') as f:`\
  f.write(r.content)`\
sc.addPyFile('mylibrary.egg')`
</code></pre>
<p>You will want to do this <strong>before</strong> you load the library. If the library
is already loaded, restart the kernel in the Jupyter notebook.</p>
<a class="header" href="#sql-style-guide" id="sql-style-guide"><h1>SQL Style Guide</h1></a>
<a class="header" href="#table-of-contents-2" id="table-of-contents-2"><h2>Table of Contents</h2></a>
<ul>
<li><a href="#consistency">Consistency</a></li>
<li><a href="#reserved-words">Reserved Words</a></li>
<li><a href="#variable-names">Variable Names</a></li>
<li><a href="#aliasing">Aliasing</a></li>
<li><a href="#left-align-root-keywords">Left Align Root Keywords</a></li>
<li><a href="#code-blocks">Code Blocks</a></li>
<li><a href="#parentheses">Parentheses</a></li>
<li><a href="#boolean-at-the-beginning-of-line">Boolean at the Beginning of Line</a></li>
<li><a href="#nested-queries">Nested Queries</a></li>
<li><a href="#about-this-document">About this Document</a></li>
</ul>
<a class="header" href="#consistency" id="consistency"><h2>Consistency</h2></a>
<p>From <a href="https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds">Pep8</a>:</p>
<blockquote>
<p>A style guide is about consistency.
Consistency with this style guide is important.
Consistency within a project is more important.
Consistency within one module or function is the most important.</p>
<p>However, know when to be inconsistent --
sometimes style guide recommendations just aren't applicable.
When in doubt, use your best judgment.
Look at other examples and decide what looks best.
And don't hesitate to ask!</p>
</blockquote>
<a class="header" href="#reserved-words" id="reserved-words"><h2>Reserved Words</h2></a>
<p>Always use uppercase for reserved keywords like <code>SELECT</code>, <code>WHERE</code>, or <code>AS</code>.</p>
<a class="header" href="#variable-names" id="variable-names"><h2>Variable Names</h2></a>
<ol>
<li>Use consistent and descriptive identifiers and names.</li>
<li>Use lower case names with underscores, such as <code>first_name</code>.
Do not use CamelCase.</li>
<li>Presto functions, such as <code>cardinality</code>, <code>approx_distinct</code>, or <code>substr</code>,
<a href="https://www.postgresql.org/docs/10/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">are identifiers</a>
and should be treated like variable names.</li>
<li>Names must begin with a letter and may not end in an underscore.</li>
<li>Only use letters, numbers, and underscores in variable names.</li>
</ol>
<a class="header" href="#aliasing" id="aliasing"><h2>Aliasing</h2></a>
<p>Always include the <code>AS</code> keyword when aliasing a variable,
it's easier to read when explicit.</p>
<p><strong>Good</strong></p>
<pre><code class="language-sql">SELECT
  substr(submission_date, 1, 6) AS month
FROM
  main_summary
LIMIT
  10
</code></pre>
<p><strong>Bad</strong></p>
<pre><code class="language-sql">SELECT
  substr(submission_date, 1, 6) month
FROM
  main_summary
LIMIT
  10
</code></pre>
<a class="header" href="#left-align-root-keywords" id="left-align-root-keywords"><h2>Left Align Root Keywords</h2></a>
<p>Root keywords should all start on the same character boundary.
This is counter to the common &quot;rivers&quot; pattern
<a href="https://www.sqlstyle.guide/#spaces">described here</a>.</p>
<p><strong>Good</strong>:</p>
<pre><code class="language-sql">SELECT
  client_id,
  submission_date
FROM
  main_summary
WHERE
  sample_id = '42'
  AND submission_date &gt; '20180101'
LIMIT
  10
</code></pre>
<p><strong>Bad</strong>:</p>
<pre><code class="language-sql">SELECT client_id,
       submission_date
  FROM main_summary
 WHERE sample_id = '42'
   AND submission_date &gt; '20180101'
</code></pre>
<a class="header" href="#code-blocks" id="code-blocks"><h2>Code Blocks</h2></a>
<p>Root keywords should be on their own line.
For example:</p>
<p><strong>Good</strong>:</p>
<pre><code class="language-sql">SELECT
  client_id,
  submission_date
FROM
  main_summary
WHERE
  submission_date &gt; '20180101'
  AND sample_id = '42'
LIMIT
  10
</code></pre>
<p>It's acceptable to include an argument on the same line as the root keyword,
if there is exactly one argument.</p>
<p><strong>Acceptable</strong>:</p>
<pre><code class="language-sql">SELECT
  client_id,
  submission_date
FROM main_summary
WHERE
  submission_date &gt; '20180101'
  AND sample_id = '42'
LIMIT 10
</code></pre>
<p>Do not include multiple arguments on one line.</p>
<p><strong>Bad</strong>:</p>
<pre><code class="language-sql">SELECT client_id, submission_date
FROM main_summary
WHERE
  submission_date &gt; '20180101'
  AND sample_id = '42'
LIMIT 10
</code></pre>
<p><strong>Bad</strong></p>
<pre><code class="language-sql">SELECT
  client_id,
  submission_date
FROM main_summary
WHERE submission_date &gt; '20180101'
  AND sample_id = '42'
LIMIT 10
</code></pre>
<a class="header" href="#parentheses" id="parentheses"><h2>Parentheses</h2></a>
<p>If parentheses span multiple lines:</p>
<ol>
<li>The opening parenthesis should terminate the line.</li>
<li>The closing parenthesis should be lined up under
the first character of the line that starts the multi-line construct.</li>
<li>The contents of the parentheses should be indented one level.</li>
</ol>
<p>For example:</p>
<p><strong>Good</strong></p>
<pre><code class="language-sql">WITH sample AS (
  SELECT
    client_id,
  FROM
    main_summary
  WHERE
    sample_id = '42'
)
</code></pre>
<p><strong>Bad</strong> (Terminating parenthesis on shared line)</p>
<pre><code class="language-sql">WITH sample AS (
  SELECT
    client_id,
  FROM
    main_summary
  WHERE
    sample_id = '42')
</code></pre>
<p><strong>Bad</strong> (No indent)</p>
<pre><code class="language-sql">WITH sample AS (
SELECT
  client_id,
FROM
  main_summary
WHERE
  sample_id = '42'
)
</code></pre>
<a class="header" href="#boolean-at-the-beginning-of-line" id="boolean-at-the-beginning-of-line"><h2>Boolean at the Beginning of Line</h2></a>
<p><code>AND</code> and <code>OR</code> should always be at the beginning of the line.
For example:</p>
<p><strong>Good</strong></p>
<pre><code class="language-sql">...
WHERE
  submission_date &gt; 20180101
  AND sample_id = '42'
</code></pre>
<p><strong>Bad</strong></p>
<pre><code class="language-sql">...
WHERE
  submission_date &gt; 20180101 AND
  sample_id = '42'
</code></pre>
<a class="header" href="#nested-queries" id="nested-queries"><h2>Nested Queries</h2></a>
<p>Do not use nested queries.
Instead, use common table expressions to improve readability.</p>
<p><strong>Good</strong>:</p>
<pre><code class="language-sql">WITH sample AS (
  SELECT
    client_id,
    submission_date
  FROM
    main_summary
  WHERE
    sample_id = '42'
)

SELECT *
FROM sample
LIMIT 10
</code></pre>
<p><strong>Bad</strong>:</p>
<pre><code class="language-sql">SELECT *
FROM (
  SELECT
    client_id,
    submission_date
  FROM
    main_summary
  WHERE
    sample_id = '42'
)
LIMIT 10
</code></pre>
<a class="header" href="#about-this-document" id="about-this-document"><h2>About this Document</h2></a>
<p>This document was heavily influenced by https://www.sqlstyle.guide/</p>
<p>Changes to the style guide should be reviewed by at least one member of
both the Data Engineering team and the Data Science team.</p>
<a class="header" href="#cookbooks" id="cookbooks"><h1>Cookbooks</h1></a>
<p>A Cookbook is a focused tutorial to guide you through a focused task.
For example, a Cookbook could:</p>
<ul>
<li>Introduce you to what types of analyses are common for (e.g.) Search or Crash data</li>
<li>Guide you through an example analysis to demonstrate
the basic principles behind a new statistical technique</li>
</ul>
<a class="header" href="#telemetry-alerts" id="telemetry-alerts"><h1>Telemetry Alerts</h1></a>
<p>Many Telemetry probes were created to show performance trends over time.
Sudden changes happening in Nightly could be the sign of an
unintentional performance regression, so we introduced a system to
automatically detect and alert developers about such changes.</p>
<p>Thus we created Telemetry Alerts. It comes in two pieces:
<a href="https://github.com/mozilla/cerberus/">Cerberus</a> the Detector and
<a href="https://github.com/mozilla/medusa/">Medusa</a> the Front-end.</p>
<a class="header" href="#cerberus" id="cerberus"><h3>Cerberus</h3></a>
<p>Every day Cerberus grabs the latest aggregated information about all
non-keyed Telemetry probes from <code>aggregates.telemetry.mozilla.org</code> and
compares the distribution of values from the <strong>Nightly</strong> builds of the
past two days to the distribution of values from the Nightly builds of
the past seven days.</p>
<p>It does this by calculating the <a href="https://en.wikipedia.org/wiki/Bhattacharyya_distance">Bhattacharyya
distance</a> between
the two distributions and guessing whether or not they are <a href="https://github.com/mozilla/cerberus/blob/master/alert/alert.py#L72">significant
and
narrow</a>.</p>
<p>It places all detected changes in a file for ingestion by Medusa.</p>
<a class="header" href="#medusa" id="medusa"><h3>Medusa</h3></a>
<p>Medusa is in charge of emailing people when distributions change and for
displaying the website <a href="https://alerts.telemetry.mozilla.org">https://alerts.telemetry.mozilla.org</a> which
contains pertinent information about each detected regression.</p>
<p>Medusa also checks for expiring histograms and sends emails notifying of
their expiry.</p>
<a class="header" href="#what-it-can-do" id="what-it-can-do"><h2>What it can do</h2></a>
<p>Telemetry Alerts is very good at identifying sudden changes in the
shapes of normalized distributions of Telemetry probes. If you can see
the distribution of <a href="https://mzl.la/2vdMRax"><code>GC_MS</code></a> shift from one day
to the next, then likely so can Cerberus.</p>
<a class="header" href="#what-cant-it-do" id="what-cant-it-do"><h2>What can't it do</h2></a>
<p>Telemetry Alerts is not able to see sudden shifts in volume. It is also
very easily fooled if a change happens over a long period of time or
doesn't fundamentally alter the shape of the probe's histogram.</p>
<p>So if you have a probe like
<a href="https://mzl.la/2vdiuRx"><code>SCALARS_BROWSER.ENGAGEMENT.MAX_CONCURRENT_TAB_COUNT</code></a>,
Cerberus won't notice if:</p>
<ul>
<li>The number of pings reporting this value decreased in half, but
otherwise reported the same spread of numbers</li>
<li>The value increases very slowly over time (which I'd expect it to do
given how good Session Restore is these days)</li>
<li>We suddenly received twice as many pings from 200-tab subsessions
(the dominance of 1-tab pings would likely ensure the overall shape
of the distribution changed insufficiently much for Cerberus to pick
up on it)</li>
</ul>
<a class="header" href="#telemetry-alert-emails" id="telemetry-alert-emails"><h2>Telemetry Alert Emails</h2></a>
<p>One of the main ways humans interact with Telemetry Alerts is through
the emails sent by Medusa.</p>
<p>At present the email contains a link to the alert's page on
<a href="https://alerts.telemetry.mozilla.org">https://alerts.telemetry.mozilla.org</a> and a link to a pushlog on
<a href="https://hg.mozilla.org">https://hg.mozilla.org</a> detailing the changes newly-present in the
Nightly build that exhibited the change.</p>
<a class="header" href="#triaging-a-telemetry-alert-email" id="triaging-a-telemetry-alert-email"><h2>Triaging a Telemetry Alert Email</h2></a>
<p>Congratulations! You have just received a Telemetry Alert!</p>
<p>Now what?</p>
<p><strong>Assumption:</strong> Alerts happen because of changes in probes. Changes in
probes happen because of changes in related code. If we can identify the
code change, we can find the bug that introduced the code change. If we
can find the bug, we can ni? the person who made the change.</p>
<p><strong>Goal:</strong> Identify the human responsible for the Alert so they can
identify if it is
good/bad/intentional/exceptional/temporary/permanent/still
relevant/having its alerts properly looked after.</p>
<p><strong>Guide:</strong></p>
<ol>
<li>
<p>Is this alert just one of a group of similar changes by topic? By
build?</p>
</li>
</ol>
<ul>
<li>
<p>If there's a group by topic (<code>SPDY</code>, <code>URLCLASSIFIER</code>, ...) check to see
if the changes are similar in direction/magnitude. They usually are.</p>
</li>
<li>
<p>If there's a group by build but not topic, maybe a large merge
kicked things over. Unfortunate, as that will make finding the source
more difficult.</p>
</li>
</ul>
<ol start="2">
<li>
<p>Open the <code>hg.mozilla.org</code> and <code>alerts.telemetry.mozilla.org</code> links in
tabs</p>
</li>
</ol>
<ul>
<li>
<p>On <code>alerts.tmo</code>, does it look like an improvement or regression? (This
is just a first idea and might change. There are often extenuating
circumstances that make something that looks bad into an
improvement, and vice versa.)</p>
</li>
<li>
<p>On <code>hg.mo</code>, does the topic of the changed probe exist in the pushlog?
In other words, does any part of the probe's name show up in the
summaries of any of the commits?</p>
</li>
</ul>
<ol start="3">
<li>
<p>From <code>alerts.tmo</code>, open the <a href="https://telemetry.mozilla.org">https://telemetry.mozilla.org</a> link by
clicking on the plot's title. Open another tab to the Evolution View.</p>
</li>
</ol>
<ul>
<li>
<p>Is the change temporary? (might have been noticed elsewhere and
backed out)</p>
</li>
<li>
<p>Is the change up or down?</p>
</li>
<li>
<p>Has it happened before?</p>
</li>
<li>
<p>Was it accompanied by a decrease in submission volume? (the second
graph at the bottom of the Evolution View)</p>
</li>
<li>
<p>On the Distribution View, did the Sample Count increase? Decrease?
(this signifies that the change could be because of the addition or
subtraction of a population of values. For instance, we could
suddenly stop sending 0 values which would shift the graph to
the right. This could be a good thing (we're not handling useless
things any longer) a bad thing (something broke and we're no longer
measuring the same thing we used to measure) or indifferent)</p>
</li>
</ul>
<ol start="4">
<li>
<p>If you still don't have a cause</p>
</li>
</ol>
<ul>
<li>
<p>Use DXR or searchfox to find where the probe is accumulated.</p>
</li>
<li>
<p>Click &quot;Log&quot; in that view.</p>
</li>
<li>
<p>Are there any changesets in the resultant <code>hg.mo</code> list that ended up
in the build we received the Alert for?</p>
</li>
</ul>
<ol start="5">
<li>
<p>If you <em>still</em> don't know what's going on</p>
</li>
</ol>
<ul>
<li>find a domain expert on IRC and bother them to help you out. Domain
knowledge is awesome.</li>
</ul>
<p>From pursuing these steps or sub-steps you should now have two things: a
bug that likely caused the alert, and an idea of what the alert is
about.</p>
<p>Now comment on the bug. Feel free to use this script:</p>
<pre><code class="language-text">This bug may have contributed to a sudden change in the Telemetry probe &lt;PROBE_NAME&gt;[1] which seems to have occurred in Nightly &lt;builddate&gt;[2][3].

There was a &lt;describe the change: increase/decrease, population addition/subtraction, regression/improvement, change in submission/sample volume...&gt;.
This might mean &lt;wild speculation. It'll encourage the ni? to refute it :) &gt;

Is this an improvement? A regression?

Is this intentional? Is this expected?

Is this probe still measuring something useful?

[1]: &lt;the alerts.tmo link&gt;
[2]: &lt;the hg.mo link for the pushlog&gt;
[3]: &lt;the telemetry.mozilla.org link showing the Evolution View&gt;
</code></pre>
<p>Then ni? the person who pushed the change. Reply-all to the
<code>dev-telemetry-alerts</code> mail with a link to the bug and some short notes on
what you found.</p>
<p>From here the user on ni? should get back to you in fairly short order
and either help you find the real bug that caused it, or help explain
what the Alert was all about. More often than not it is an expected
change from a probe that is still operating correctly and there is no
action to take...</p>
<p>...except making sure you never have to respond to an Alert for this
probe again, that is. File a bug in that bug's component to update the
Alerting probe to have a valid, monitored <code>alert_emails</code> field so that
the next time it misbehaves <em>they</em> can be the ones to explain themselves
without you having to spend all this time tracking them down.</p>
<a class="header" href="#working-with-parquet" id="working-with-parquet"><h1>Working with Parquet</h1></a>
<p>This guide will give you a quick introduction to working with
<a href="https://parquet.apache.org/">Parquet</a> files at Mozilla.
You can also refer to Spark's documentation on the subject
<a href="http://spark.apache.org/docs/latest/sql-programming-guide.html#parquet-files">here</a>.</p>
<p>Most of our <a href="../datasets/derived.html">derived datasets</a>,
like the <code>longitudinal</code> or <code>main_summary</code> tables,
are stored in Parquet files.
You can access these datasets in <a href="https://sql.telemetry.mozilla.org/">re:dash</a>,
but you may want to access the data from an
<a href="https://analysis.telemetry.mozilla.org/">ATMO</a> cluster
if SQL isn't powerful enough for your analysis
or if a sample of the data will not suffice.</p>
<a class="header" href="#table-of-contents-3" id="table-of-contents-3"><h2>Table of Contents</h2></a>
<ul>
<li><a href="#reading-parquet-tables">Reading Parquet Tables</a></li>
<li><a href="#writing-parquet-tables">Writing Parquet Tables</a>
<ul>
<li><a href="#where-to-save-data">Where to save data</a></li>
<li><a href="#how-to-save-data">How to save data</a></li>
</ul>
</li>
<li><a href="#accessing-parquet-tables-from-redash">Accessing Parquet Tables from Re:dash</a></li>
</ul>
<a class="header" href="#reading-parquet-tables" id="reading-parquet-tables"><h1>Reading Parquet Tables</h1></a>
<p>Spark provides native support for reading parquet files.
The result of loading a parquet file is a
<a href="http://spark.apache.org/docs/2.1.0/api/python/pyspark.sql.html#pyspark.sql.DataFrame">DataFrame</a>.
For example, you can load <code>main_summary</code> with the following snippet:</p>
<pre><code class="language-python"># Parquet files are self-describing so the schema is preserved.
main_summary = spark.read.parquet('s3://telemetry-parquet/main_summary/v1/')
</code></pre>
<p>You can find the S3 path for common datasets in
<a href="../concepts/choosing_a_dataset.html">Choosing a Dataset</a>
or in the reference documentation.</p>
<a class="header" href="#writing-parquet-tables" id="writing-parquet-tables"><h1>Writing Parquet Tables</h1></a>
<p>Saving a table to parquet is a great way to share an intermediate dataset.</p>
<a class="header" href="#where-to-save-data" id="where-to-save-data"><h2>Where to save data</h2></a>
<p>You can save data to a subdirectory of the following bucket:
<code>s3://net-mozaws-prod-us-west-2-pipeline-analysis/&lt;username&gt;/</code>
Use your username for the subdirectory name.
This bucket is available to all ATMO clusters and Airflow.</p>
<p>When your analysis is production ready,
open a PR against <a href="https://github.com/mozilla/python_mozetl"><code>python_mozetl</code></a>.</p>
<a class="header" href="#how-to-save-data" id="how-to-save-data"><h2>How to save data</h2></a>
<p>You can save the DataFrame <code>test_dataframe</code>
to the <code>telemetry-test-bucket</code> with the following command:</p>
<pre><code class="language-python">test_dataframe.write.mode('error') \
    .parquet('s3://telemetry-test-bucket/my_subdir/table_name')
</code></pre>
<p>Note: data saved to <code>s3://telemetry-test-bucket</code> will automatically be deleted
after 30 days.</p>
<a class="header" href="#accessing-parquet-tables-from-redash" id="accessing-parquet-tables-from-redash"><h1>Accessing Parquet Tables from Re:dash</h1></a>
<p>See <a href="create_a_dataset.html">Creating a custom re:dash dataset</a>.</p>
<a class="header" href="#creating-your-own-dataset-to-query-in-redash" id="creating-your-own-dataset-to-query-in-redash"><h1>Creating Your Own Dataset to Query in re:dash</h1></a>
<ol>
<li>Create a spark notebook that does the transformations you need, either on
raw data (using Dataset API) or on parquet data</li>
<li>Output the results of that to an S3 location, usually
<code>telemetry-parquet/user/$YOUR_DATASET/v$VERSION_NUMBER/submission_date=$YESTERDAY/</code>.
This would partition by <code>submission_date</code>, meaning each day this runs and is
outputted to a new location in S3. Do NOT put the <code>submission_date</code> in the
parquet file as well! A column name cannot also be the name of a partition.
Partitioning is optional, but datasets should have a version in the path.</li>
<li>Using <a href="https://bugzilla.mozilla.org/enter_bug.cgi?bug_file_loc=http%3A%2F%2F&amp;bug_ignored=0&amp;bug_severity=normal&amp;bug_status=NEW&amp;cf_fx_iteration=---&amp;cf_fx_points=1&amp;comment=Location%20of%20the%20dataset%3A%20%0D%0ADesired%20dataset%20name%3A&amp;component=Operations&amp;contenttypemethod=autodetect&amp;contenttypeselection=text%2Fplain&amp;defined_groups=1&amp;flag_type-4=X&amp;flag_type-607=X&amp;flag_type-800=X&amp;flag_type-803=X&amp;flag_type-916=X&amp;form_name=enter_bug&amp;maketemplate=Remember%20values%20as%20bookmarkable%20template&amp;op_sys=Linux&amp;priority=P1&amp;product=Data%20Platform%20and%20Tools&amp;rep_platform=x86_64&amp;short_desc=Publish%20dataset&amp;target_milestone=---&amp;version=unspecified&amp;status_whiteboard=%5BDataOps%5D">this template</a>,
open a bug to publish the dataset (making it available in Spark and Re:dash) with the following attributes:
<ul>
<li>Add whiteboard tag <code>[DataOps]</code></li>
<li>Title: &quot;Publish dataset&quot;</li>
<li>Content: Location of the dataset in S3 (from step 2 above) and the desired table name</li>
</ul>
</li>
</ol>
<a class="header" href="#sending-a-custom-ping" id="sending-a-custom-ping"><h1>Sending a Custom Ping</h1></a>
<p>Got some new data you want to send to us? How in the world do you send a new ping? Follow this guide
to find out.</p>
<a class="header" href="#write-your-questions" id="write-your-questions"><h2>Write Your Questions</h2></a>
<p>Do not try and implement new pings unless you know specifically what questions you're trying to
answer. General questions about &quot;How do users use our product?&quot; won't cut it - these need to be
specific, concrete asks that can be translated to data points. This will also make it easier down
the line as you start data review.</p>
<p>More detail on how to design and implement new pings for Firefox Desktop <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/custom-pings.html">can be found here</a>.</p>
<a class="header" href="#choose-a-namespace-and-doctype" id="choose-a-namespace-and-doctype"><h2>Choose a Namespace and DocType</h2></a>
<p>For new telemetry pings, the namespace is simply <code>telemetry</code>. For non-Telemetry
pings, choose a namespace that uniquely identifies the product that will be
generating the data.</p>
<p>The DocType is used to differentiate pings within a namespace. It can be as
simple as <code>event</code>, but should generally be descriptive of the data being
collected.</p>
<p>Both namespace and DocType are limited to the pattern <code>[a-zA-Z-]</code>. In other words, hyphens and letters from the <a href="https://en.wikipedia.org/wiki/ISO_basic_Latin_alphabet">ISO basic Latin alphabet</a>.</p>
<a class="header" href="#create-a-schema" id="create-a-schema"><h2>Create a Schema</h2></a>
<p>Use JSON Schema to start with. See the <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas#adding-a-new-schema">&quot;Adding a new schema&quot; documentation</a> and examples schemas in the
<a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/">Mozilla Pipeline Schemas repo</a>.
This schema is just used to validate the incoming data; any ping that doesn't match the schema
will be removed. Validate your JSON Schema using a
<a href="https://jsonschemalint.com/#/version/draft-04/markup/json">validation tool</a>.</p>
<p>We already have automatic deduplicating based on <code>docId</code>, which catches about 90% of duplicates and
removes them from the dataset.</p>
<a class="header" href="#start-a-data-review" id="start-a-data-review"><h2>Start a Data Review</h2></a>
<p>Data review for new pings is more complicated than when adding new probes. See
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1347266">Data Review for Focus-Event Ping</a>
as an example. Consider where the data falls in the
<a href="https://wiki.mozilla.org/Firefox/Data_Collection">Data Collection Categories</a>.</p>
<a class="header" href="#submit-schema-to-mozilla-servicesmozilla-pipeline-schemas" id="submit-schema-to-mozilla-servicesmozilla-pipeline-schemas"><h2>Submit Schema to <code>mozilla-services/mozilla-pipeline-schemas</code></h2></a>
<p>The first schema added should be the JSON Schema made in step 2.
Add at least one example ping which the data can be validated against.
These test pings will be validated automatically during the build.</p>
<p>Additionally,
a <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/blob/master/schemas/telemetry/core/core.9.parquetmr.txt">Parquet output</a>
schema should be added. This would add a new dataset, available in <a href="https://sql.telemetry.mozilla.org">Re:dash</a>.
The best documentation we have for the Parquet schema is by looking at the examples in
<a href="https://github.com/mozilla-services/mozilla-pipeline-schemas"><code>mozilla-pipeline-schemas</code></a>.</p>
<p>Parquet output also has a <code>metadata</code> section. These are fields added to the ping at ingestion time;
they might come from the URL submitted to the edge server, or the IP Address used to make the request.
<a href="https://pipeline-cep.prod.mozaws.net/dashboard_output/analysis.moz_telemetry_parquet_schema.parquet.txt">This document</a>
lists available metadata fields for all pings.</p>
<p>The stream you're interested in is probably <code>telemetry</code>.
For example, look at <code>system-addon-deployment-diagnostics</code> immediately under the <code>telemetry</code> top-level
field. The <code>schema</code> element has top-level fields (e.g. <code>Timestamp</code>, <code>Type</code>), as well as more fields
under the <code>Fields</code> element. Any of these can be used in the <code>metadata</code> section of your parquet schema,
except for <code>submission</code>.</p>
<p>Some common ones for Telemetry data might be:</p>
<ul>
<li><code>Date</code></li>
<li><code>submissionDate</code></li>
<li><code>geoCountry</code></li>
<li><code>geoCity</code></li>
<li><code>geoSubdivision1</code></li>
<li><code>geoSubdivision2</code></li>
<li><code>normalizedChannel</code></li>
<li><code>appVersion</code></li>
<li><code>appBuildId</code></li>
</ul>
<p>And for non-Telemetry data:</p>
<ul>
<li><code>geoCountry</code></li>
<li><code>geoCity</code></li>
<li><code>geoSubdivision1</code></li>
<li><code>geoSubdivision2</code></li>
<li><code>documentId</code></li>
</ul>
<p><em>Important Note</em>: Schema evolution of nested structs is currently broken, so you will not be able to add
any fields in the future to your <code>metadata</code> section. We recommend adding any that may seem useful.</p>
<a class="header" href="#testing-the-schema" id="testing-the-schema"><h3>Testing The Schema</h3></a>
<p>For new data, use the <a href="https://github.com/mozilla-services/edge-validator">edge validator</a> to test
your schema.</p>
<p>If your data is <em>already</em> being sent, and you want to test the schema you're writing on the data
that is currently being ingested, you can test your Parquet output in
<a href="https://pipeline-cep.prod.mozaws.net/">Hindsight</a> by using an output plugin.
See <a href="https://bugzilla.mozilla.org/attachment.cgi?id=8829626">Core ping output plugin</a>
for an example, where the parquet schema is specified as <code>parquet_schema</code>. If no errors arise, that
means it should be correct. The &quot;Deploy&quot; button should not be used to actually deploy, that will be
done by operations in the next step.</p>
<a class="header" href="#telemetry-specific-deploy-the-plugin" id="telemetry-specific-deploy-the-plugin"><h2>(Telemetry-specific) Deploy the Plugin</h2></a>
<p>File <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1333203">a bug to deploy the new schema.</a></p>
<p>Real-time analysis will be key to ensuring your data is being processed and parsed correctly.
It should follow the format specified in
<a href="https://mozilla-services.github.io/lua_sandbox_extensions/moz_telemetry/sandboxes/heka/analysis/moz_telemetry_doctype_monitor.html">MozTelemetry <code>docType</code> monitor</a>.
This allows you to check validation errors, size changes, duplicates, and more. Once you have
the numbers set, file a
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1356380">bug to let ops deploy it</a>.</p>
<a class="header" href="#start-sending-data" id="start-sending-data"><h2>Start Sending Data</h2></a>
<p>If you're using the Telemetry APIs, use those built-in. These can be with the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/custom-pings.html">Gecko Telemetry APIs</a>,
the <a href="https://github.com/mozilla-mobile/telemetry-android">Android Telemetry APIs</a>, or the
<a href="https://github.com/mozilla-mobile/telemetry-ios">iOS Telemetry APIs</a>.</p>
<p>For non-Telemetry data, see <a href="../concepts/pipeline/http_edge_spec.html">our HTTP edge server specification</a>
and specifically the <a href="../concepts/pipeline/http_edge_spec.html#postput-request">non-Telemetry example</a> for the expected format. The edge
server endpoint is <code>https://incoming.telemetry.mozilla.org</code>.</p>
<a class="header" href="#non-telemetry-access-your-data" id="non-telemetry-access-your-data"><h2>(Non-Telemetry) Access Your Data</h2></a>
<p>First confirm with the reviewers of
<a href="#submit-schema-to-mozilla-servicesmozilla-pipeline-schemas">your schema pull request</a>
that your schemas have been deployed.</p>
<p>In the following links, replace <code>&lt;namespace&gt;</code>, <code>&lt;doctype&gt;</code> And <code>&lt;docversion&gt;</code> with
appropriate values. Also replace <code>-</code> with <code>_</code> in <code>&lt;namespace&gt;</code> if your
namespace contains <code>-</code> characters.</p>
<a class="header" href="#cep" id="cep"><h3>CEP</h3></a>
<p>Once you've sent some pings, refer to the following real-time analysis plugins
to verify that your data is being processed:</p>
<ul>
<li><code>https://pipeline-cep.prod.mozaws.net/dashboard_output/graphs/analysis.moz_generic_error_monitor.&lt;namespace&gt;.html</code></li>
<li><code>https://pipeline-cep.prod.mozaws.net/dashboard_output/analysis.moz_generic_&lt;namespace&gt;_&lt;doctype&gt;_&lt;docversion&gt;.submissions.json</code></li>
<li><code>https://pipeline-cep.prod.mozaws.net/dashboard_output/analysis.moz_generic_&lt;namespace&gt;_&lt;doctype&gt;_&lt;docversion&gt;.errors.txt</code></li>
</ul>
<p>If this first graph shows ingestion errors, you can view the corresponding
error messages in the third link. Otherwise, you should be able to view the
last ten processed submissions via the second link. You can also write your own
custom real-time analysis plugins using this same infrastructure if you desire;
use the above plugins as examples and see
<a href="realtime_analysis_plugin.html">here</a> for a more detailed explanation.</p>
<p>If you encounter schema validation errors, you can fix your data or
<a href="#submit-schema-to-mozilla-servicesmozilla-pipeline-schemas">submit another pull request</a>
to amend your schemas. Backwards-incompatible schema changes should generally
be accompanied by an increment to <code>docversion</code>.</p>
<p>Once you've established that your pings are flowing through the real-time
system, verify that you can access the data from the downstream systems.</p>
<a class="header" href="#stmo" id="stmo"><h3>STMO</h3></a>
<p>In the Athena data source, a new table
<code>&lt;namespace&gt;_&lt;doctype&gt;_parquet_&lt;docversion&gt;</code> will be created for your data. A
convenience pointer <code>&lt;namespace&gt;_&lt;doctype&gt;_parquet</code> will also refer to the latest
available <code>docversion</code> of the ping. The data is partitioned by
<code>submission_date_s3</code> which is formatted as <code>%Y%m%d</code>, like <code>20180130</code>, and is
generally updated hourly. Refer to the <a href="../tools/stmo.html">STMO documentation</a>
for general information about using Re:dash.</p>
<p>This table may take up to a day to appear in the Athena source; if you still
don't see a table for your new ping after 24 hours,
<a href="https://mana.mozilla.org/wiki/display/SVCOPS/Contacting+Data+Operations">contact Data Operations</a>
so that they can investigate. Once the table is available, it should contain
all the pings sent during that first day, regardless of how long it takes for
the table to appear.</p>
<a class="header" href="#atmo" id="atmo"><h3>ATMO</h3></a>
<p>The data should be available in S3 at:</p>
<p><code>s3://net-mozaws-prod-us-west-2-pipeline-data/&lt;namespace&gt;-&lt;doctype&gt;-parquet/v&lt;docversion&gt;/</code></p>
<p>Note: here <code>&lt;namespace&gt;</code> should not be escaped.</p>
<p>Refer to the <a href="../tools/spark.html#faq">Spark FAQ</a> for details on accessing this table via ATMO.</p>
<a class="header" href="#write-etl-jobs" id="write-etl-jobs"><h2>Write ETL Jobs</h2></a>
<p>We have some basic generalized ETL jobs you can use to transform your data on a batch basis - for example,
a <a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/GenericLongitudinal.scala">Longitudinal</a>
or <a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/GenericCountView.scala">client-count-daily</a>
like dataset. Otherwise, you'll have to write your own.</p>
<p>You can schedule it on <a href="http://workflow.telemetry.mozilla.org/">Airflow</a>, or you can
run it as a job in ATMO. If the output is parquet, you can add it to the Hive metastore to have it
available in re:dash. Check the docs on <a href="create_a_dataset.html">creating your own datasets</a>.</p>
<a class="header" href="#build-dashboards-using-atmo-or-stmo" id="build-dashboards-using-atmo-or-stmo"><h2>Build Dashboards Using ATMO or STMO</h2></a>
<p>Last steps! What are you using this data for anyway?</p>
<a class="header" href="#working-with-hyperloglog-in-zeppelin" id="working-with-hyperloglog-in-zeppelin"><h1>Working with HyperLogLog in Zeppelin</h1></a>
<p>This guide will set you up to work with HyperLogLog in Zeppelin.</p>
<a class="header" href="#zeppelin-configuration" id="zeppelin-configuration"><h2>Zeppelin Configuration</h2></a>
<ul>
<li>
<p>Launch a Zeppelin notebook</p>
</li>
<li>
<p>Open the panel for Interpreter configuration</p>
<ul>
<li>This can be found at <code>localhost:8890/#/intepreter</code></li>
</ul>
</li>
<li>
<p>Add the Sonatype Snapshot repository</p>
<ul>
<li>Expand the Repository Information cog, next to the create button</li>
<li>Settings are as follows:</li>
</ul>
<pre><code>ID: Sonatype OSS Snapshots
URL: https://oss.sonatype.org/content/repositories/snapshots
Snapshot: true
</code></pre>
</li>
<li>
<p>Add the dependency to the <code>Spark</code> interpreter</p>
<ul>
<li>spark &gt; Edit &gt; Dependencies</li>
<li>Add the following entry to artifacts:</li>
</ul>
<pre><code>com.mozilla.telemetry:spark-hyperloglog:2.0.0-SNAPSHOT
</code></pre>
</li>
</ul>
<p>These steps should enable the use of the library within the notebook. Using the
<code>%dep</code> interpreter to dynamically add the library is currently not supported.
You may want to add a short snippet near the top of the notebook to make the
functions more accessible.</p>
<pre><code class="language-scala">import org.apache.spark.sql.functions.udf
import com.mozilla.spark.sql.hyperloglog.aggregates._
import com.mozilla.spark.sql.hyperloglog.functions._

val HllMerge = new HyperLogLogMerge
val HllCreate = udf(hllCreate _)
val HllCardinality = udf(hllCardinality _)

spark.udf.register(&quot;hll_merge&quot;, HllMerge)
spark.udf.register(&quot;hll_create&quot;, HllCreate)
spark.udf.register(&quot;hll_cardinality&quot;, HllCardinality)
</code></pre>
<a class="header" href="#example-usage" id="example-usage"><h2>Example Usage</h2></a>
<p>This is a short example which can also be used to verify expected behavior.</p>
<pre><code class="language-scala">case class Example(uid: String, color: String)

val examples = Seq(
    Example(&quot;uid_1&quot;, &quot;red&quot;),
    Example(&quot;uid_2&quot;, &quot;blue&quot;),
    Example(&quot;uid_3&quot;, &quot;blue&quot;),
    Example(&quot;uid_3&quot;, &quot;red&quot;))

val frame = examples.toDF()
</code></pre>
<p>In a single expression, we can create and count the unique id's that appear in the DataFrame.</p>
<pre><code class="language-scala">&gt;&gt;&gt; frame
  .select(expr(&quot;hll_create(uid, 12) as hll&quot;))
  .groupBy()
  .agg(expr(&quot;hll_cardinality(hll_merge(hll)) as count&quot;))
  .show()

+-----+
|count|
+-----+
|    3|
+-----+
</code></pre>
<p>The code in the previous section defines UDF functions that can be used directly
as Spark column expressions. Let's explore the data structure a bit more in
slightly more detail.</p>
<pre><code class="language-scala">val example = frame
    .select(HllCreate($&quot;uid&quot;, lit(12)).alias(&quot;hll&quot;), $&quot;color&quot;)
    .groupBy(&quot;color&quot;)
    .agg(HllMerge($&quot;hll&quot;).alias(&quot;hll&quot;))

example.createOrReplaceTempView(&quot;example&quot;)
</code></pre>
<p>This groups <code>uid</code>s by the <code>color</code> attribute and registers the table with the SQL
context. Each row contains a HLL binary object representing the set of <code>uid</code>s.</p>
<pre><code class="language-scala">&gt;&gt;&gt; example.show()
+-----|--------------------+
|color|                 hll|
+-----|--------------------+
|  red|[02 0C 00 00 00 0...|
| blue|[02 0C 00 00 00 0...|
+-----|--------------------+
</code></pre>
<p>Each HLL object takes up <code>2^12</code> bits of space. This configurable size parameter
affects the size and standard error of the cardinality estimates. The
cardinality operator can count the number of <code>uid</code>s associated with each <code>color</code>.</p>
<pre><code class="language-scala">&gt;&gt;&gt; example.select($&quot;color&quot;, HllCardinality($&quot;hll&quot;).alias(&quot;count&quot;)).show()
+-----|-----+
|color|count|
+-----|-----+
|  red|    2|
| blue|    2|
+-----|-----+
</code></pre>
<p>We can also write this query in the <code>%sql</code> interpreter.</p>
<pre><code class="language-SQL">%dep sql

SELECT color, hll_cardinality(hll_merge(hll)) as count
FROM example
GROUP BY color
</code></pre>
<p>Finally, note that the <code>color</code> HLL sets have an overlapping <code>uid</code>. We obtain the
count of <code>uid</code>s and avoid double counting by merging the sets.</p>
<pre><code class="language-scala">&gt;&gt;&gt; example.groupBy().agg(HllCardinality(HllMerge($&quot;hll&quot;)).alias(&quot;count&quot;)).show()
+-----+
|count|
+-----+
|    3|
+-----+
</code></pre>
<a class="header" href="#longitudinal-examples" id="longitudinal-examples"><h1>Longitudinal Examples</h1></a>
<a class="header" href="#introduction-2" id="introduction-2"><h3>Introduction</h3></a>
<p>The longitudinal dataset is a summary of main pings. If you're not sure which
dataset to use for your query, this is probably what you want. It differs from
the <code>main_summary</code> table in two important ways:</p>
<ul>
<li>The longitudinal dataset groups all data for a client-id in the same row.
This makes it easy to report profile level metrics. Without this deduplicating,
metrics would be weighted by the number of submissions instead of by clients.</li>
<li>The dataset uses a 1% of all recent profiles, which will reduce query
computation time and save resources. The sample of clients will be stable over
time.</li>
</ul>
<p>Accordingly, one should prefer using the Longitudinal dataset except in the
rare case where a 100% sample is strictly necessary.</p>
<p>As discussed in the <a href="http://reports.telemetry.mozilla.org/post/tutorials/longitudinal_dataset.kp">Longitudinal Data Set Example Notebook</a>:</p>
<pre><code>The longitudinal dataset is logically organized as a table where rows
represent profiles and columns the various metrics (e.g. startup time). Each
field of the table contains a list of values, one per Telemetry submission
received for that profile. [...]

The current version of the longitudinal dataset has been build with all
main pings received from 1% of profiles across all channels with [...] up to
180 days of data.
</code></pre>
<a class="header" href="#table-structure" id="table-structure"><h3>Table structure</h3></a>
<p>To get an overview of the longitudinal data table:</p>
<pre><code class="language-sql">DESCRIBE longitudinal
</code></pre>
<p>That table has a row for each client, with columns for the different
parts of the ping. There are a lot of fields here, so I recommend
downloading the results as a CSV if you want to search through these
fields. Unfortunately, there's no way to filter the output of DESCRIBE
in Presto.</p>
<p>Because this table combines all rows for a given client id, most columns
contain either Arrays or Maps (described below). A few properties are
directly available to query on:</p>
<pre><code class="language-sql">SELECT count(*) AS count
FROM longitudinal
WHERE os = 'Linux'
</code></pre>
<a class="header" href="#arrays" id="arrays"><h4>Arrays</h4></a>
<p>Most properties are arrays, which contain one entry for each submission
from a given client (newest first). Note that indexing starts at 1:</p>
<pre><code class="language-sql">SELECT reason[1] AS newest_reason
FROM longitudinal
WHERE os = 'Linux'
</code></pre>
<p>To expand arrays and maps and work on the data row-wise we can use
<code>UNNEST(array)</code>.</p>
<pre><code class="language-sql">WITH lengths AS
  (SELECT os, greatest(-1, least(31, sl / (24*60*60))) AS days
   FROM longitudinal
   CROSS JOIN UNNEST(session_length, reason) AS t(sl, r)
   WHERE r = 'shutdown' OR r = 'aborted-session')
SELECT os, days, count(*) AS count
FROM lengths
GROUP BY days, os ORDER BY days ASC
</code></pre>
<p>However, it may be better to use a sample from the <code>main_summary</code> table
instead.</p>
<p>Links:</p>
<ul>
<li><a href="https://prestodb.io/docs/current/functions/array.html">Documentation on array
functions</a></li>
<li><a href="https://prestodb.io/docs/current/sql/select.html#unnest"><code>UNNEST</code>
documentation</a></li>
</ul>
<a class="header" href="#maps" id="maps"><h4>Maps</h4></a>
<p>Some fields like <code>active_addons</code> or <code>user_prefs</code> are handled as maps, on
which you can use the <code>[]</code> operator and special functions:</p>
<pre><code class="language-sql">WITH adp AS
  (SELECT active_addons[1]['{d10d0bf8-f5b5-c8b4-a8b2-2b9879e08c5d}']
            IS NOT null AS has_adblockplus
   FROM longitudinal)
SELECT has_adblockplus, count(*) AS count
FROM adp GROUP BY 1 ORDER BY 2 DESC
</code></pre>
<p>Links:</p>
<ul>
<li><a href="https://prestodb.io/docs/current/functions/map.html">Documentation on map
functions</a></li>
</ul>
<a class="header" href="#sampling" id="sampling"><h3>Sampling</h3></a>
<p>While composing queries, it can be helpful to work on small samples to
reduce query runtime:</p>
<pre><code class="language-sql">SELECT * FROM longitudinal LIMIT 1000 ...
</code></pre>
<p>There's no need to use other sampling methods, such as <code>TABLESAMPLE</code>, on
the longitudinal set. Rows are randomly ordered, so a <code>LIMIT</code> sample is
expected to be random.</p>
<a class="header" href="#example-queries" id="example-queries"><h3>Example Queries</h3></a>
<a class="header" href="#blocklist-urls-extensionsblocklisturl" id="blocklist-urls-extensionsblocklisturl"><h4>Blocklist URLs (<code>extensions.blocklist.url</code>)</h4></a>
<pre><code class="language-sql">SELECT bl, COUNT(bl)
FROM
  (SELECT element_at(settings, 1).user_prefs['extensions.blocklist.url'] AS bl
   FROM longitudinal)
GROUP BY bl
</code></pre>
<a class="header" href="#blocklist-enableddisabled-extensionsblocklistenabled-count" id="blocklist-enableddisabled-extensionsblocklistenabled-count"><h4>Blocklist enabled/disabled (<code>extensions.blocklist.enabled</code>) count:</h4></a>
<pre><code class="language-sql">SELECT bl, COUNT(bl)
FROM
  (SELECT element_at(settings, 1).blocklist_enabled AS bl
   FROM longitudinal)
GROUP BY bl
</code></pre>
<a class="header" href="#parsing-most-recent-submission_date" id="parsing-most-recent-submission_date"><h4>Parsing most recent <code>submission_date</code></h4></a>
<pre><code class="language-sql">SELECT DATE_PARSE(submission_date[1], '%Y-%m-%dT00:00:00.000Z') as parsed_submission_date
FROM longitudinal
</code></pre>
<a class="header" href="#limiting-to-most-recent-ping-in-the-last-7-days" id="limiting-to-most-recent-ping-in-the-last-7-days"><h4>Limiting to most recent ping in the last 7 days</h4></a>
<pre><code class="language-sql">SELECT * FROM longitudinal
WHERE DATE_DIFF('day', DATE_PARSE(submission_date[1], '%Y-%m-%dT00:00:00.000Z'), current_date) &lt; 7
</code></pre>
<a class="header" href="#scalar-measurement-how-many-users-with-more-than-100-tabs" id="scalar-measurement-how-many-users-with-more-than-100-tabs"><h4>Scalar measurement (how many users with more than 100 tabs)</h4></a>
<pre><code class="language-sql">WITH samples AS
 (SELECT
   client_id,
   normalized_channel as channel,
   mctc.value AS max_concurrent_tabs
  FROM longitudinal
  CROSS JOIN UNNEST(scalar_parent_browser_engagement_max_concurrent_tab_count) as t (mctc)
  WHERE
   scalar_parent_browser_engagement_max_concurrent_tab_count is not null and
   mctc.value is not null and
   normalized_channel = 'nightly')
SELECT approx_distinct(client_id) FROM samples WHERE max_concurrent_tabs &gt; 100
</code></pre>
<a class="header" href="#keyed-scalars" id="keyed-scalars"><h4>Keyed scalars</h4></a>
<p>Retrieve all the keys for a given scalar and sum all values for each key giving
one row per key:</p>
<pre><code class="language-sql">SELECT t.key as open_type,
       SUM(REDUCE(t.val, 0, (s, x) -&gt; s + COALESCE(x.value, 0), s -&gt; s)) as open_count,
       normalized_channel AS &quot;channel::multi-filter&quot;
FROM longitudinal
CROSS JOIN UNNEST(scalar_parent_devtools_responsive_open_trigger) AS t(key, val)
GROUP BY t.key, normalized_channel
</code></pre>
<p>This query also makes use of <code>multi-filter</code> to show an interactive filter in
Re:dash.</p>
<p>This query requires a modern version of Presto, and because of this it currently
with the Presto data source but it doesn't work with the Athena data source.</p>
<a class="header" href="#using-views" id="using-views"><h3>Using Views</h3></a>
<p>If you find yourself copy/pasting SQL between different queries,
consider using a Presto VIEW to allow for code reuse. Views create
logical tables which you can reuse in other queries. For example, <a href="https://sql.telemetry.mozilla.org/queries/776/source">this
view</a> defines some
important filters and derived variables which are then used in <a href="https://sql.telemetry.mozilla.org/queries/777/source#1311">this
downstream
query</a>.</p>
<p>You can define a view by prefixing your query with</p>
<pre><code class="language-sql">CREATE OR REPLACE VIEW view_name AS ...
</code></pre>
<p>Be careful not to overwrite an existing view! Using a unique name is
important.</p>
<p>Find more information
<a href="https://prestodb.io/docs/current/sql/create-view.html">here</a>.</p>
<a class="header" href="#working-offline" id="working-offline"><h3>Working offline</h3></a>
<p>It's often useful to keep a local sample of the longitudinal data when
prototyping an analysis. The data is stored in
<code>s3://telemetry-parquet/longitudinal/</code>. Once you have AWS credentials you
can copy a shard of the parquet dataset to a local directory using
<code>aws s3 cp [filename] .</code></p>
<p>To request AWS credentials, see <a href="https://mana.mozilla.org/wiki/display/SVCOPS/Requesting+A+Dev+IAM+account+from+Cloud+Operations">this
page</a>.
To initialize your AWS credentials, try <code>aws configure</code></p>
<a class="header" href="#faq-1" id="faq-1"><h3>FAQ</h3></a>
<a class="header" href="#im-getting-an-error--cannot-be-resolved" id="im-getting-an-error--cannot-be-resolved"><h4>I'm getting an error, &quot;... cannot be resolved&quot;</h4></a>
<p>For some reason, re:dash has trouble parsing SQL strings with double
quotes. Try using single quotes instead.</p>
<a class="header" href="#other-resources" id="other-resources"><h3>Other Resources</h3></a>
<ul>
<li><a href="https://prestodb.io/docs/current/sql.html">Presto Docs</a></li>
<li><a href="https://docs.treasuredata.com/articles/presto-query-faq">Helpful FAQ covering Presto performance</a></li>
<li><a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/Longitudinal.scala#L194">Longitudinal schema definition</a></li>
<li><a href="https://wiki.mozilla.org/Custom_dashboards_with_re:dash">Custom dashboards with Re:dash</a></li>
</ul>
<a class="header" href="#working-with-crash-pings" id="working-with-crash-pings"><h1>Working with Crash Pings</h1></a>
<p>Here are some snippets to get you started querying crash pings
from the Dataset API.</p>
<p>We can first load and instantiate a Dataset object to query
the crash pings, and look at the possible fields to filter on:</p>
<pre><code class="language-python">from moztelemetry.dataset import Dataset
telem = Dataset.from_source(&quot;telemetry&quot;)
telem.schema
# =&gt; 'submissionDate, sourceName, sourceVersion, docType, appName, appUpdateChannel,
#     appVersion, appBuildId'
</code></pre>
<p>The more specific these filters, the faster it can be pulled.
The fields can be filtered by either value or a callable.
For example, a version and date range can be specified from the
<code>v5758</code> and <code>dates</code>lambdas below:</p>
<pre><code class="language-python">v5758 = lambda x: x[:2] in ('57', '58')
dates = lambda x: '20180126' &lt;= x &lt;= '20180202'
telem = (
    Dataset.from_source(&quot;telemetry&quot;)
    .where(docType='crash', appName=&quot;Firefox&quot;, appUpdateChannel=&quot;release&quot;,
           appVersion=v5758, submissionDate=dates)
)
</code></pre>
<p>Now, referencing the <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/crash-ping.html">docs for the crash ping</a>, the desired fields
can be selected and brought in as a spark RDD named <code>pings</code></p>
<pre><code class="language-python">sel = (
    telem.select(
        os_name='environment.system.os.name',
        os_version='environment.system.os.version',
        app_version='application.version',
        app_architecture='application.architecture',
        clientId='clientId',
        creationDate='creationDate',
        submissionDate='meta.submissionDate',
        sample_id='meta.sampleId',
        modules='payload.stackTraces.modules',
        stackTraces='payload.stackTraces',
        oom_size='payload.metadata.OOMAllocationSize',
        AvailablePhysicalMemory='payload.metadata.AvailablePhysicalMemory',
        AvailableVirtualMemory='payload.metadata.AvailableVirtualMemory',
        TotalPhysicalMemory='payload.metadata.TotalPhysicalMemory',
        TotalVirtualMemory='payload.metadata.TotalVirtualMemory',
        reason='payload.metadata.MozCrashReason',
        payload='payload',
    )
)
pings = sel.records(sc)
</code></pre>
<a class="header" href="#creating-a-real-time-analysis-plugin" id="creating-a-real-time-analysis-plugin"><h1>Creating a Real-time Analysis Plugin</h1></a>
<a class="header" href="#getting-started-1" id="getting-started-1"><h2>Getting Started</h2></a>
<p>Creating an analysis plugin consists of three steps:</p>
<ol>
<li>
<p>Writing a message matcher</p>
<p>The message matcher allows one to select specific data from the data stream.</p>
</li>
<li>
<p>Writing the analysis code/business logic</p>
<p>The analysis code allows one to aggregate, detect anomalies, apply machine
learning algorithms etc.</p>
</li>
<li>
<p>Writing the output code</p>
<p>The output code allows one to structure the analysis results in an easy to
consume format.</p>
</li>
</ol>
<a class="header" href="#step-by-step-setup" id="step-by-step-setup"><h3>Step by Step Setup</h3></a>
<ol>
<li>
<p>Go to the CEP site: https://pipeline-cep.prod.mozaws.net/</p>
</li>
<li>
<p>Login/Register using your Google <code>@mozilla.com</code> account</p>
</li>
<li>
<p>Click on the <code>Plugin Deployment</code> tab</p>
</li>
<li>
<p>Create a message matcher</p>
<ol>
<li>
<p>Edit the <code>message_matcher</code> variable in the <code>Heka Analysis Plugin Configuration</code>
text area. For this example we are selecting all telemetry messages. The
full syntax of the message matcher can be found here:
http://mozilla-services.github.io/lua_sandbox/util/message_matcher.html</p>
<pre><code class="language-lua">message_matcher = &quot;Type == 'telemetry'&quot;
</code></pre>
</li>
</ol>
</li>
<li>
<p>Test the message matcher</p>
<ol>
<li>
<p>Click the <code>Run Matcher</code> button.</p>
<p>Your results or error message will appear to the right.  You can browse
the returned messages to examine their structure and the data they
contain; this is very helpful when developing the analysis code but is
also useful for data exploration even when not developing a plugin.</p>
</li>
</ol>
</li>
<li>
<p>Delete the code in the <code>Heka Analysis Plugin</code> text area</p>
</li>
<li>
<p>Create the Analysis Code (<code>process_message</code>)</p>
<p>The <code>process_message</code> function is invoked every time a message is matched and
should return 0 for success and -1 for failure. Full interface documentation:
http://mozilla-services.github.io/lua_sandbox/heka/analysis.html</p>
<ol>
<li>
<p>Here is the minimum  implementation; type it into the
<code>Heka Analysis Plugin</code> text area:</p>
<pre><code class="language-lua">function process_message()
    return 0 -- success
end
</code></pre>
</li>
</ol>
</li>
<li>
<p>Create the Output Code (<code>timer_event</code>)</p>
<p>The <code>timer_event</code> function is invoked every <code>ticker_interval</code> seconds.</p>
<ol>
<li>
<p>Here is the minimum implementation; type it into the <code>Heka Analysis Plugin</code>
text area:</p>
<pre><code class="language-lua">function timer_event()
end
</code></pre>
</li>
</ol>
</li>
<li>
<p>Test the Plugin</p>
<ol>
<li>
<p>Click the <code>Test Plugin</code> button.</p>
<p>Your results or error message will appear to the right. If an error is
output, correct it and test again.</p>
</li>
</ol>
</li>
<li>
<p>Extend the Code to Perform a Simple Message Count Analysis/Output</p>
<ol>
<li>
<p>Replace the code in the <code>Heka Analysis Plugin</code> text area with the
following:</p>
<pre><code class="language-lua">local cnt = 0
function process_message()
    cnt = cnt + 1                       -- count the number of messages that matched
    return 0
end

function timer_event()
    inject_payload(&quot;txt&quot;, &quot;types&quot;, cnt) -- output the count
end
</code></pre>
</li>
</ol>
</li>
<li>
<p>Test the Plugin</p>
<ol>
<li>
<p>Click the <code>Test Plugin</code> button.</p>
<p>Your results or error message will appear to the right. If an error is
output, correct it and test again.</p>
</li>
</ol>
</li>
<li>
<p>Extend the Code to Perform a More Complex Count by Type Analysis/Output</p>
<ol>
<li>
<p>Replace the code in the <code>Heka Analysis Plugin</code> text area with the
following:</p>
<pre><code class="language-lua">types = {}
function process_message()
    -- read the docType from the message, if it doesn't exist set it to &quot;unknown&quot;
    local dt = read_message(&quot;Fields[docType]&quot;) or &quot;unknown&quot;

    -- look up the docType in the types hash
    local cnt = types[dt]
    if cnt then
        types[dt] = cnt + 1   -- if the type cnt exists, increment it by one
    else
        types[dt] = 1         -- if the type cnt didn't exist, initialize it to one
    end
    return 0
end

function timer_event()
    add_to_payload(&quot;docType = Count\n&quot;)   -- add a header to the output
    for k, v in pairs(types) do           -- iterate over all the key/values (docTypes/cnt in the hash)
        add_to_payload(k, &quot; = &quot;, v, &quot;\n&quot;) -- add a line to the output
    end
    inject_payload(&quot;txt&quot;, &quot;types&quot;)        -- finalize all the data written to the payload
end
</code></pre>
</li>
</ol>
</li>
<li>
<p>Test the Plugin</p>
<ol>
<li>
<p>Click the <code>Test Plugin</code> button.</p>
<p>Your results or error message will appear to the right. If an error is
output, correct it and test again.</p>
</li>
</ol>
</li>
<li>
<p>Deploy the plugin</p>
<ol>
<li>Click the <code>Deploy Plugin</code> button and dismiss the successfully deployed
dialog.</li>
</ol>
</li>
<li>
<p>View the running plugin</p>
<ol>
<li>Click the <code>Plugins</code> tab and look for the plugin that was just deployed
<code>{user}.example</code></li>
<li>Right click on the plugin to active the context menu allowing you to view
the source or stop the plugin.</li>
</ol>
</li>
<li>
<p>View the plugin output</p>
<ol>
<li>Click on the <code>Dashboards</code> tab</li>
<li>Click on the <code>Raw Dashboard Output</code> link</li>
<li>Click on <code>analysis.{user}.example.types.txt</code> link</li>
</ol>
</li>
</ol>
<a class="header" href="#where-to-go-from-here" id="where-to-go-from-here"><h3>Where to go from here</h3></a>
<ul>
<li>Lua Reference: http://www.lua.org/manual/5.1/manual.html</li>
<li>Available Lua Modules: https://mozilla-services.github.io/lua_sandbox_extensions/</li>
<li>Support
<ul>
<li>IRC: <a href="irc://irc.mozilla.org/hindsight">#hindsight on <code>irc.mozilla.org</code></a></li>
<li>Mailing list: https://mail.mozilla.org/listinfo/hindsight</li>
</ul>
</li>
</ul>
<a class="header" href="#see-my-pings" id="see-my-pings"><h1>See My Pings</h1></a>
<p>So you want to see what you're sending the telemetry pipeline, huh? Well follow these steps and we'll have you reading some JSON in no time.</p>
<p>For a more thorough introduction, see <a href="realtime_analysis_plugin.html">Creating a Real-Time Analysis Plugin Cookbook</a>.</p>
<a class="header" href="#steps-to-create-a-viewing-output" id="steps-to-create-a-viewing-output"><h2>Steps to Create a Viewing Output</h2></a>
<ol>
<li>
<p>Get your <code>clientId</code> from whatever product you're using. For desktop, it's available in <code>about:telemetry</code>.</p>
</li>
<li>
<p>Go to the CEP site: https://pipeline-cep.prod.mozaws.net/</p>
</li>
<li>
<p>Login/Register using your Google <code>@mozilla.com</code> account</p>
</li>
<li>
<p>Click on the &quot;Analysis Plugin Deployment&quot; tab</p>
</li>
<li>
<p>Under &quot;Heka Analysis Plugin Configuration&quot;, put the following config:</p>
</li>
</ol>
<pre><code>filename = '&lt;your_name&gt;_&lt;product&gt;_pings.lua'
message_matcher = 'Type == &quot;telemetry&quot; &amp;&amp; Fields[docType] == &quot;&lt;doctype&gt;&quot; &amp;&amp; Fields[clientId] == &quot;&lt;your_client_id&gt;&quot;'
preserve_data = false
ticker_interval = 60
</code></pre>
<p>Where <code>&lt;product&gt;</code> is whatever product you're testing, and <code>&lt;doctype&gt;</code> is whatever ping you're testing (e.g. <code>main</code>, <code>core</code>, <code>mobile-event</code>, etc.).</p>
<ol start="6">
<li>Under &quot;Heka Analysis Plugin&quot; put the following. This will, by default, show the most recent 10 pings that match your <code>clientId</code> on the specified <code>docType</code>.</li>
</ol>
<p>NOTE: If you are looking at <code>main</code>, <code>saved-session</code>, or <code>crash</code> pings, the submitted data is split out into several pieces. Reading just <code>Fields[submission]</code>
will not give you the entire submitted ping contents. You can change that to e.g. <code>Fields[environment.system]</code>, <code>Fields[payload.histograms]</code>, <code>Fields[payload.keyedHistograms]</code>.
To see all of the available fields, <a href="../tools/cep_matcher.html">look at a ping in the Matcher tab</a>.</p>
<pre><code>require &quot;string&quot;
require &quot;table&quot;

output = {}
max_len = 10
cur_ind = 1

function process_message()
    output[cur_ind] = read_message(&quot;Fields[submission]&quot;)
    cur_ind = cur_ind + 1
    if cur_ind &gt; max_len then
        cur_ind = 1
    end
    return 0
end

function timer_event(ns, shutdown)
    local res = table.concat(output, &quot;,&quot;)
    add_to_payload(&quot;[&quot; .. res .. &quot;]&quot;)
    inject_payload(&quot;json&quot;)
end
</code></pre>
<ol start="7">
<li>
<p>Click &quot;Run Matcher&quot;, then &quot;Test Plugin&quot;. Check that no errors appear in &quot;Debug Output&quot;</p>
</li>
<li>
<p>Click &quot;Deploy Plugin&quot;. Your output will be available at <code>https://pipeline-cep.prod.mozaws.net/dashboard_output/analysis.&lt;username&gt;_mozilla_com.&lt;your_name&gt;_&lt;product&gt;_pings..json</code></p>
</li>
</ol>
<a class="header" href="#cep-matcher" id="cep-matcher"><h1>CEP Matcher</h1></a>
<p>The CEP Matcher tab lets you easily view some current pings of any ping type. To access it, follow
<a href="../cookbooks/realtime_analysis_plugin.html">these first few directions</a> for accessing the CEP. Once there,
click on the &quot;Matcher&quot; tab. The message-matcher is set by default to <code>TRUE</code>, meaning all pings will
be matched. Click &quot;Run Matcher&quot; and a few pings will show up.</p>
<a class="header" href="#editing-the-message-matcher" id="editing-the-message-matcher"><h2>Editing the Message Matcher</h2></a>
<p>Changing the message matcher will filter down the accepted pings, letting you hone in on a certain type.
Generally, you can filter on any fields in a ping. For example, <code>docType</code>:</p>
<pre><code>Fields[docType] == &quot;main&quot;
</code></pre>
<p>Or OS:</p>
<pre><code>Fields[os] == &quot;Android&quot;
</code></pre>
<p>We can also combine matchers together:</p>
<pre><code>Fields[docType] == &quot;core&quot; &amp;&amp; Fields[os] == &quot;Android&quot; &amp;&amp; Fields[appName] == &quot;Focus&quot;
</code></pre>
<p>Note that most of the time, you want just proper telemetry pings, so include this in your matcher:</p>
<pre><code>Type == &quot;telemetry&quot;
</code></pre>
<p>Which would get us a sample of Focus Android core pings.</p>
<p>The <a href="https://hekad.readthedocs.io/en/v0.10.0/message_matcher.html">Message Matcher documentation</a> has
more information on the syntax.</p>
<p>To see the available fields that you can filter on for any <code>docType</code>, see <a href="https://pipeline-cep.prod.mozaws.net/dashboard_output/analysis.moz_telemetry_parquet_schema.parquet.txt">this document</a>.
For example, look under the <code>telemetry</code> top-level field at <code>system-addon-deployment-diagnostics</code>. The available fields to filter on are:</p>
<pre><code>required binary Logger;
required fixed_len_byte_array(16) Uuid;
optional int32 Pid;
optional int32 Severity;
optional binary EnvVersion;
required binary Hostname;
required int64 Timestamp;
optional binary Payload;
required binary Type;
required group Fields {
    required binary submission;
    required binary Date;
    required binary appUpdateChannel;
    required double sourceVersion;
    required binary documentId;
    required binary docType;
    required binary os;
    optional binary environment.addons;
    optional binary DNT;
    required binary environment.partner;
    required binary sourceName;
    required binary appVendor;
    required binary environment.profile;
    required binary environment.settings;
    required binary normalizedChannel;
    required double sampleId;
    required binary Host;
    required binary geoCountry;
    required binary geoCity;
    required boolean telemetryEnabled;
    required double creationTimestamp;
    required binary appVersion;
    required binary appBuildId;
    required binary environment.system;
    required binary environment.build;
    required binary clientId;
    required binary submissionDate;
    required binary appName;
}
</code></pre>
<p>So, for example, you could have a message matcher like:</p>
<pre><code>Type == &quot;telemetry&quot; &amp;&amp; Fields[geoCountry] == &quot;US&quot;
</code></pre>
<a class="header" href="#active-dau-and-active-mau" id="active-dau-and-active-mau"><h1>Active DAU and Active MAU</h1></a>
<p>An <strong>Active User</strong> is defined as a client who has <code>total_daily_uri</code> &gt;= 5 URI for a given date.</p>
<ul>
<li>Dates are defined by <code>submission_date_s3</code>.</li>
<li>A client's <code>total_daily_uri</code> is defined as their sum of <code>scalar_parent_browser_engagement_total_uri_count</code> for a given date<sup><a href="#total_uri_count">1</a></sup>.</li>
</ul>
<p><strong>Active DAU</strong> is the number of Active Users on a given day.</p>
<p><strong>Active MAU</strong> is the number of unique clients who have been an Active User on any day in the last <strong>28 days</strong>. In other words, any client that contributes to Active DAU in the last 28 days would also contribute to Active MAU for that day. Note that this is not simply the sum of Active DAU over 28 days, since any particular client could be active on many days.</p>
<p>For quick analysis, using <code>clients_daily_v6</code> is recommended. Below is an example query for getting Active DAU (aDAU) using <code>clients_daily_v6</code>.</p>
<pre><code class="language-sql">SELECT
    submission_date_s3,
    count(*) AS total_clients_cdv6
FROM
    clients_daily_v6
WHERE
    scalar_parent_browser_engagement_total_uri_count_sum &gt;= 5
GROUP BY
    1
ORDER BY
    1 ASC
</code></pre>
<p><code>main_summary</code> can also be used for getting aDAU. Below is an example query using a 1% sample over March 2018 using <code>main_summary</code>:</p>
<pre><code class="language-sql">SELECT
    submission_date_s3,
    count(DISTINCT client_id) * 100 as aDAU
FROM
    (SELECT
            submission_date_s3,
            client_id,
            sum(coalesce(scalar_parent_browser_engagement_total_uri_count, 0)) as total_daily_uri
        FROM
            main_summary
        WHERE
            sample_id = '51'
            AND submission_date_s3 &gt;= '20180301'
            AND submission_date_s3 &lt; '20180401'
        GROUP BY
            1, 2) as daily_clients_table
WHERE
    total_daily_uri &gt;= 5
GROUP BY
    1
ORDER BY
    1 ASC
</code></pre>
<p><a href="../datasets/batch_view/client_count_daily/reference.html"><code>client_count_daily</code></a> can be used to get <strong>approximate</strong> aDAU. This dataset uses HyperLogLog to estimate unique counts. For example:</p>
<pre><code class="language-sql">SELECT
    submission_date AS day,
    cardinality(merge(cast(hll AS HLL))) AS active_dau
FROM client_count_daily
WHERE
    total_uri_count_threshold &gt;= 5
    -- Limit to 7 days of history
    AND submission_date &gt;= date_format(CURRENT_DATE - INTERVAL '7' DAY, '%Y%m%d')
GROUP BY 1
ORDER BY 1
</code></pre>
<p><span id="total_uri_count"><strong>1</strong></span>: Note, the probe measuring <code>scalar_parent_browser_engagement_total_uri_count</code> only exists in clients with Firefox 50 and up. Clients on earlier versions of Firefox won't be counted as an Active User (regardless of their use). Similarly, <code>scalar_parent_browser_engagement_total_uri_count</code> doesn't increment when a client is in Private Browsing mode, so that won't be included as well.</p>
<p><em>Authored by the Product Data Science Team. Please direct questions/concerns to Ben Miroglio (<code>bmiroglio</code>).</em></p>
<a class="header" href="#retention-1" id="retention-1"><h1>Retention</h1></a>
<p>Retention measures the rate at which users are <em>continuing</em> to use Firefox, making it one of the more important metrics we track. We commonly measure retention between releases, experiment cohorts, and various Firefox subpopulations to better understand how a change to the user experience or use of a specific feature affect behavior.</p>
<a class="header" href="#n-week-retention" id="n-week-retention"><h2>N Week Retention</h2></a>
<p>Time is an embedded component of retention. Most retention analysis starts with some anchor, or action that is associated with a date (experiment enrollment date, profile creation date, button clicked on date <em>d</em>, etc.). We then look 1, 2, …, N weeks beyond the anchor to see what percent of users have submitted a ping (signaling their continued use of Firefox).</p>
<p>For example, let’s say we are calculating retention for new Firefox users. Each user can then be anchored by their <code>profile_creation_date</code>, and we can count the number of users who submitted a ping between 7-13 days after profile creation (1 Week retention), 14-20 days after profile creation (2 Week Retention), etc.</p>
<a class="header" href="#example-methodology" id="example-methodology"><h3>Example Methodology</h3></a>
<p>Given a dataset in Spark, we can construct a field <code>retention_period</code> that uses <code>submission_date_s3</code> to determine the period to which a ping belongs (i.e. if a user created their profile on April 1st, all pings submitted between April 8th and April 14th are assigned to week 1). 1-week retention can then be simplified to the percent of users with a 1 value for <code>retention_period</code>, 2-week retention simplifies to the percent of users with a 2 value for <code>retention_period</code>, ..., etc. Note that each retention period is independent of the others, so it is possible to have higher 2-week retention than 1-week retention (especially during holidays).</p>
<p>First let's map 1, 2, ..., N week retention the the amount of days elapsed after the anchor point:</p>
<pre><code class="language-python">PERIODS = {}
N_WEEKS = 6
for i in range(1, N_WEEKS + 1):
    PERIODS[i] = {
        'start': i * 7,
        'end': i * 7 + 6
    }  
</code></pre>
<p>Which gives us</p>
<pre><code class="language-python">{1: {'end': 13, 'start': 7},
 2: {'end': 20, 'start': 14},
 3: {'end': 27, 'start': 21},
 4: {'end': 34, 'start': 28},
 5: {'end': 41, 'start': 35},
 6: {'end': 48, 'start': 42}}

</code></pre>
<p>Next, let's define some helper functions:</p>
<pre><code class="language-python">import datetime as dt
import pandas as pd
import pyspark.sql.types as st
import pyspark.sql.functions as F

udf = F.udf

def date_diff(d1, d2, fmt='%Y%m%d'):
    &quot;&quot;&quot;
    Returns days elapsed from d2 to d1 as an integer
    
    Params:
    d1 (str)
    d2 (str)
    fmt (str): format of d1 and d2 (must be the same)
    
    &gt;&gt;&gt; date_diff('20170205', '20170201')
    4
    
    &gt;&gt;&gt; date_diff('20170201', '20170205)
    -4
    &quot;&quot;&quot;
    try:
        return (pd.to_datetime(d1, format=fmt) - 
                pd.to_datetime(d2, format=fmt)).days
    except:
        return None
    

@udf(returnType=st.IntegerType())
def get_period(anchor, submission_date_s3):
    &quot;&quot;&quot;
    Given an anchor and a submission_date_s3,
    returns what period a ping belongs to. This 
    is a spark UDF.
    
    Params:
    anchor (col): anchor date
    submission_date_s3 (col): a ping's submission_date to s3
    
    Global:
    PERIODS (dict): defined globally based on n-week method
    
    Returns an integer indicating the retention period
    &quot;&quot;&quot;
    if anchor is not None:
        diff = date_diff(submission_date_s3, anchor)
        if diff &gt;= 7: # exclude first 7 days
            for period in sorted(PERIODS):
                if diff &lt;= PERIODS[period]['end']:
                    return period

@udf(returnType=st.StringType())
def from_unixtime_handler(ut):
    &quot;&quot;&quot;
    Converts unix time (in days) to a string in %Y%m%d format.
    This is a spark UDF.
    
    Params:
    ut (int): unix time in days
    
    Returns a date as a string if it is parsable by datetime, otherwise None
    &quot;&quot;&quot;
    if ut is not None:
        try:
            return (dt.datetime.fromtimestamp(ut * 24 * 60 * 60).strftime(&quot;%Y%m%d&quot;))
        except:
            return None
        
</code></pre>
<p>Now we can load in a subset of <code>main_summary</code> and construct the necessary fields for retention calculations:</p>
<pre><code class="language-python">ms = spark.sql(&quot;&quot;&quot;
    SELECT 
        client_id, 
        submission_date_s3,
        profile_creation_date,
        os
    FROM main_summary 
    WHERE 
        submission_date_s3 &gt;= '20180401'
        AND submission_date_s3 &lt;= '20180603'
        AND sample_id = '42'
        AND app_name = 'Firefox'
        AND normalized_channel = 'release'
        AND os in ('Darwin', 'Windows_NT', 'Linux')
    &quot;&quot;&quot;)

PCD_CUTS = ('20180401', '20180415')

ms = (
    ms.withColumn(&quot;pcd&quot;, from_unixtime_handler(&quot;profile_creation_date&quot;)) # i.e. 17500 -&gt; '20171130'
      .filter(&quot;pcd &gt;= '{}'&quot;.format(PCD_CUTS[0]))
      .filter(&quot;pcd &lt;= '{}'&quot;.format(PCD_CUTS[1]))
      .withColumn(&quot;period&quot;, get_period(&quot;pcd&quot;, &quot;submission_date_s3&quot;))
)
</code></pre>
<p>Note that we filter to profiles that were created in the first half of April so that we have sufficient time to observe 6 weeks of behavior. Now we can calculate retention!</p>
<pre><code class="language-python">os_counts = (
    ms
    .groupby(&quot;os&quot;)
    .agg(F.countDistinct(&quot;client_id&quot;).alias(&quot;total_clients&quot;))
)

weekly_counts = (
    ms
    .groupby(&quot;period&quot;, &quot;os&quot;)
    .agg(F.countDistinct(&quot;client_id&quot;).alias(&quot;n_week_clients&quot;))
)

retention_by_os = (
    weekly_counts
    .join(os_counts, on='os')
    .withColumn(&quot;retention&quot;, F.col(&quot;n_clients&quot;) / F.col(&quot;total_count&quot;))
)
</code></pre>
<p>Peeking at 6-Week Retention</p>
<pre><code class="language-python">retention_by_os.filter(&quot;period = 6&quot;).show()
</code></pre>
<pre><code>+----------+------+--------------+-------------+-------------------+
|        os|period|n_week_clients|total_clients|          retention|
+----------+------+--------------+-------------+-------------------+
|     Linux|     6|          1495|        22422|0.06667558647756668|
|    Darwin|     6|          1288|         4734|0.27207435572454586|
|Windows_NT|     6|         29024|       124872|0.23243000832852842|
+----------+------+--------------+-------------+-------------------+


</code></pre>
<p>we observe that 6.7% of Linux users whose profile was created in the first half of April submitted a ping 6 weeks later, and so forth. The example code snippets are consolidated in <a href="https://gist.github.com/benmiroglio/fc708e5905fad33b43adb9c90e38ebf4">this notebook</a>.</p>
<a class="header" href="#new-vs-existing-user-retention" id="new-vs-existing-user-retention"><h3>New vs. Existing User Retention</h3></a>
<p>The above example calculates <strong>New User Retention</strong>, which is distinct from <strong>Existing User Retention</strong>. This distinction is important when understanding retention baselines (i.e. does this number make sense?). Existing users typically have much higher retention numbers than new users.</p>
<p>Note that is more common in industry to refer to Existing User Retention as &quot;Churn&quot; (Churn = 1 - Retention), however, we use retention across the board for the sake of consistency and interpretability.</p>
<p><strong>Please be sure to specify whether or not your retention analysis is for new or existing users.</strong></p>
<a class="header" href="#what-if-theres-no-anchor-point" id="what-if-theres-no-anchor-point"><h3>What If There's No Anchor Point?</h3></a>
<p>Sometimes there isn't a clear anchor point like <code>profile_creation_date</code> or <code>enrollment_date</code>.</p>
<p>For example, imagine you are tasked with reporting retention numbers for users that enabled sync (<code>sync_configured</code>) compared to users that haven't. Being a boolean pref, there is no straightforward way to determine <em>when</em> <code>sync_enabled</code> flipped from <code>false</code> to <code>true</code> aside from looking at a client's entire history (which is not recommended!). What now?</p>
<p>We can construct an artificial anchor point using fixed weekly periods; the retention concepts then remain unchanged. The process can be summarized by the following steps:</p>
<ul>
<li>Define a baseline week cohort
<ul>
<li>For this example let's define the baseline as users that submitted pings between 2018-01-01 and 2018-01-07</li>
</ul>
</li>
<li>Count all users with/without sync enabled in this period</li>
<li>Assign these users to an anchor point of 2018-01-01 (the <strong>beginning</strong> of the baseline week)</li>
<li>Count the number of users in the baseline week that submitted a ping between 7-13 days after 2018-01-01 (1 Week retention), 14-20 days after 2018-01-01 (2 Week Retention), etc.</li>
<li>Shift the baseline week up 7 days (and all other dates) and repeat as necessary</li>
</ul>
<p>This method is also valid in the presence of an anchor point, however, it is recommended the anchor point method is employed when possible.</p>
<a class="header" href="#confounding-factors" id="confounding-factors"><h3>Confounding Factors</h3></a>
<p>When performing retention analysis between two or more groups, it is important to look at other usage metrics to get an understanding of other influential factors.</p>
<p>For example (borrowing the sync example from the previous section) you find that users with and without sync have a 1 week retention of 0.80 and 0.40, respectively. Wow--we should really be be promoting sync as it could double retention numbers!</p>
<p><em>Not quite</em>. Turns out you next look at <code>active_ticks</code> and <code>total_uri_count</code> and find that sync users report much higher numbers for these measures as well. Now how can we explain this difference in retention?</p>
<p>There could be an entirely separate cookbook devoted to answering this question, however this contrived example is meant to demonstrate that simply comparing retention numbers between two groups isn't capturing the full story. Sans an experiment or model-based approach, all we can say is &quot;enabling sync is <strong>associated</strong> with higher retention numbers.&quot; There is still value in this assertion, however it should be stressed that <strong>association/correlation != causation!</strong></p>
<a class="header" href="#dataset-reference" id="dataset-reference"><h1>Dataset Reference</h1></a>
<p>After completing <a href="../concepts/choosing_a_dataset.html">Choosing a Dataset</a>
you should have a high level understanding of what questions each dataset is able to answer.
This section contains references that focus on a single dataset each.
Reading this section front to back is not recommended.
Instead, identify a dataset you'd like to understand better and read through
the relevant documentation.
After reading the tutorial, you should know all you need about the dataset.</p>
<p>Each tutorial should include:</p>
<ul>
<li>Introduction
<ul>
<li>A short overview of why we built the dataset and what need it's meant to solve</li>
<li>What data source the data is collected from,
and a high level overview of how the data is organized</li>
<li>How it is stored and how to access the data including
<ul>
<li>whether the data is available in re:dash</li>
<li>S3 paths</li>
</ul>
</li>
</ul>
</li>
<li>Reference
<ul>
<li>An example query to give the reader an idea of what the data looks like
and how it is meant to be used</li>
<li>How the data is processed and sampled</li>
<li>How frequently it's updated, and how it's scheduled</li>
<li>An up-to-date schema for the dataset</li>
<li>How to augment or modify the dataset</li>
</ul>
</li>
</ul>
<a class="header" href="#raw-ping-data" id="raw-ping-data"><h1>Raw Ping Data</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a></li>
</ul>
<a class="header" href="#introduction-3" id="introduction-3"><h1>Introduction</h1></a>
<p>We receive data from our users via <strong>pings</strong>.
There are several types of pings,
each containing different measurements and sent for different purposes.
To review a complete list of ping types and their schemata, see
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/index.html">this section of the Mozilla Source Tree Docs</a>.</p>
<p>Many pings are also described by a JSONSchema specification which can be found in <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/tree/master/schemas/telemetry">this repository</a>.</p>
<a class="header" href="#background-and-caveats-8" id="background-and-caveats-8"><h4>Background and Caveats</h4></a>
<p>The large majority of analyses can be completed using only the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">main ping</a>.
This ping includes histograms, scalars, events, and other performance and diagnostic data.</p>
<p>Few analyses actually rely directly on the raw ping data.
Instead, we provide <strong>derived datasets</strong> which are processed versions of these data,
made to be:</p>
<ul>
<li>Easier and faster to query</li>
<li>Organized to make the data easier to analyze</li>
<li>Cleaned of erroneous or misleading data</li>
</ul>
<p>Before analyzing raw ping data,
<strong>check to make sure there isn't already a derived dataset</strong> made for your purpose.
If you do need to work with raw ping data, be aware that loading the data can take a while.
Try to limit the size of your data by controlling the date range, etc.</p>
<a class="header" href="#accessing-the-data-14" id="accessing-the-data-14"><h4>Accessing the Data</h4></a>
<p>You can access raw ping data from an <a href="https://analysis.telemetry.mozilla.org/">ATMO cluster</a> using the <a href="https://python-moztelemetry.readthedocs.io/en/stable/api.html#module-moztelemetry.dataset">Dataset API</a>.
Raw ping data are not available in <a href="https://sql.telemetry.mozilla.org/">re:dash</a>.</p>
<a class="header" href="#further-reading-8" id="further-reading-8"><h4>Further Reading</h4></a>
<p>You can find <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/index.html">the complete ping documentation</a>.
To augment our data collection, see <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Adding_a_new_Telemetry_probe">Collecting New Data</a> and the
<a href="https://wiki.mozilla.org/Firefox/Data_Collection">Data Collection Policy</a>.</p>
<a class="header" href="#data-reference" id="data-reference"><h1>Data Reference</h1></a>
<p>You can find the reference documentation for all ping types
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/concepts/pings.html">here</a>.</p>
<a class="header" href="#derived-datasets" id="derived-datasets"><h1>Derived Datasets</h1></a>
<p>See <a href="../concepts/choosing_a_dataset.html">Choosing a Dataset</a>
for a discussion on the differences between pings and derived datasets.</p>
<a class="header" href="#addons-datasets" id="addons-datasets"><h1>Addons Datasets</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#sampling">Sampling</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-4" id="introduction-4"><h1>Introduction</h1></a>
<p>This is a work in progress.
The work is being tracked
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364172">here</a>.</p>
<a class="header" href="#data-reference-1" id="data-reference-1"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-1" id="example-queries-1"><h2>Example Queries</h2></a>
<a class="header" href="#sampling-1" id="sampling-1"><h2>Sampling</h2></a>
<p>It contains one or more records for every
<a href="../main_summary/reference.html">Main Summary</a>
record that contains a non-null value for <code>client_id</code>.
Each Addons record contains info for a single addon,
or if the main ping did not contain any active addons,
there will be a row with nulls for all the addon fields
(to identify <code>client_id</code>s/records without any addons).</p>
<p>Like the Main Summary dataset, No attempt is made to de-duplicate submissions by <code>documentId</code>, so any analysis that could be affected by duplicate records should take care to remove duplicates using the <code>documentId</code> field.</p>
<a class="header" href="#scheduling" id="scheduling"><h2>Scheduling</h2></a>
<p>This dataset is updated daily via the
<a href="https://github.com/mozilla/telemetry-airflow">telemetry-airflow</a> infrastructure.
The job DAG runs every day after the Main Summary data has been generated.
The DAG is <a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/main_summary.py#L36">here</a>.</p>
<a class="header" href="#schema" id="schema"><h2>Schema</h2></a>
<p>As of 2017-03-16, the current version of the <code>addons</code> dataset is <code>v2</code>,
and has a schema as follows:</p>
<pre><code>root
 |-- document_id: string (nullable = true)
 |-- client_id: string (nullable = true)
 |-- subsession_start_date: string (nullable = true)
 |-- normalized_channel: string (nullable = true)
 |-- addon_id: string (nullable = true)
 |-- blocklisted: boolean (nullable = true)
 |-- name: string (nullable = true)
 |-- user_disabled: boolean (nullable = true)
 |-- app_disabled: boolean (nullable = true)
 |-- version: string (nullable = true)
 |-- scope: integer (nullable = true)
 |-- type: string (nullable = true)
 |-- foreign_install: boolean (nullable = true)
 |-- has_binary_components: boolean (nullable = true)
 |-- install_day: integer (nullable = true)
 |-- update_day: integer (nullable = true)
 |-- signed_state: integer (nullable = true)
 |-- is_system: boolean (nullable = true)
 |-- submission_date_s3: string (nullable = true)
 |-- sample_id: string (nullable = true)
</code></pre>
<p>For more detail on where these fields come from in the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/environment.html#addons">raw data</a>,
please look
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/AddonsView.scala">in the <code>AddonsView</code> code</a>.</p>
<p>The fields are all simple scalar values.</p>
<a class="header" href="#churn-1" id="churn-1"><h1>Churn</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-5" id="introduction-5"><h1>Introduction</h1></a>
<p>The churn dataset tracks the 7-day churn rate of telemetry profiles. This
dataset is generally used for analyzing cohort churn across segments and time.</p>
<a class="header" href="#content-2" id="content-2"><h4>Content</h4></a>
<p>Churn is the rate of attrition defined by <code>(clients seen in week N)/(clients seen in week 0)</code>
for groups of clients with some shared attributes. A group of clients with
shared attributes is called a <em>cohort</em>. The cohorts in this dataset are created
every week and can be tracked over time using the <code>acquisition_date</code> and the
weeks since acquisition or <code>current_week</code>.</p>
<p>The following example demonstrates the current logic for generating this
dataset. Each column represents the days since some arbitrary starting date.</p>
<table><thead><tr><th>   client </th><th> 00 </th><th> 01 </th><th> 02 </th><th> 03 </th><th> 04 </th><th> 05 </th><th> 06 </th><th> 07 </th><th> 08 </th><th> 09 </th><th> 10 </th><th> 11 </th><th> 12 </th><th> 13 </th><th> 14 </th></tr></thead><tbody>
<tr><td> A        </td><td> X  </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td> X  </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td></tr>
<tr><td> B        </td><td>    </td><td> X  </td><td> X  </td><td> X  </td><td> X  </td><td> X  </td><td> X  </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td></tr>
<tr><td> C        </td><td> X  </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td>    </td><td> X  </td></tr>
</tbody></table>
<p>All three clients are part of the same cohort. Client A is retained for weeks 0
and 1 since there is activity in both periods. A client only needs to show up
once in the period to be counted as retained. Client B is acquired in week 0 and
is active frequently but does not appear in following weeks. Client B is
considered churned on week 1. However, a client that is churned can become
retained again. Client C is considered churned on week 1 but retained on week 3.</p>
<p>The following table summarizes the above daily activity into the following view
where every column represents the current week since acquisition date..</p>
<table><thead><tr><th>   client </th><th> 0 </th><th> 1 </th><th>  2 </th></tr></thead><tbody>
<tr><td> A        </td><td> X </td><td> X </td><td>    </td></tr>
<tr><td> B        </td><td> X </td><td>   </td><td>    </td></tr>
<tr><td> C        </td><td> X </td><td>   </td><td> X  </td></tr>
</tbody></table>
<p>The clients are then grouped into cohorts by attributes. An attribute describes
a property about the cohort such as the country of origin or the binary
distribution channel. Each group also contains descriptive aggregates of
engagement. Each metric describes the activity of a cohort such as size and
overall usage at a given time instance.</p>
<a class="header" href="#background-and-caveats-9" id="background-and-caveats-9"><h4>Background and Caveats</h4></a>
<ul>
<li>Each row in this dataset describes a unique segment of users
<ul>
<li>The number of rows is exponential with the number of dimensions</li>
<li>New fields should be added sparing to account for data-set size</li>
</ul>
</li>
<li>The dataset lags by 10 days in order account for submission latency
<ul>
<li>This value was determined to be time for 99% of main pings to arrive at the
server. With the shutdown-ping sender, this has been reduced to 4 days.
However, <code>churn_v3</code> still tracks releases older than Firefox 55.</li>
</ul>
</li>
<li>The start of the period is fixed to Sundays. Once it has been aggregated, the
period cannot be shifted due to the way clients are counted.
<ul>
<li>A supplementary 1-day <code>retention</code> dataset using HyperLogLog for client
counts is available for counting over arbitrary retention periods and date
offsets. Additionally, calculating churn or retention over specific cohorts
is tractable in STMO with <code>main_summary</code> or <code>clients_daily</code> datasets.</li>
</ul>
</li>
</ul>
<a class="header" href="#accessing-the-data-15" id="accessing-the-data-15"><h4>Accessing the Data</h4></a>
<p><code>churn</code> is available in Re:dash under Athena and Presto. The data is also
available in parquet for consumption by columnar data engines at
<code>s3://telemetry-parquet/churn/v3</code>.</p>
<a class="header" href="#data-reference-2" id="data-reference-2"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-2" id="example-queries-2"><h2>Example Queries</h2></a>
<p>This section walks through a typical query to generate data suitable for
visualization.</p>
<table><thead><tr><th> field </th><th> type </th><th> description </th></tr></thead><tbody>
<tr><td> <code>cohort_date</code> </td><td> common, attribute </td><td>  The start date bucket of the cohort. This is week the client was acquired.</td></tr>
<tr><td> <code>elapsed_periods</code> </td><td> common, attribute </td><td> The number of periods that have elapsed since the cohort date. In this dataset, the retention period is 7 days.</td></tr>
<tr><td> <code>channel</code> </td><td> attribute </td><td> Part of the release train model. An attribute that distinguishes cohorts.</td></tr>
<tr><td> <code>geo</code> </td><td> filter attribute </td><td> Country code. Used to filter out all countries other than the 'US'</td></tr>
<tr><td> <code>n_profiles</code> </td><td> metric </td><td> Count of users in a cohort. Use sum to aggregate.</td></tr>
</tbody></table>
<p>First the fields are extracted and aliased for consistency. <code>cohort_date</code> and
<code>elapsed_periods</code> are common to most retention queries and are useful concepts
for building on other datasets.</p>
<pre><code class="language-sql">WITH extracted AS (
    SELECT acquisition_period AS cohort_date,
           current_week AS elapsed_periods,
           n_profiles,
           channel,
           geo
    FROM churn
),
</code></pre>
<p>The extracted table is filtered down to the attributes of interest. The cohorts
of interest originate in the US and are in the release or beta channels. Note
that <code>channel</code> here is the concatenation of the normalized channel and the
funnelcake id. Only cohorts appearing after August 6, 2017 are chosen to be in
this population.</p>
<pre><code class="language-sql"> population AS (
    SELECT channel,
           cohort_date,
           elapsed_periods,
           n_profiles
    FROM extracted
    WHERE geo = 'US'
      AND channel IN ('release', 'beta')
      AND cohort_date &gt; '20170806'
      -- filter out noise from clients with incorrect dates
      AND elapsed_periods &gt;= 0
      AND elapsed_periods &lt; 12
),
</code></pre>
<p>The number of profiles is aggregated by the cohort dimensions. The cohort
acquisition date and elapsed periods since acquisition are fundamental to cohort
analysis.</p>
<pre><code class="language-sql"> cohorts AS (
     SELECT channel,
            cohort_date,
            elapsed_periods,
            sum(n_profiles) AS n_profiles
     FROM population
     GROUP BY 1, 2, 3
),
</code></pre>
<p>The table will have the following structure. The table is sorted by the first three columns for demonstration.</p>
<table><thead><tr><th> <code>channel</code> </th><th> <code>cohort_date</code> </th><th> <code>elapsed_periods</code> </th><th> <code>n_profiles</code> </th></tr></thead><tbody>
<tr><td> release </td><td> 20170101 </td><td> 0 </td><td> 100 </td></tr>
<tr><td> release </td><td> 20170101 </td><td> 1 </td><td> 90 </td></tr>
<tr><td> release </td><td> 20170101 </td><td> 2 </td><td> 80 </td></tr>
<tr><td> ... </td><td> ... </td><td> ... </td><td> ... </td></tr>
<tr><td> beta </td><td> 20170128 </td><td> 10 </td><td> 25 </td></tr>
</tbody></table>
<p>Finally, retention is calculated through the number of profiles at the time of
the <code>elapsed_period</code> relative to the initial period. This data can be imported
into a pivot table for further analysis.</p>
<pre><code class="language-sql">results AS (
    SELECT c.*,
           iv.n_profiles AS total_n_profiles,
           (0.0+c.n_profiles)*100/iv.n_profiles AS percentage_n_profiles
    FROM cohorts c
    JOIN (
        SELECT *
        FROM cohorts
        WHERE elapsed_periods = 0
    ) iv ON (
        c.cohort_date = iv.cohort_date
        AND c.channel = iv.channel
    )
)
</code></pre>
<table><thead><tr><th> <code>channel</code> </th><th> <code>cohort_date</code> </th><th> <code>elapsed_periods</code> </th><th> <code>n_profiles</code> </th><th> <code>total_n_profiles</code> </th><th> <code>percentage_n_profiles</code> </th></tr></thead><tbody>
<tr><td> release   </td><td> 20170101      </td><td> 0                 </td><td> 100          </td><td> 100                </td><td> 1.0                     </td></tr>
<tr><td> release   </td><td> 20170101      </td><td> 1                 </td><td> 90           </td><td> 100                </td><td> 0.9                     </td></tr>
<tr><td> release   </td><td> 20170101      </td><td> 2                 </td><td> 80           </td><td> 100                </td><td> 0.8                     </td></tr>
<tr><td> ...       </td><td> ....          </td><td> ...               </td><td> ...          </td><td> ...                </td><td> ...                     </td></tr>
<tr><td> beta      </td><td> 20170128      </td><td> 10                </td><td> 25           </td><td> 50                 </td><td> 0.5                     </td></tr>
</tbody></table>
<p>Obtain the results.</p>
<pre><code class="language-SQL">SELECT *
FROM results
</code></pre>
<p>You may consider visualizing using cohort graphs, line charts, or a pivot
tables. See <a href="https://sql.telemetry.mozilla.org/dashboard/firefox-telemetry-retention-dataset-example-usage">Firefox Telemetry Retention: Dataset Example Usage</a>
for more examples.</p>
<a class="header" href="#scheduling-1" id="scheduling-1"><h2>Scheduling</h2></a>
<p>The aggregated churn data is updated weekly on Wednesday.</p>
<a class="header" href="#schema-1" id="schema-1"><h2>Schema</h2></a>
<p>As of 2017-10-15, the current version of <code>churn</code> is <code>v3</code> and has a schema as follows:</p>
<pre><code>root
 |-- channel: string (nullable = true)
 |-- geo: string (nullable = true)
 |-- is_funnelcake: string (nullable = true)
 |-- acquisition_period: string (nullable = true)
 |-- start_version: string (nullable = true)
 |-- sync_usage: string (nullable = true)
 |-- current_version: string (nullable = true)
 |-- current_week: long (nullable = true)
 |-- source: string (nullable = true)
 |-- medium: string (nullable = true)
 |-- campaign: string (nullable = true)
 |-- content: string (nullable = true)
 |-- distribution_id: string (nullable = true)
 |-- default_search_engine: string (nullable = true)
 |-- locale: string (nullable = true)
 |-- is_active: string (nullable = true)
 |-- n_profiles: long (nullable = true)
 |-- usage_hours: double (nullable = true)
 |-- sum_squared_usage_hours: double (nullable = true)
 |-- total_uri_count: long (nullable = true)
 |-- unique_domains_count_per_profile: double (nullable = true)
</code></pre>
<a class="header" href="#code-reference" id="code-reference"><h2>Code Reference</h2></a>
<p>The script for generating <code>churn</code> currently lives in
<a href="https://github.com/mozilla/python_mozetl"><code>mozilla/python_mozetl</code></a>. The job can
be found in
<a href="https://github.com/mozilla/python_mozetl/blob/master/mozetl/engagement/churn/job.py"><code>mozetl/engagement/churn</code></a>.</p>
<a class="header" href="#client-count-daily-reference" id="client-count-daily-reference"><h1>Client Count Daily Reference</h1></a>
<p>This document is a work in progress.
The work is being tracked
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364175">here</a>.</p>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#caveats">Caveats</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-6" id="introduction-6"><h1>Introduction</h1></a>
<p>The <code>client_count_daily</code> dataset is useful for estimating user counts over a few
<a href="https://github.com/mozilla/telemetry-airflow/blob/master/jobs/client_count_daily_view.sh">pre-defined dimensions</a>.</p>
<p>The <code>client_count_daily</code> dataset is similar to the deprecated
<a href="../client_count/reference.html"><code>client_count</code> dataset</a>
except that is aggregated by submission date and not activity date.</p>
<a class="header" href="#content-3" id="content-3"><h4>Content</h4></a>
<p>This dataset includes columns for a dozen factors and an HLL variable.
The <code>hll</code> column contains a
<a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>
variable, which is an approximation to the exact count.
The factor columns include <strong>submission</strong> date and the dimensions listed
<a href="https://github.com/mozilla/telemetry-airflow/blob/master/jobs/client_count_daily_view.sh">here</a>.
Each row represents one combinations of the factor columns.</p>
<a class="header" href="#background-and-caveats-10" id="background-and-caveats-10"><h4>Background and Caveats</h4></a>
<p>It's important to understand that the <code>hll</code> column is <strong>not a standard count</strong>.
The <code>hll</code> variable avoids double-counting users when aggregating over multiple days.
The HyperLogLog variable is a far more efficient way to count distinct elements of a set,
but comes with some complexity.
To find the cardinality of an HLL use <code>cardinality(cast(hll AS HLL))</code>.
To find the union of two HLL's over different dates, use <code>merge(cast(hll AS HLL))</code>.
The <a href="https://sql.telemetry.mozilla.org/queries/81/source#129">Firefox ER Reporting Query</a>
is a good example to review.
Finally, Roberto has a relevant write-up
<a href="https://robertovitillo.com/2016/04/12/measuring-product-engagment-at-scale/">here</a>.</p>
<a class="header" href="#accessing-the-data-16" id="accessing-the-data-16"><h4>Accessing the Data</h4></a>
<p>The data is available in Re:dash.
Take a look at this
<a href="https://sql.telemetry.mozilla.org/queries/81/source#129">example query</a>.</p>
<p>I don't recommend accessing this data from ATMO.</p>
<a class="header" href="#further-reading-9" id="further-reading-9"><h4>Further Reading</h4></a>
<a class="header" href="#data-reference-3" id="data-reference-3"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-3" id="example-queries-3"><h2>Example Queries</h2></a>
<a class="header" href="#compute-dau-for-non-windows-clients-for-the-last-week" id="compute-dau-for-non-windows-clients-for-the-last-week"><h4>Compute DAU for non-windows clients for the last week</h4></a>
<pre><code class="language-sql">WITH sample AS (
  SELECT
    os,
    submission_date,
    cardinality(merge(cast(hll AS HLL))) AS count
  FROM client_count_daily
  WHERE submission_date &gt;= DATE_FORMAT(CURRENT_DATE - INTERVAL '7' DAY, '%Y%m%d')
  GROUP BY
    submission_date,
    os
)

SELECT
  os,
  -- formatting date as late as possible improves performance dramatically
  date_parse(submission_date, '%Y%m%d') AS submission_date,
  count
FROM sample
WHERE
  count &gt; 10 -- remove outliers
  AND lower(os) NOT LIKE '%windows%'
ORDER BY
  os,
  submission_date DESC
</code></pre>
<a class="header" href="#compute-wau-by-channel-for-the-last-week" id="compute-wau-by-channel-for-the-last-week"><h4>Compute WAU by Channel for the last week</h4></a>
<pre><code class="language-sql">WITH dau AS (
  SELECT
    normalized_channel,
    submission_date,
    merge(cast(hll AS HLL)) AS hll
  FROM client_count_daily
  -- 2 days of lag, 7 days of results, and 6 days preceding for WAU
  WHERE submission_date &gt; DATE_FORMAT(CURRENT_DATE - INTERVAL '15' DAY, '%Y%m%d')
  GROUP BY
    submission_date,
    normalized_channel
),
wau AS (
  SELECT
    normalized_channel,
    submission_date,
    cardinality(merge(hll) OVER (
      PARTITION BY normalized_channel
      ORDER BY submission_date
      ROWS BETWEEN 6 PRECEDING AND 0 FOLLOWING
    )) AS count
  FROM dau
)

SELECT
  normalized_channel,
  -- formatting date as late as possible improves performance dramatically
  date_parse(submission_date, '%Y%m%d') AS submission_date,
  count
FROM wau
WHERE
  count &gt; 10 -- remove outliers
  AND submission_date &gt; DATE_FORMAT(CURRENT_DATE - INTERVAL '9' DAY, '%Y%m%d') -- only days that have a full WAU
</code></pre>
<a class="header" href="#caveats" id="caveats"><h2>Caveats</h2></a>
<p>The <code>hll</code> column does not product an exact count. <code>hll</code> stands for
<a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a>, a sophisticated
algorithm that allows for the counting of extremely high numbers of items,
sacrificing a small amount of accuracy in exchange for using much less memory
than a simple counting structure.</p>
<p>When count is calculated over a column that may change over time, such as
<code>total_uri_count_threshold</code>, then a client would be counted in every group
where they appear. Over longer windows, like MAU, this is more likely to occur.</p>
<a class="header" href="#scheduling-2" id="scheduling-2"><h2>Scheduling</h2></a>
<p>This dataset is updated daily via the
<a href="https://github.com/mozilla/telemetry-airflow">telemetry-airflow</a> infrastructure.
The job runs as part of the <a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/main_summary.py"><code>main_summary</code> DAG</a>.</p>
<a class="header" href="#schema-2" id="schema-2"><h2>Schema</h2></a>
<p>The data is partitioned by <code>submission_date</code> which is formatted as <code>%Y%m%d</code>,
like <code>20180130</code>.</p>
<p>As of 2018-03-15, the current version of the <code>client_count_daily</code> dataset
is <code>v2</code>, and has a schema as follows:</p>
<pre><code>root
 |-- app_name: string (nullable = true)
 |-- app_version: string (nullable = true)
 |-- country: string (nullable = true)
 |-- devtools_toolbox_opened: boolean (nullable = true)
 |-- e10s_enabled: boolean (nullable = true)
 |-- hll: binary (nullable = true)
 |-- locale: string (nullable = true)
 |-- normalized_channel: string (nullable = true)
 |-- os: string (nullable = true)
 |-- os_version: string (nullable = true)
 |-- top_distribution_id: string (nullable = true)
 |-- total_uri_count_threshold: integer (nullable = true)
</code></pre>
<p>The <code>client_count</code> dataset is deprecated in favor of
<a href="../client_count_daily/reference.html"><code>client_count_daily</code></a>,
which is aggregated by submission date instead of activity date.</p>
<a class="header" href="#clients-daily" id="clients-daily"><h1>Clients Daily</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
<a class="header" href="#introduction-7" id="introduction-7"><h1>Introduction</h1></a>
<p>The <code>clients_daily</code> table is intended as the first stop for asking questions
about how people use Firefox. It should be easy to answer simple questions.
Each row in the table is a (<code>client_id</code>, <code>submission_date</code>) and contains a
number of aggregates about that day's activity.</p>
<a class="header" href="#contents-10" id="contents-10"><h4>Contents</h4></a>
<p>Many questions about Firefox take the form &quot;What did clients with
characteristics X, Y, and Z do during the period S to E?&quot; The
<code>clients_daily</code> table is aimed at answer those questions.</p>
<a class="header" href="#accessing-the-data-17" id="accessing-the-data-17"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.</p>
<pre><code>s3://telemetry-parquet/clients_daily/v6/
</code></pre>
<p>The <code>clients_daily</code> table is accessible through re:dash using the <code>Athena</code>
data source. It is also available via the <code>Presto</code> data source, though
<code>Athena</code> should be preferred for performance and stability reasons.</p>
<p>Here's an <a href="https://sql.telemetry.mozilla.org/queries/23746#61771">example query</a>.</p>
<a class="header" href="#data-reference-4" id="data-reference-4"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-4" id="example-queries-4"><h2>Example Queries</h2></a>
<a class="header" href="#compute-churn-for-a-one-day-cohort" id="compute-churn-for-a-one-day-cohort"><h4>Compute Churn for a one-day cohort:</h4></a>
<pre><code class="language-sql">SELECT
  date_parse(submission_date_s3, '%Y%m%d') AS submission_date_s3,
  approx_distinct(client_id) AS cohort_dau
FROM clients_daily
WHERE
  submission_date_s3 &gt; '20170831'
  AND submission_date_s3 &lt; '20171001'
  AND profile_creation_date LIKE '2017-09-01%'
GROUP BY 1
ORDER BY 1
</code></pre>
<a class="header" href="#distribution-of-pings-per-client-per-day" id="distribution-of-pings-per-client-per-day"><h4>Distribution of pings per client per day:</h4></a>
<pre><code class="language-sql">SELECT
  normalized_channel,
  CASE
    WHEN pings_aggregated_by_this_row &gt; 50 THEN 50
    ELSE pings_aggregated_by_this_row
  END AS pings_per_day,
  approx_distinct(client_id) AS client_count
FROM clients_daily
WHERE
  submission_date_s3 = '20170901'
  AND normalized_channel &lt;&gt; 'Other'
GROUP BY
  1,
  2
ORDER BY
  2,
  1
</code></pre>
<a class="header" href="#scheduling-3" id="scheduling-3"><h2>Scheduling</h2></a>
<p>This dataset is updated daily via the
<a href="https://github.com/mozilla/telemetry-airflow">telemetry-airflow</a> infrastructure.
The job runs as part of the <a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/main_summary.py#L160"><code>main_summary</code> DAG</a>.</p>
<a class="header" href="#schema-3" id="schema-3"><h2>Schema</h2></a>
<p>The data is partitioned by <code>submission_date_s3</code> which is formatted as <code>%Y%m%d</code>,
like <code>20180130</code>.</p>
<p>As of 2018-05-16, the current version of the <code>clients_daily</code> dataset is <code>v6</code>, and has a schema as follows:</p>
<pre><code>root
 |-- client_id: string (nullable = true)
 |-- aborts_content_sum: long (nullable = true)
 |-- aborts_gmplugin_sum: long (nullable = true)
 |-- aborts_plugin_sum: long (nullable = true)
 |-- active_addons_count_mean: double (nullable = true)
 |-- active_experiment_branch: string (nullable = true)
 |-- active_experiment_id: string (nullable = true)
 |-- active_hours_sum: double (nullable = true)
 |-- addon_compatibility_check_enabled: boolean (nullable = true)
 |-- app_build_id: string (nullable = true)
 |-- app_display_version: string (nullable = true)
 |-- app_name: string (nullable = true)
 |-- app_version: string (nullable = true)
 |-- blocklist_enabled: boolean (nullable = true)
 |-- channel: string (nullable = true)
 |-- city: string (nullable = true)
 |-- client_clock_skew_mean: double (nullable = true)
 |-- client_submission_latency_mean: double (nullable = true)
 |-- country: string (nullable = true)
 |-- cpu_cores: integer (nullable = true)
 |-- cpu_count: integer (nullable = true)
 |-- cpu_family: integer (nullable = true)
 |-- cpu_l2_cache_kb: integer (nullable = true)
 |-- cpu_l3_cache_kb: integer (nullable = true)
 |-- cpu_model: integer (nullable = true)
 |-- cpu_speed_mhz: integer (nullable = true)
 |-- cpu_stepping: integer (nullable = true)
 |-- cpu_vendor: string (nullable = true)
 |-- crashes_detected_content_sum: long (nullable = true)
 |-- crashes_detected_gmplugin_sum: long (nullable = true)
 |-- crashes_detected_plugin_sum: long (nullable = true)
 |-- crash_submit_attempt_content_sum: long (nullable = true)
 |-- crash_submit_attempt_main_sum: long (nullable = true)
 |-- crash_submit_attempt_plugin_sum: long (nullable = true)
 |-- crash_submit_success_content_sum: long (nullable = true)
 |-- crash_submit_success_main_sum: long (nullable = true)
 |-- crash_submit_success_plugin_sum: long (nullable = true)
 |-- default_search_engine: string (nullable = true)
 |-- default_search_engine_data_load_path: string (nullable = true)
 |-- default_search_engine_data_name: string (nullable = true)
 |-- default_search_engine_data_origin: string (nullable = true)
 |-- default_search_engine_data_submission_url: string (nullable = true)
 |-- devtools_toolbox_opened_count_sum: long (nullable = true)
 |-- distribution_id: string (nullable = true)
 |-- e10s_enabled: boolean (nullable = true)
 |-- env_build_arch: string (nullable = true)
 |-- env_build_id: string (nullable = true)
 |-- env_build_version: string (nullable = true)
 |-- experiments: map (nullable = true)
 |    |-- key: string
 |    |-- value: string (valueContainsNull = true)
 |-- first_paint_mean: double (nullable = true)
 |-- flash_version: string (nullable = true)
 |-- geo_subdivision1: string (nullable = true)
 |-- geo_subdivision2: string (nullable = true)
 |-- gfx_features_advanced_layers_status: string (nullable = true)
 |-- gfx_features_d2d_status: string (nullable = true)
 |-- gfx_features_d3d11_status: string (nullable = true)
 |-- gfx_features_gpu_process_status: string (nullable = true)
 |-- install_year: long (nullable = true)
 |-- is_default_browser: boolean (nullable = true)
 |-- is_wow64: boolean (nullable = true)
 |-- locale: string (nullable = true)
 |-- memory_mb: integer (nullable = true)
 |-- normalized_channel: string (nullable = true)
 |-- normalized_os_version: string (nullable = true)
 |-- os: string (nullable = true)
 |-- os_service_pack_major: long (nullable = true)
 |-- os_service_pack_minor: long (nullable = true)
 |-- os_version: string (nullable = true)
 |-- pings_aggregated_by_this_row: long (nullable = true)
 |-- places_bookmarks_count_mean: double (nullable = true)
 |-- places_pages_count_mean: double (nullable = true)
 |-- plugin_hangs_sum: long (nullable = true)
 |-- plugins_infobar_allow_sum: long (nullable = true)
 |-- plugins_infobar_block_sum: long (nullable = true)
 |-- plugins_infobar_shown_sum: long (nullable = true)
 |-- plugins_notification_shown_sum: long (nullable = true)
 |-- previous_build_id: string (nullable = true)
 |-- profile_age_in_days: integer (nullable = true)
 |-- profile_creation_date: string (nullable = true)
 |-- push_api_notify_sum: long (nullable = true)
 |-- sample_id: string (nullable = true)
 |-- sandbox_effective_content_process_level: integer (nullable = true)
 |-- scalar_combined_webrtc_nicer_stun_retransmits_sum: long (nullable = true)
 |-- scalar_combined_webrtc_nicer_turn_401s_sum: long (nullable = true)
 |-- scalar_combined_webrtc_nicer_turn_403s_sum: long (nullable = true)
 |-- scalar_combined_webrtc_nicer_turn_438s_sum: long (nullable = true)
 |-- scalar_content_navigator_storage_estimate_count_sum: long (nullable = true)
 |-- scalar_content_navigator_storage_persist_count_sum: long (nullable = true)
 |-- scalar_parent_aushelper_websense_reg_version: string (nullable = true)
 |-- scalar_parent_browser_engagement_max_concurrent_tab_count_max: integer (nullable = true)
 |-- scalar_parent_browser_engagement_max_concurrent_window_count_max: integer (nullable = true)
 |-- scalar_parent_browser_engagement_tab_open_event_count_sum: long (nullable = true)
 |-- scalar_parent_browser_engagement_total_uri_count_sum: long (nullable = true)
 |-- scalar_parent_browser_engagement_unfiltered_uri_count_sum: long (nullable = true)
 |-- scalar_parent_browser_engagement_unique_domains_count_max: integer (nullable = true)
 |-- scalar_parent_browser_engagement_unique_domains_count_mean: double (nullable = true)
 |-- scalar_parent_browser_engagement_window_open_event_count_sum: long (nullable = true)
 |-- scalar_parent_devtools_copy_full_css_selector_opened_sum: long (nullable = true)
 |-- scalar_parent_devtools_copy_unique_css_selector_opened_sum: long (nullable = true)
 |-- scalar_parent_devtools_toolbar_eyedropper_opened_sum: long (nullable = true)
 |-- scalar_parent_dom_contentprocess_troubled_due_to_memory_sum: long (nullable = true)
 |-- scalar_parent_navigator_storage_estimate_count_sum: long (nullable = true)
 |-- scalar_parent_navigator_storage_persist_count_sum: long (nullable = true)
 |-- scalar_parent_storage_sync_api_usage_extensions_using_sum: long (nullable = true)
 |-- search_cohort: string (nullable = true)
 |-- search_count_all: long (nullable = true)
 |-- search_count_abouthome: long (nullable = true)
 |-- search_count_contextmenu: long (nullable = true)
 |-- search_count_newtab: long (nullable = true)
 |-- search_count_searchbar: long (nullable = true)
 |-- search_count_system: long (nullable = true)
 |-- search_count_urlbar: long (nullable = true)
 |-- session_restored_mean: double (nullable = true)
 |-- sessions_started_on_this_day: long (nullable = true)
 |-- shutdown_kill_sum: long (nullable = true)
 |-- subsession_hours_sum: decimal(37,6) (nullable = true)
 |-- ssl_handshake_result_failure_sum: long (nullable = true)
 |-- ssl_handshake_result_success_sum: long (nullable = true)
 |-- sync_configured: boolean (nullable = true)
 |-- sync_count_desktop_sum: long (nullable = true)
 |-- sync_count_mobile_sum: long (nullable = true)
 |-- telemetry_enabled: boolean (nullable = true)
 |-- timezone_offset: integer (nullable = true)
 |-- total_hours_sum: decimal(27,6) (nullable = true)
 |-- update_auto_download: boolean (nullable = true)
 |-- update_channel: string (nullable = true)
 |-- update_enabled: boolean (nullable = true)
 |-- vendor: string (nullable = true)
 |-- web_notification_shown_sum: long (nullable = true)
 |-- windows_build_number: long (nullable = true)
 |-- windows_ubr: long (nullable = true)
</code></pre>
<a class="header" href="#code-reference-1" id="code-reference-1"><h1>Code Reference</h1></a>
<p>This dataset is generated by
<a href="https://github.com/mozilla/telemetry-batch-view/tree/master/src/main/scala/com/mozilla/telemetry/views/ClientsDailyView.scala"><code>telemetry-batch-view</code></a>.
Refer to this repository for information on how to run or augment the dataset.</p>
<a class="header" href="#crash-aggregates-reference" id="crash-aggregates-reference"><h1>Crash Aggregates Reference</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#sampling">Sampling</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-8" id="introduction-8"><h1>Introduction</h1></a>
<p>The <code>crash_aggregates</code> dataset compiles crash statistics over various dimensions for each day.</p>
<a class="header" href="#rows-and-columns-1" id="rows-and-columns-1"><h4>Rows and Columns</h4></a>
<p>There's one column for each of the stratifying dimensions and the crash statistics.
Each row is a distinct set of dimensions, along with their associated crash stats.
Example stratifying dimensions include channel and country,
example statistics include usage hours and plugin crashes.
See the <a href="https://github.com/mozilla/telemetry-batch-view/blob/master/docs/CrashAggregateView.md">complete documentation</a>
for all available dimensions
and statistics.</p>
<a class="header" href="#accessing-the-data-18" id="accessing-the-data-18"><h4>Accessing the Data</h4></a>
<p>This dataset is accessible via re:dash.</p>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://telemetry-parquet/crash_aggregates/v1/
</code></pre>
<a class="header" href="#further-reading-10" id="further-reading-10"><h4>Further Reading</h4></a>
<p>The technical documentation for this dataset can be found in the
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/docs/CrashAggregateView.md">telemetry-batch-view documentation</a></p>
<a class="header" href="#data-reference-5" id="data-reference-5"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-5" id="example-queries-5"><h2>Example Queries</h2></a>
<p>Here's an example query that computes crash rates
for each channel (sorted by number of usage hours):</p>
<pre><code class="language-sql">SELECT dimensions['channel'] AS channel,
       sum(stats['usage_hours']) AS usage_hours,
       1000 * sum(stats['main_crashes']) / sum(stats['usage_hours']) AS main_crash_rate,
       1000 * sum(stats['content_crashes']) / sum(stats['usage_hours']) AS content_crash_rate,
       1000 * sum(stats['plugin_crashes']) / sum(stats['usage_hours']) AS plugin_crash_rate,
       1000 * sum(stats['gmplugin_crashes']) / sum(stats['usage_hours']) AS gmplugin_crash_rate,
       1000 * sum(stats['gpu_crashes']) / sum(stats['usage_hours']) AS gpu_crash_rate
FROM crash_aggregates
GROUP BY dimensions['channel']
ORDER BY -sum(stats['usage_hours'])
</code></pre>
<p>Main process crashes by build date and OS version.</p>
<pre><code class="language-sql">WITH channel_rates AS (
  SELECT dimensions['build_id'] AS build_id,
         SUM(stats['main_crashes']) AS main_crashes, -- total number of crashes
         SUM(stats['usage_hours']) / 1000 AS usage_kilohours, -- thousand hours of usage
         dimensions['os_version'] AS os_version -- os version
   FROM crash_aggregates
   WHERE dimensions['experiment_id'] is null -- not in an experiment
     AND regexp_like(dimensions['build_id'], '^\d{14}$') -- validate build IDs
     AND dimensions['build_id'] &gt; '20160201000000' -- only in the date range that we care about
   GROUP BY dimensions['build_id'], dimensions['os_version']
)
SELECT cast(parse_datetime(build_id, 'yyyyMMddHHmmss') as date) as build_id, -- program build date
       usage_kilohours, -- thousands of usage hours
       os_version, -- os version
       main_crashes / usage_kilohours AS main_crash_rate -- crash rate being defined as crashes per thousand usage hours
FROM channel_rates
WHERE usage_kilohours &gt; 100 -- only aggregates that have statistically significant usage hours
ORDER BY build_id ASC
</code></pre>
<a class="header" href="#sampling-2" id="sampling-2"><h2>Sampling</h2></a>
<a class="header" href="#invalid-pings" id="invalid-pings"><h3>Invalid Pings</h3></a>
<p>We ignore invalid pings in our processing. Invalid pings are defined as those that:</p>
<ul>
<li>The submission dates or activity dates are invalid or missing.</li>
<li>The build ID is malformed.</li>
<li>The <code>docType</code> field is missing or unknown.</li>
<li>The ping is a main ping without usage hours or a crash ping with usage hours.</li>
</ul>
<a class="header" href="#scheduling-4" id="scheduling-4"><h2>Scheduling</h2></a>
<p>The <code>crash_aggregates</code> job is run daily, at midnight UTC.
The job is scheduled on <a href="https://github.com/mozilla/telemetry-airflow">Airflow</a>.
The DAG is <a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/crash_aggregates.py">here</a></p>
<a class="header" href="#schema-4" id="schema-4"><h2>Schema</h2></a>
<p>The <code>crash_aggregates</code> table has 4 commonly-used columns:</p>
<ul>
<li><code>submission_date</code> is the date pings were submitted for a particular aggregate.
<ul>
<li>For example, <code>select sum(stats['usage_hours']) from crash_aggregates where submission_date = '2016-03-15'</code> will give the total number of user hours represented by pings submitted on March 15, 2016.</li>
<li>The dataset is partitioned by this field. Queries that limit the possible values of <code>submission_date</code> can run significantly faster.</li>
</ul>
</li>
<li><code>activity_date</code> is the day when the activity being recorded took place.
<ul>
<li>For example, <code>select sum(stats['usage_hours']) from crash_aggregates where activity_date = '2016-03-15'</code> will give the total number of user hours represented by activities that took place on March 15, 2016.</li>
<li>This can be several days before the pings are actually submitted, so it will always be before or on its corresponding <code>submission_date</code>.</li>
<li>Therefore, queries that are sensitive to when measurements were taken on the client should prefer this field over <code>submission_date</code>.</li>
</ul>
</li>
<li><code>dimensions</code> is a map of all the other dimensions that we currently care about. These fields include:
<ul>
<li><code>dimensions['build_version']</code> is the program version, like <code>46.0a1</code>.</li>
<li><code>dimensions['build_id']</code> is the <code>YYYYMMDDhhmmss</code> timestamp the program was built, like <code>20160123180541</code>. This is also known as the <code>build ID</code> or <code>buildid</code>.</li>
<li><code>dimensions['channel']</code> is the channel, like <code>release</code> or <code>beta</code>.</li>
<li><code>dimensions['application']</code> is the program name, like <code>Firefox</code> or <code>Fennec</code>.</li>
<li><code>dimensions['os_name']</code> is the name of the OS the program is running on, like <code>Darwin</code> or <code>Windows_NT</code>.</li>
<li><code>dimensions['os_version']</code> is the version of the OS the program is running on.</li>
<li><code>dimensions['architecture']</code> is the architecture that the program was built for (not necessarily the one it is running on).</li>
<li><code>dimensions['country']</code> is the country code for the user (determined using geoIP), like <code>US</code> or <code>UK</code>.</li>
<li><code>dimensions['experiment_id']</code> is the identifier of the experiment being participated in, such as <code>e10s-beta46-noapz@experiments.mozilla.org</code>, or null if no experiment.</li>
<li><code>dimensions['experiment_branch']</code> is the branch of the experiment being participated in, such as <code>control</code> or <code>experiment</code>, or null if no experiment.</li>
<li><code>dimensions['e10s_enabled']</code> is whether E10s is enabled.</li>
<li><code>dimensions['gfx_compositor']</code> is the graphics backend compositor used by the program, such as <code>d3d11</code>, <code>opengl</code> and <code>simple</code>. Null values may be reported as <code>none</code> as well.</li>
<li>All of the above fields can potentially be blank, which means &quot;not present&quot;. That means that in the actual pings, the corresponding fields were null.</li>
</ul>
</li>
<li><code>stats</code> contains the aggregate values that we care about:
<ul>
<li><code>stats['usage_hours']</code> is the number of user-hours represented by the aggregate.</li>
<li><code>stats['main_crashes']</code> is the number of main process crashes represented by the aggregate (or just program crashes, in the non-E10S case).</li>
<li><code>stats['content_crashes']</code> is the number of content process crashes represented by the aggregate.</li>
<li><code>stats['plugin_crashes']</code> is the number of plugin process crashes represented by the aggregate.</li>
<li><code>stats['gmplugin_crashes']</code> is the number of Gecko media plugin (often abbreviated <code>GMPlugin</code>) process crashes represented by the aggregate.</li>
<li><code>stats['content_shutdown_crashes']</code> is the number of content process crashes that were caused by failure to shut down in a timely manner.</li>
<li><code>stats['gpu_crashes']</code> is the number of GPU process crashes represented by the aggregate.</li>
</ul>
</li>
</ul>
<p><code>TODO(harter)</code>: https://bugzilla.mozilla.org/show_bug.cgi?id=1361862</p>
<a class="header" href="#crash-summary-reference" id="crash-summary-reference"><h1>Crash Summary Reference</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#sampling">Sampling</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-9" id="introduction-9"><h1>Introduction</h1></a>
<p>The <code>crash_summary</code> table is the most direct representation of a crash ping.</p>
<a class="header" href="#contents-11" id="contents-11"><h4>Contents</h4></a>
<p>The <code>crash_summary</code> table contains one row for each crash ping.
Each column represents one field from the crash ping payload,
though only a subset of all crash ping fields are included.</p>
<a class="header" href="#accessing-the-data-19" id="accessing-the-data-19"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://telemetry-parquet/crash_summary/v1/
</code></pre>
<p><code>crash_summary</code> is accessible through re:dash.
Here's an <a href="https://sql.telemetry.mozilla.org/queries/4793/source">example query</a>.</p>
<a class="header" href="#further-reading-11" id="further-reading-11"><h4>Further Reading</h4></a>
<p>The technical documentation for <code>crash_summary</code> is located in the
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/docs/CrashSummary.md">telemetry-batch-view documentation</a>.</p>
<p>The code responsible for generating this dataset is
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/CrashSummaryView.scala">here</a></p>
<a class="header" href="#data-reference-6" id="data-reference-6"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-6" id="example-queries-6"><h2>Example Queries</h2></a>
<p>Here is an example query to get the total number of main crashes by <code>gfx_compositor</code>:</p>
<pre><code class="language-sql">select gfx_compositor, count(*)
from crash_summary
where application = 'Firefox'
and (payload.processType IS NULL OR payload.processType = 'main')
group by gfx_compositor
</code></pre>
<a class="header" href="#sampling-3" id="sampling-3"><h2>Sampling</h2></a>
<p><code>CrashSummary</code> contains one record for every
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/crash-ping.html">crash ping</a>
submitted by Firefox.
It was built with the long term goal of providing a base for
<a href="../crash_aggregates/reference.html"><code>CrashAggregates</code></a>.</p>
<a class="header" href="#scheduling-5" id="scheduling-5"><h2>Scheduling</h2></a>
<p>This dataset is updated daily, shortly after midnight UTC.
The job is scheduled on
<a href="https://github.com/mozilla/telemetry-airflow">telemetry-airflow</a>.
The DAG is <a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/crash_summary.py">here</a>.</p>
<a class="header" href="#schema-5" id="schema-5"><h2>Schema</h2></a>
<pre><code>root
 |-- client_id: string (nullable = true)
 |-- normalized_channel: string (nullable = true)
 |-- build_version: string (nullable = true)
 |-- build_id: string (nullable = true)
 |-- channel: string (nullable = true)
 |-- application: string (nullable = true)
 |-- os_name: string (nullable = true)
 |-- os_version: string (nullable = true)
 |-- architecture: string (nullable = true)
 |-- country: string (nullable = true)
 |-- experiment_id: string (nullable = true)
 |-- experiment_branch: string (nullable = true)
 |-- experiments: map (nullable = true)
 |    |-- key: string
 |    |-- value: string (valueContainsNull = true)
 |-- e10s_enabled: boolean (nullable = true)
 |-- gfx_compositor: string (nullable = true)
 |-- profile_created: integer (nullable = true)
 |-- payload: struct (nullable = true)
 |    |-- crashDate: string (nullable = true)
 |    |-- processType: string (nullable = true)
 |    |-- hasCrashEnvironment: boolean (nullable = true)
 |    |-- metadata: map (nullable = true)
 |    |    |-- key: string
 |    |    |-- value: string (valueContainsNull = true)
 |    |-- version: integer (nullable = true)
 |-- submission_date: string (nullable = true)
</code></pre>
<p>For more detail on where these fields come from in the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/crash-ping.html">raw data</a>,
please look at the case classes
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/CrashSummaryView.scala">in the <code>CrashSummaryView</code> code</a>.</p>
<a class="header" href="#cross-sectional-reference" id="cross-sectional-reference"><h1>Cross Sectional Reference</h1></a>
<p>This data set has been deprecated in favor of <a href="../clients_daily/reference.html">Clients Daily</a></p>
<a class="header" href="#error-aggregates-reference" id="error-aggregates-reference"><h1>Error Aggregates Reference</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#sampling">Sampling</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-10" id="introduction-10"><h1>Introduction</h1></a>
<p>The <code>error_aggregates_v2</code> table represents counts of errors counted from main and crash
pings, aggregated every 5 minutes. It is the dataset backing the main <a href="https://data-missioncontrol.dev.mozaws.net/">mission
control</a> view, but may also be queried
independently.</p>
<a class="header" href="#contents-12" id="contents-12"><h4>Contents</h4></a>
<p>The <code>error_aggregates_v2</code> table contains counts of various error measures (for
example: crashes, &quot;the slow script dialog showing&quot;), aggregated across each
unique set of dimensions (for example: channel, operating system) every 5
minutes. You can get an aggregated count for any particular set of dimensions
by summing using SQL.</p>
<a class="header" href="#experiment-unpacking" id="experiment-unpacking"><h5>Experiment unpacking</h5></a>
<p>It's important to note that when this dataset is written, pings from clients participating in an experiment
are aggregated on the <code>experiment_id</code> and <code>branch_id</code> dimensions corresponding to what experiment and branch
they are participating in. However, they are also aggregated with the rest of the population where the values of
these dimensions are null.
Therefore care must be taken when writing aggregating queries over the whole population - in these cases one needs to
filter for <code>experiment_id is null</code> and <code>branch_id is null</code> in order to not double-count pings from experiments.</p>
<a class="header" href="#accessing-the-data-20" id="accessing-the-data-20"><h4>Accessing the data</h4></a>
<p>You can access the data via re:dash. Choose <code>Athena</code> and then select the
<code>telemetry.error_aggregates_v2</code> table.</p>
<a class="header" href="#further-reading-12" id="further-reading-12"><h4>Further Reading</h4></a>
<p>The code responsible for generating this dataset is <a href="https://github.com/mozilla/telemetry-streaming/blob/master/src/main/scala/com/mozilla/telemetry/streaming/ErrorAggregator.scala">here</a>.</p>
<a class="header" href="#data-reference-7" id="data-reference-7"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-7" id="example-queries-7"><h2>Example Queries</h2></a>
<p>Getting a large number of different crash measures across many platforms and channels
(<a href="https://sql.telemetry.mozilla.org/queries/4769/source">view on Re:dash</a>):</p>
<pre><code class="language-sql">SELECT window_start,
       build_id,
       channel,
       os_name,
       version,
       sum(usage_hours) AS usage_hours,
       sum(main_crashes) AS main,
       sum(content_crashes) AS content,
       sum(gpu_crashes) AS gpu,
       sum(plugin_crashes) AS plugin,
       sum(gmplugin_crashes) AS gmplugin
FROM telemetry.error_aggregates_v2
  WHERE application = 'Firefox'
  AND (os_name = 'Darwin' or os_name = 'Linux' or os_name = 'Windows_NT')
  AND (channel = 'beta' or channel = 'release' or channel = 'nightly' or channel = 'esr')
  AND build_id &gt; '201801'
  AND window_start &gt; current_timestamp - (1 * interval '24' hour)
  AND experiment_id IS NULL
  AND branch_id IS NULL
GROUP BY window_start, channel, build_id, version, os_name
</code></pre>
<p>Get the number of <code>main_crashes</code> on Windows over a small interval
(<a href="https://sql.telemetry.mozilla.org/queries/51677">view on Re:dash</a>):</p>
<pre><code class="language-sql">SELECT window_start as time, sum(main_crashes) AS main_crashes
FROM telemetry.error_aggregates_v2
  WHERE application = 'Firefox'
  AND os_name = 'Windows_NT'
  AND channel = 'release'
  AND version = '58.0.2'
  AND window_start &gt; timestamp '2018-02-21'
  AND window_end &lt; timestamp '2018-02-22'
  AND experiment_id IS NULL
  AND branch_id IS NULL
GROUP BY window_start
</code></pre>
<a class="header" href="#sampling-4" id="sampling-4"><h2>Sampling</h2></a>
<a class="header" href="#data-sources-1" id="data-sources-1"><h3>Data sources</h3></a>
<p>The aggregates in this data source are derived from main, crash and core <a href="../../pings.html">pings</a>:</p>
<ul>
<li>crash pings are used to count/gather main and content crash events, all other errors from desktop clients (including all other crashes) are gathered from main pings</li>
<li>core pings are used to count usage hours, first subsession and unique client counts.</li>
</ul>
<a class="header" href="#scheduling-6" id="scheduling-6"><h2>Scheduling</h2></a>
<p>The <code>error_aggregates</code> job is run continuously, using the Spark Streaming infrastructure</p>
<a class="header" href="#schema-6" id="schema-6"><h2>Schema</h2></a>
<p>The <code>error_aggregates_v2</code> table has the following columns which define its dimensions:</p>
<ul>
<li><code>window_start</code>: beginning of interval when this sample was taken</li>
<li><code>window_end</code>: end of interval when this sample was taken (will always be 5 minutes more
than <code>window_start</code> for any given row)</li>
<li><code>submission_date_s3</code>: the date pings were submitted for a particular aggregate</li>
<li><code>channel</code>: the channel, like <code>release</code> or <code>beta</code></li>
<li><code>version</code>: the version e.g. <code>57.0.1</code></li>
<li><code>display_version</code>: like version, but includes beta number if applicable e.g. <code>57.0.1b4</code></li>
<li><code>build_id</code>: the <code>YYYYMMDDhhmmss</code> timestamp the program was built, like <code>20160123180541</code>. This is also known as the <code>build ID</code> or <code>buildid</code></li>
<li><code>application</code>: application name (e.g. <code>Firefox</code> or <code>Fennec</code>)</li>
<li><code>os_name</code>: name of the OS (e.g. <code>Darwin</code> or <code>Windows_NT</code>)</li>
<li><code>os_version</code>: version of the OS</li>
<li><code>architecture</code>: build architecture, e.g. <code>x86</code></li>
<li><code>country</code>: country code for the user (determined using geoIP), like <code>US</code> or <code>UK</code></li>
<li><code>experiment_id</code>: identifier of the experiment being participated in, such as <code>e10s-beta46-noapz@experiments.mozilla.org</code>, null if no experiment or for unpacked rows (see <a href="#experiment-unpacking">Experiment unpacking</a>)</li>
<li><code>experiment_branch</code>: the branch of the experiment being participated in, such as <code>control</code> or <code>experiment</code>, null if no experiment or for unpacked rows (see <a href="#experiment-unpacking">Experiment unpacking</a>)</li>
</ul>
<p>And these are the various measures we are counting:</p>
<ul>
<li><code>usage_hours</code>: number of usage hours (i.e. total number of session hours reported by the pings in this aggregate, note that this might include time where
people are not actively using the browser or their computer is asleep)</li>
<li><code>count</code>: number of pings processed in this aggregate</li>
<li><code>main_crashes</code>: number of main process crashes (or just program crashes, in the non-e10s case)</li>
<li><code>startup_crashes</code> : number of startup crashes</li>
<li><code>content_crashes</code>: number of content process crashes (<code>version =&gt; 58</code> only)</li>
<li><code>gpu_crashes</code>: number of GPU process crashes</li>
<li><code>plugin_crashes</code>: number of plugin process crashes</li>
<li><code>gmplugin_crashes</code>: number of Gecko media plugin (often abbreviated <code>GMPlugin</code>) process crashes</li>
<li><code>content_shutdown_crashes</code>: number of content process crashes that were caused by failure to shut down in a timely manner (<code>version =&gt; 58</code> only)</li>
<li><code>browser_shim_usage_blocked</code>: number of times a CPOW shim was blocked from being created by browser code</li>
<li><code>permissions_sql_corrupted</code>: number of times the permissions SQL error occurred (beta/nightly only)</li>
<li><code>defective_permissions_sql_removed</code>: number of times there was a removal of defective <code>permissions.sqlite</code> (beta/nightly only)</li>
<li><code>slow_script_notice_count</code>: number of times the slow script notice count was shown (beta/nightly only)</li>
<li><code>slow_script_page_count</code>: number of pages that trigger slow script notices (beta/nightly only)</li>
</ul>
<a class="header" href="#introduction-11" id="introduction-11"><h1>Introduction</h1></a>
<p>This is a work in progress.
The work is being tracked
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364170">here</a>.</p>
<a class="header" href="#data-reference-8" id="data-reference-8"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-8" id="example-queries-8"><h2>Example Queries</h2></a>
<p>This is a work in progress.
The work is being tracked
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364170">here</a>.</p>
<a class="header" href="#sampling-5" id="sampling-5"><h2>Sampling</h2></a>
<p>The events dataset contains one row for each event in a main ping.
This dataset is derived from <a href="../main_summary/reference.html"><code>main_summary</code></a>
so any of <code>main_summary</code>'s filters affect this dataset as well.</p>
<p>Data is currently available from 2017-01-05 on.</p>
<a class="header" href="#scheduling-7" id="scheduling-7"><h2>Scheduling</h2></a>
<p>The events dataset is updated daily, shortly after
<a href="../main_summary/reference.html"><code>main_summary</code></a> is updated.
The job is scheduled on <a href="https://github.com/mozilla/telemetry-airflow">Airflow</a>.
The DAG is <a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/main_summary.py#L63">here</a>.</p>
<a class="header" href="#firefox-events" id="firefox-events"><h2>Firefox events</h2></a>
<p>Firefox has an API to record events, which are then submitted through the main ping.
The format and mechanism of event collection in Firefox is documented <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html">here</a>.</p>
<p>The full events data pipeline is <a href="../../../concepts/pipeline/event_pipeline.html">documented here</a>.</p>
<a class="header" href="#schema-7" id="schema-7"><h2>Schema</h2></a>
<p>As of 2017-01-26, the current version of the <code>events</code> dataset is <code>v1</code>, and has a schema as follows:</p>
<pre><code>root
 |-- document_id: string (nullable = true)
 |-- client_id: string (nullable = true)
 |-- normalized_channel: string (nullable = true)
 |-- country: string (nullable = true)
 |-- locale: string (nullable = true)
 |-- app_name: string (nullable = true)
 |-- app_version: string (nullable = true)
 |-- os: string (nullable = true)
 |-- os_version: string (nullable = true)
 |-- subsession_start_date: string (nullable = true)
 |-- subsession_length: long (nullable = true)
 |-- sync_configured: boolean (nullable = true)
 |-- sync_count_desktop: integer (nullable = true)
 |-- sync_count_mobile: integer (nullable = true)
 |-- timestamp: long (nullable = true)
 |-- sample_id: string (nullable = true)
 |-- event_timestamp: long (nullable = false)
 |-- event_category: string (nullable = false)
 |-- event_method: string (nullable = false)
 |-- event_object: string (nullable = false)
 |-- event_string_value: string (nullable = true)
 |-- event_map_values: map (nullable = true)
 |    |-- key: string
 |    |-- value: string
 |-- submission_date_s3: string (nullable = true)
 |-- doc_type: string (nullable = true)
</code></pre>
<a class="header" href="#first-shutdown-summary" id="first-shutdown-summary"><h1>First Shutdown Summary</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
<a class="header" href="#introduction-12" id="introduction-12"><h1>Introduction</h1></a>
<p>The <code>first_shutdown_summary</code> table is a summary of the <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/first-shutdown-ping.html"><code>first-shutdown</code>
ping</a>.</p>
<a class="header" href="#contents-13" id="contents-13"><h4>Contents</h4></a>
<p>The first shutdown ping contains first session usage data. The
dataset has rows similar to the
<a href="../new_profile/reference.html"><code>telemetry_new_profile_parquet</code></a>,
but in the shape of
<a href="../main_summary/reference.html"><code>main_summary</code></a>.</p>
<a class="header" href="#background-and-caveats-11" id="background-and-caveats-11"><h4>Background and Caveats</h4></a>
<p>Ping latency was reduced through the
shutdown ping-sender mechanism in Firefox 55. To maintain consistent historical
behavior, the first main ping is not sent until the second start up. In Firefox 57, a
separate first-shutdown ping was created to evaluate first-shutdown behavior while maintaining backwards compatibility.</p>
<p>In many cases, the first-shutdown ping is a duplicate of the main ping. The first-shutdown summary can be used in conjunction with the main summary by taking the union and deduplicating on the <code>document_id</code>.</p>
<a class="header" href="#accessing-the-data-21" id="accessing-the-data-21"><h4>Accessing the Data</h4></a>
<p>The data can be accessed as <code>first_shutdown_summary</code>. It is currently stored in the following path.</p>
<pre><code>s3://telemetry-parquet/first_shutdown_summary/v4/
</code></pre>
<p>The data is backfilled to 2017-09-22, the date of its first nightly appearance. This data should be available to all releases on and after Firefox 57.</p>
<a class="header" href="#code-reference-2" id="code-reference-2"><h1>Code Reference</h1></a>
<p>This dataset is generated by
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/MainSummaryView.scala">telemetry-batch-view</a>.</p>
<a class="header" href="#longitudinal-reference" id="longitudinal-reference"><h1>Longitudinal Reference</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#sampling">Sampling</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
<a class="header" href="#introduction-13" id="introduction-13"><h1>Introduction</h1></a>
<p>The <code>longitudinal</code> dataset is a 1% sample of main ping data
organized so that each row corresponds to a <code>client_id</code>.
If you're not sure which dataset to use for your analysis,
this is probably what you want.</p>
<a class="header" href="#contents-14" id="contents-14"><h4>Contents</h4></a>
<p>Each row in the <code>longitudinal</code> dataset represents one <code>client_id</code>,
which is approximately a user.
Each column represents a field from the main ping.
Most fields contain <strong>arrays of values</strong>, with one value for each ping associated with a <code>client_id</code>.
Using arrays give you access to the raw data from each ping,
but can be difficult to work with from SQL.
Here's a <a href="https://sql.telemetry.mozilla.org/queries/4188#table">query showing some sample data</a>
to help illustrate.
Take a look at the <a href="../../../cookbooks/longitudinal.html">longitudinal examples</a> if you get stuck.</p>
<a class="header" href="#background-and-caveats-12" id="background-and-caveats-12"><h4>Background and Caveats</h4></a>
<p>Think of the longitudinal table as wide and short.
The dataset contains more columns than <code>main_summary</code>
and down-samples to 1% of all clients to reduce query computation time and save resources.</p>
<p>In summary, the longitudinal table differs from <code>main_summary</code> in two important ways:</p>
<ul>
<li>The longitudinal dataset groups all data so that one row represents a <code>client_id</code></li>
<li>The longitudinal dataset samples to 1% of all <code>client_id</code>s</li>
</ul>
<p>Please note that this dataset only contains release (or opt-out) histograms and scalars.</p>
<a class="header" href="#accessing-the-data-22" id="accessing-the-data-22"><h4>Accessing the Data</h4></a>
<p>The <code>longitudinal</code> is available in re:dash,
though it can be difficult to work with the array values in SQL.
Take a look at this <a href="https://sql.telemetry.mozilla.org/queries/4189/source">example query</a>.</p>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data
in <a href="http://spark.apache.org/docs/latest/quick-start.html">Spark</a>.</p>
<pre><code>s3://telemetry-parquet/longitudinal/
</code></pre>
<a class="header" href="#data-reference-9" id="data-reference-9"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-9" id="example-queries-9"><h2>Example Queries</h2></a>
<p>Take a look at the
<a href="../../../cookbooks/longitudinal_examples.html">Longitudinal Examples Cookbook</a>.</p>
<a class="header" href="#sampling-6" id="sampling-6"><h2>Sampling</h2></a>
<a class="header" href="#pings-within-last-6-months" id="pings-within-last-6-months"><h3>Pings Within Last 6 Months</h3></a>
<p>The <code>longitudinal</code> filters to <code>main</code> pings from within the last 6 months.</p>
<a class="header" href="#a1-sample" id="a1-sample"><h3>1% Sample</h3></a>
<p>The longitudinal dataset samples down to 1% of all clients in the above sample.
The sample is generated by the following process:</p>
<ul>
<li>hash the <code>client_id</code> for each ping from the last 6 months.</li>
<li>project that hash onto an integer from 1:100, inclusive</li>
<li>filter to pings with <code>client_id</code>s matching a 'magic number' (in this case 42)</li>
</ul>
<p>This process has a couple of nice properties:</p>
<ul>
<li>The sample is consistent over time.
The <code>longitudinal</code> dataset is regenerated weekly.
The clients included in each run are very similar with this process.
The only change will come from never-before-seen clients,
or clients without a ping in the last 180 days.</li>
<li>We don't need to adjust the sample as new clients enter or exit our pool.</li>
</ul>
<p>More practically,
the sample is created by filtering to pings with <code>main_summary.sample_id == 42</code>.
If you're working with <code>main_summary</code>,
you can recreate this sample by doing this filter manually.</p>
<a class="header" href="#scheduling-8" id="scheduling-8"><h2>Scheduling</h2></a>
<p>The <code>longitudinal</code> job is run weekly, early on Sunday morning UTC.
The job is scheduled on <a href="https://github.com/mozilla/telemetry-airflow">Airflow</a>.
The DAG is <a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/longitudinal.py">here</a>.</p>
<a class="header" href="#schema-8" id="schema-8"><h2>Schema</h2></a>
<p><code>TODO(harter)</code>: https://bugzilla.mozilla.org/show_bug.cgi?id=1361862</p>
<a class="header" href="#code-reference-3" id="code-reference-3"><h1>Code Reference</h1></a>
<p>This dataset is generated by
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/Longitudinal.scala">telemetry-batch-view</a>.
Refer to this repository for information on how to run or augment the dataset.</p>
<a class="header" href="#main-summary" id="main-summary"><h1>Main Summary</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#adding-new-fields">Adding New Fields</a>
<ul>
<li><a href="#user-preferences">User Preferences</a></li>
<li><a href="#histograms">Histograms</a></li>
<li><a href="#addon-scalars">Addon Scalars</a></li>
<li><a href="#other-fields">Other Fields</a></li>
</ul>
</li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#sampling">Sampling</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
<li><a href="#time-formats">Time formats</a></li>
</ul>
</li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
<a class="header" href="#introduction-14" id="introduction-14"><h1>Introduction</h1></a>
<p>The <code>main_summary</code> table is the most direct representation of a main ping
but can be difficult to work with due to its size.
Prefer the <code>longitudinal</code> dataset unless using the sampled data is prohibitive.</p>
<a class="header" href="#contents-15" id="contents-15"><h4>Contents</h4></a>
<p>The <code>main_summary</code> table contains one row for each ping.
Each column represents one field from the main ping payload,
though only a subset of all main ping fields are included.
This dataset <strong>does not include histograms</strong>.</p>
<a class="header" href="#background-and-caveats-13" id="background-and-caveats-13"><h4>Background and Caveats</h4></a>
<p>This table is massive, and due to its size, it can be difficult to work with.
You should <strong>avoid querying <code>main_summary</code></strong> from <a href="https://sql.telemetry.mozilla.org">re:dash</a>.
Your queries will be <strong>slow to complete</strong> and can <strong>impact performance for other users</strong>,
since re:dash on a shared cluster.</p>
<p>Instead, we recommend using the <code>longitudinal</code> or <code>clients_daily</code> dataset where possible.
If these datasets do not suffice, consider using Spark on an
<a href="https://analysis.telemetry.mozilla.org">ATMO</a> cluster.
In the odd case where these queries are necessary,
make use of the <code>sample_id</code> field and limit to a short submission date range.</p>
<a class="header" href="#accessing-the-data-23" id="accessing-the-data-23"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://telemetry-parquet/main_summary/v4/
</code></pre>
<p>Though <strong>not recommended</strong> <code>main_summary</code> is accessible through re:dash.
Here's an <a href="https://sql.telemetry.mozilla.org/queries/4201/source">example query</a>.
Your queries will be slow to complete and can <strong>impact performance for other users</strong>,
since re:dash is on a shared cluster.</p>
<a class="header" href="#further-reading-13" id="further-reading-13"><h4>Further Reading</h4></a>
<p>The technical documentation for <code>main_summary</code> is located in the
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/docs/MainSummary.md">telemetry-batch-view documentation</a>.</p>
<p>The code responsible for generating this dataset is
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/MainSummaryView.scala">here</a></p>
<a class="header" href="#adding-new-fields" id="adding-new-fields"><h1>Adding New Fields</h1></a>
<p>We support a few basic types that can be easily added to <code>main_summary</code>.</p>
<p>Non-addon scalars are automatically added to <code>main_summary</code>.</p>
<a class="header" href="#user-preferences" id="user-preferences"><h2>User Preferences</h2></a>
<p>These are added in the <code>userPrefsList</code>, near the top of the
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/MainSummaryView.scala">Main Summary file</a>.
They must be available in the <a href="http://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/environment.html">ping environment</a>
to be included here. There is more information in the file itself.</p>
<p>Once added, they will show as top-level fields, with the string <code>user_pref</code> prepended. For example, <code>IntegerUserPref(&quot;dom.ipc.processCount&quot;)</code> becomes <code>user_pref_dom_ipc_processcount</code>.</p>
<a class="header" href="#histograms" id="histograms"><h2>Histograms</h2></a>
<p>Histograms can simply be added to the <code>histogramsWhitelist</code> near the top of
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/MainSummaryView.scala">Main Summary file</a>.
Simply add the name of the histogram in the alphabetically-sorted position in the list.</p>
<p>Each process a histogram is recorded in will have a column in <code>main_summary</code>, with the string <code>histogram_</code> prepended. For example, <code>CYCLE_COLLECTOR_MAX_PAUSE</code>
is recorded in the <code>parent</code>, <code>content</code>, and <code>gpu</code> processes (according to the <a href="https://telemetry.mozilla.org/probe-dictionary/?search=CYCLE_COLLECTOR_MAX_PAUSE&amp;detailView=histogram%2FCYCLE_COLLECTOR_MAX_PAUSE">definition</a>).
It will then result in three columns:</p>
<ul>
<li><code>histogram_parent_cycle_collector_max_pause</code></li>
<li><code>histogram_content_cycle_collector_max_pause</code></li>
<li><code>histogram_gpu_cycle_collector_max_pause</code></li>
</ul>
<a class="header" href="#addon-scalars" id="addon-scalars"><h2>Addon Scalars</h2></a>
<p>Addon scalars are recorded by an addon. To include one of these, add the <a href="https://dxr.mozilla.org/mozilla-central/rev/tip/toolkit/components/telemetry/Scalars.yaml">definition</a> to the
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/resources/addon/Scalars.yaml">addon scalars definition file</a> in <a href="https://github.com/mozilla/telemetry-batch-view">telemetry-batch-view</a>.
Be sure to include the section:</p>
<pre><code>    record_in_processes:
      - 'dynamic'
</code></pre>
<p>The addon scalars can then be found in the associated column, depending on their type:</p>
<ul>
<li><code>string_addon_scalars</code></li>
<li><code>keyed_string_addon_scalars</code></li>
<li><code>uint_addon_scalars</code></li>
<li><code>keyed_uint_addon_scalars</code></li>
<li><code>boolean_addon_scalars</code></li>
<li><code>keyed_boolean_addon_scalars</code></li>
</ul>
<p>These columns are all maps. Each addon scalar will be a key within that map, concatenating the top-level subsection within <code>Scalars.yaml</code> with its name to get the key. As an example, consider the following scalar definition:</p>
<pre><code>test:
  misunderestimated_nucular:
    description: A test scalar, no soup for you!
    expires: never
    kind: string
    keyed: true
    notification_emails:
      - frank@mozilla.com
    record_in_processes:
      - 'dynamic'
</code></pre>
<p>For example, you could find the addon scalar <code>test.misunderestimated_nucular</code>, a keyed string scalar, using <code>keyed_string_addon_scalars['test_misunderestimated_nucular']</code>.
In general, use <code>element_at</code>, which returns <code>NULL</code> when the key is not found: <code>element_at(keyed_string_addon_scalars, 'test_misunderestimated_nucular')</code></p>
<a class="header" href="#other-fields" id="other-fields"><h2>Other Fields</h2></a>
<p>We can include other types of fields as well, for example if there needs to be a specific transformation done. We do need the data to be available in the <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">Main Ping</a></p>
<a class="header" href="#data-reference-10" id="data-reference-10"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-10" id="example-queries-10"><h2>Example Queries</h2></a>
<p>We recommend working with this dataset via Spark rather than <code>sql.t.m.o</code>.
Due to the large number of records,
queries can consume a lot of resources on the
<strong>shared cluster and impact other users</strong>.
Queries via <code>sql.t.m.o</code> should limit to a short <code>submission_date_s3</code> range,
and ideally make use of the <code>sample_id</code> field.</p>
<p>When using Presto to query the data from <code>sql.t.m.o</code>,
you can use the <code>UNNEST</code> feature to access items in the
<code>search_counts</code>, <code>popup_notification_stats</code> and <code>active_addons</code> fields.</p>
<p>For example, to compare the search volume for different search source values,
you could use:</p>
<pre><code class="language-sql">WITH search_data AS (
  SELECT
    s.source AS search_source,
    s.count AS search_count
  FROM
    main_summary
    CROSS JOIN UNNEST(search_counts) AS t(s)
  WHERE
    submission_date_s3 = '20160510'
    AND sample_id = '42'
    AND search_counts IS NOT NULL
)

SELECT
  search_source,
  sum(search_count) as total_searches
FROM search_data
GROUP BY search_source
ORDER BY sum(search_count) DESC
</code></pre>
<a class="header" href="#sampling-7" id="sampling-7"><h2>Sampling</h2></a>
<p>The <code>main_summary</code> dataset contains one record for each <code>main</code> ping
as long as the record contains a non-null value for
<code>documentId</code>, <code>submissionDate</code>, and <code>Timestamp</code>.
We do not ever expect nulls for these fields.</p>
<a class="header" href="#scheduling-9" id="scheduling-9"><h2>Scheduling</h2></a>
<p>This dataset is updated daily via the <a href="https://github.com/mozilla/telemetry-airflow">telemetry-airflow</a> infrastructure.
The job DAG runs every day shortly after midnight UTC.
You can find the job definition
<a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/main_summary.py">here</a></p>
<a class="header" href="#schema-9" id="schema-9"><h2>Schema</h2></a>
<p>As of 2017-12-03, the current version of the <code>main_summary</code> dataset is <code>v4</code>, and has a schema as follows:</p>
<pre><code>root
 |-- document_id: string (nullable = false)
 |-- client_id: string (nullable = true)
 |-- channel: string (nullable = true)
 |-- normalized_channel: string (nullable = true)
 |-- normalized_os_version: string (nullable = true)
 |-- country: string (nullable = true)
 |-- city: string (nullable = true)
 |-- geo_subdivision1: string (nullable = true)
 |-- geo_subdivision2: string (nullable = true)
 |-- os: string (nullable = true)
 |-- os_version: string (nullable = true)
 |-- os_service_pack_major: long (nullable = true)
 |-- os_service_pack_minor: long (nullable = true)
 |-- windows_build_number: long (nullable = true)
 |-- windows_ubr: long (nullable = true)
 |-- install_year: long (nullable = true)
 |-- is_wow64: boolean (nullable = true)
 |-- memory_mb: integer (nullable = true)
 |-- cpu_count: integer (nullable = true)
 |-- cpu_cores: integer (nullable = true)
 |-- cpu_vendor: string (nullable = true)
 |-- cpu_family: integer (nullable = true)
 |-- cpu_model: integer (nullable = true)
 |-- cpu_stepping: integer (nullable = true)
 |-- cpu_l2_cache_kb: integer (nullable = true)
 |-- cpu_l3_cache_kb: integer (nullable = true)
 |-- cpu_speed_mhz: integer (nullable = true)
 |-- gfx_features_d3d11_status: string (nullable = true)
 |-- gfx_features_d2d_status: string (nullable = true)
 |-- gfx_features_gpu_process_status: string (nullable = true)
 |-- gfx_features_advanced_layers_status: string (nullable = true)
 |-- apple_model_id: string (nullable = true)
 |-- antivirus: array (nullable = true)
 |    |-- element: string (containsNull = false)
 |-- antispyware: array (nullable = true)
 |    |-- element: string (containsNull = false)
 |-- firewall: array (nullable = true)
 |    |-- element: string (containsNull = false)
 |-- profile_creation_date: long (nullable = true)
 |-- profile_reset_date: long (nullable = true)
 |-- previous_build_id: string (nullable = true)
 |-- session_id: string (nullable = true)
 |-- subsession_id: string (nullable = true)
 |-- previous_session_id: string (nullable = true)
 |-- previous_subsession_id: string (nullable = true)
 |-- session_start_date: string (nullable = true)
 |-- subsession_start_date: string (nullable = true)
 |-- session_length: long (nullable = true)
 |-- subsession_length: long (nullable = true)
 |-- subsession_counter: integer (nullable = true)
 |-- profile_subsession_counter: integer (nullable = true)
 |-- creation_date: string (nullable = true)
 |-- distribution_id: string (nullable = true)
 |-- submission_date: string (nullable = false)
 |-- sync_configured: boolean (nullable = true)
 |-- sync_count_desktop: integer (nullable = true)
 |-- sync_count_mobile: integer (nullable = true)
 |-- app_build_id: string (nullable = true)
 |-- app_display_version: string (nullable = true)
 |-- app_name: string (nullable = true)
 |-- app_version: string (nullable = true)
 |-- timestamp: long (nullable = false)
 |-- env_build_id: string (nullable = true)
 |-- env_build_version: string (nullable = true)
 |-- env_build_arch: string (nullable = true)
 |-- e10s_enabled: boolean (nullable = true)
 |-- e10s_multi_processes: long (nullable = true)
 |-- locale: string (nullable = true)
 |-- update_channel: string (nullable = true)
 |-- update_enabled: boolean (nullable = true)
 |-- update_auto_download: boolean (nullable = true)
 |-- attribution: struct (nullable = true)
 |    |-- source: string (nullable = true)
 |    |-- medium: string (nullable = true)
 |    |-- campaign: string (nullable = true)
 |    |-- content: string (nullable = true)
 |-- sandbox_effective_content_process_level: integer (nullable = true)
 |-- active_experiment_id: string (nullable = true)
 |-- active_experiment_branch: string (nullable = true)
 |-- reason: string (nullable = true)
 |-- timezone_offset: integer (nullable = true)
 |-- plugin_hangs: integer (nullable = true)
 |-- aborts_plugin: integer (nullable = true)
 |-- aborts_content: integer (nullable = true)
 |-- aborts_gmplugin: integer (nullable = true)
 |-- crashes_detected_plugin: integer (nullable = true)
 |-- crashes_detected_content: integer (nullable = true)
 |-- crashes_detected_gmplugin: integer (nullable = true)
 |-- crash_submit_attempt_main: integer (nullable = true)
 |-- crash_submit_attempt_content: integer (nullable = true)
 |-- crash_submit_attempt_plugin: integer (nullable = true)
 |-- crash_submit_success_main: integer (nullable = true)
 |-- crash_submit_success_content: integer (nullable = true)
 |-- crash_submit_success_plugin: integer (nullable = true)
 |-- shutdown_kill: integer (nullable = true)
 |-- active_addons_count: long (nullable = true)
 |-- flash_version: string (nullable = true)
 |-- vendor: string (nullable = true)
 |-- is_default_browser: boolean (nullable = true)
 |-- default_search_engine_data_name: string (nullable = true)
 |-- default_search_engine_data_load_path: string (nullable = true)
 |-- default_search_engine_data_origin: string (nullable = true)
 |-- default_search_engine_data_submission_url: string (nullable = true)
 |-- default_search_engine: string (nullable = true)
 |-- devtools_toolbox_opened_count: integer (nullable = true)
 |-- client_submission_date: string (nullable = true)
 |-- client_clock_skew: long (nullable = true)
 |-- client_submission_latency: long (nullable = true)
 |-- places_bookmarks_count: integer (nullable = true)
 |-- places_pages_count: integer (nullable = true)
 |-- push_api_notify: integer (nullable = true)
 |-- web_notification_shown: integer (nullable = true)
 |-- popup_notification_stats: map (nullable = true)
 |    |-- key: string
 |    |-- value: struct (valueContainsNull = true)
 |    |    |-- offered: integer (nullable = true)
 |    |    |-- action_1: integer (nullable = true)
 |    |    |-- action_2: integer (nullable = true)
 |    |    |-- action_3: integer (nullable = true)
 |    |    |-- action_last: integer (nullable = true)
 |    |    |-- dismissal_click_elsewhere: integer (nullable = true)
 |    |    |-- dismissal_leave_page: integer (nullable = true)
 |    |    |-- dismissal_close_button: integer (nullable = true)
 |    |    |-- dismissal_not_now: integer (nullable = true)
 |    |    |-- open_submenu: integer (nullable = true)
 |    |    |-- learn_more: integer (nullable = true)
 |    |    |-- reopen_offered: integer (nullable = true)
 |    |    |-- reopen_action_1: integer (nullable = true)
 |    |    |-- reopen_action_2: integer (nullable = true)
 |    |    |-- reopen_action_3: integer (nullable = true)
 |    |    |-- reopen_action_last: integer (nullable = true)
 |    |    |-- reopen_dismissal_click_elsewhere: integer (nullable = true)
 |    |    |-- reopen_dismissal_leave_page: integer (nullable = true)
 |    |    |-- reopen_dismissal_close_button: integer (nullable = true)
 |    |    |-- reopen_dismissal_not_now: integer (nullable = true)
 |    |    |-- reopen_open_submenu: integer (nullable = true)
 |    |    |-- reopen_learn_more: integer (nullable = true)
 |-- search_counts: array (nullable = true)
 |    |-- element: struct (containsNull = false)
 |    |    |-- engine: string (nullable = true)
 |    |    |-- source: string (nullable = true)
 |    |    |-- count: long (nullable = true)
 |-- active_addons: array (nullable = true)
 |    |-- element: struct (containsNull = false)
 |    |    |-- addon_id: string (nullable = false)
 |    |    |-- blocklisted: boolean (nullable = true)
 |    |    |-- name: string (nullable = true)
 |    |    |-- user_disabled: boolean (nullable = true)
 |    |    |-- app_disabled: boolean (nullable = true)
 |    |    |-- version: string (nullable = true)
 |    |    |-- scope: integer (nullable = true)
 |    |    |-- type: string (nullable = true)
 |    |    |-- foreign_install: boolean (nullable = true)
 |    |    |-- has_binary_components: boolean (nullable = true)
 |    |    |-- install_day: integer (nullable = true)
 |    |    |-- update_day: integer (nullable = true)
 |    |    |-- signed_state: integer (nullable = true)
 |    |    |-- is_system: boolean (nullable = true)
 |    |    |-- is_web_extension: boolean (nullable = true)
 |    |    |-- multiprocess_compatible: boolean (nullable = true)
 |-- disabled_addons_ids: array (nullable = true)
 |    |-- element: string (containsNull = false)
 |-- active_theme: struct (nullable = true)
 |    |-- addon_id: string (nullable = false)
 |    |-- blocklisted: boolean (nullable = true)
 |    |-- name: string (nullable = true)
 |    |-- user_disabled: boolean (nullable = true)
 |    |-- app_disabled: boolean (nullable = true)
 |    |-- version: string (nullable = true)
 |    |-- scope: integer (nullable = true)
 |    |-- type: string (nullable = true)
 |    |-- foreign_install: boolean (nullable = true)
 |    |-- has_binary_components: boolean (nullable = true)
 |    |-- install_day: integer (nullable = true)
 |    |-- update_day: integer (nullable = true)
 |    |-- signed_state: integer (nullable = true)
 |    |-- is_system: boolean (nullable = true)
 |    |-- is_web_extension: boolean (nullable = true)
 |    |-- multiprocess_compatible: boolean (nullable = true)
 |-- blocklist_enabled: boolean (nullable = true)
 |-- addon_compatibility_check_enabled: boolean (nullable = true)
 |-- telemetry_enabled: boolean (nullable = true)
 |-- user_prefs: struct (nullable = true)
 |    |-- dom_ipc_process_count: integer (nullable = true)
 |    |-- extensions_allow_non_mpc_extensions: boolean (nullable = true)
 |-- events: array (nullable = true)
 |    |-- element: struct (containsNull = false)
 |    |    |-- timestamp: long (nullable = false)
 |    |    |-- category: string (nullable = false)
 |    |    |-- method: string (nullable = false)
 |    |    |-- object: string (nullable = false)
 |    |    |-- string_value: string (nullable = true)
 |    |    |-- map_values: map (nullable = true)
 |    |    |    |-- key: string
 |    |    |    |-- value: string (valueContainsNull = true)
 |-- ssl_handshake_result_success: integer (nullable = true)
 |-- ssl_handshake_result_failure: integer (nullable = true)
 |-- ssl_handshake_result: map (nullable = true)
 |    |-- key: string
 |    |-- value: integer (valueContainsNull = true)
 |-- active_ticks: integer (nullable = true)
 |-- main: integer (nullable = true)
 |-- first_paint: integer (nullable = true)
 |-- session_restored: integer (nullable = true)
 |-- total_time: integer (nullable = true)
 |-- plugins_notification_shown: integer (nullable = true)
 |-- plugins_notification_user_action: struct (nullable = true)
 |    |-- allow_now: integer (nullable = true)
 |    |-- allow_always: integer (nullable = true)
 |    |-- block: integer (nullable = true)
 |-- plugins_infobar_shown: integer (nullable = true)
 |-- plugins_infobar_block: integer (nullable = true)
 |-- plugins_infobar_allow: integer (nullable = true)
 |-- plugins_infobar_dismissed: integer (nullable = true)
 |-- experiments: map (nullable = true)
 |    |-- key: string
 |    |-- value: string (valueContainsNull = true)
 |-- search_cohort: string (nullable = true)
 |-- gfx_compositor: string (nullable = true)
 |-- quantum_ready: boolean (nullable = true)
 |-- gc_max_pause_ms_main_above_150: long (nullable = true)
 |-- gc_max_pause_ms_main_above_250: long (nullable = true)
 |-- gc_max_pause_ms_main_above_2500: long (nullable = true)
 |-- gc_max_pause_ms_content_above_150: long (nullable = true)
 |-- gc_max_pause_ms_content_above_250: long (nullable = true)
 |-- gc_max_pause_ms_content_above_2500: long (nullable = true)
 |-- cycle_collector_max_pause_main_above_150: long (nullable = true)
 |-- cycle_collector_max_pause_main_above_250: long (nullable = true)
 |-- cycle_collector_max_pause_main_above_2500: long (nullable = true)
 |-- cycle_collector_max_pause_content_above_150: long (nullable = true)
 |-- cycle_collector_max_pause_content_above_250: long (nullable = true)
 |-- cycle_collector_max_pause_content_above_2500: long (nullable = true)
 |-- input_event_response_coalesced_ms_main_above_150: long (nullable = true)
 |-- input_event_response_coalesced_ms_main_above_250: long (nullable = true)
 |-- input_event_response_coalesced_ms_main_above_2500: long (nullable = true)
 |-- input_event_response_coalesced_ms_content_above_150: long (nullable = true)
 |-- input_event_response_coalesced_ms_content_above_250: long (nullable = true)
 |-- input_event_response_coalesced_ms_content_above_2500: long (nullable = true)
 |-- ghost_windows_main_above_1: long (nullable = true)
 |-- ghost_windows_content_above_1: long (nullable = true)
 |-- user_pref_dom_ipc_plugins_sandbox_level_flash: integer (nullable = true)
 |-- user_pref_dom_ipc_processcount: integer (nullable = true)
 |-- user_pref_extensions_allow_non_mpc_extensions: boolean (nullable = true)
 |-- user_pref_extensions_legacy_enabled: boolean (nullable = true)
 |-- user_pref_browser_search_widget_innavbar: boolean (nullable = true)
 |-- user_pref_general_config_filename: string (nullable = true)
 |-- ** dynamically included scalar fields, see source **
 |-- ** dynamically included whitelisted histograms, see source **
 |-- boolean_addon_scalars: map (nullable = true)
 |    |-- key: string
 |    |-- value: boolean (valueContainsNull = true)
 |-- keyed_boolean_addon_scalars: map (nullable = true)
 |    |-- key: string
 |    |-- value: map (valueContainsNull = true)
 |    |    |-- key: string
 |    |    |-- value: boolean (valueContainsNull = true)
 |-- string_addon_scalars: map (nullable = true)
 |    |-- key: string
 |    |-- value: string (valueContainsNull = true)
 |-- keyed_string_addon_scalars: map (nullable = true)
 |    |-- key: string
 |    |-- value: map (valueContainsNull = true)
 |    |    |-- key: string
 |    |    |-- value: string (valueContainsNull = true)
 |-- uint_addon_scalars: map (nullable = true)
 |    |-- key: string
 |    |-- value: integer (valueContainsNull = true)
 |-- keyed_uint_addon_scalars: map (nullable = true)
 |    |-- key: string
 |    |-- value: map (valueContainsNull = true)
 |    |    |-- key: string
 |    |    |-- value: integer (valueContainsNull = true)
 |-- submission_date_s3: string (nullable = true)
 |-- sample_id: string (nullable = true)
</code></pre>
<p>For more detail on where these fields come from in the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/main-ping.html">raw data</a>,
please look
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/MainSummaryView.scala">in the <code>MainSummaryView</code> code</a>.
in the <code>buildSchema</code> function.</p>
<p>Most of the fields are simple scalar values, with a few notable exceptions:</p>
<ul>
<li>The <code>search_count</code> field is an array of structs, each item in the array representing
a 3-tuple of (<code>engine</code>, <code>source</code>, <code>count</code>). The <code>engine</code> field represents the name of
the search engine against which the searches were done. The <code>source</code> field represents
the part of the Firefox UI that was used to perform the search. It contains values
such as <code>abouthome</code>, <code>urlbar</code>, and <code>searchbar</code>. The <code>count</code> field contains the number
of searches performed against this engine+source combination during that subsession.
Any of the fields in the struct may be null (for example if the search key did not
match the expected pattern, or if the count was non-numeric).</li>
<li>The <code>loop_activity_counter</code> field is a simple struct containing inner fields for each
expected value of the <code>LOOP_ACTIVITY_COUNTER</code> Enumerated Histogram. Each inner field
is a count for that histogram bucket.</li>
<li>The <code>popup_notification_stats</code> field is a map of <code>String</code> keys to struct values,
each field in the struct being a count for the expected values of the
<code>POPUP_NOTIFICATION_STATS</code> Keyed Enumerated Histogram.</li>
<li>The <code>places_bookmarks_count</code> and <code>places_pages_count</code> fields contain the <strong>mean</strong>
value of the corresponding Histogram, which can be interpreted as the average number
of bookmarks or pages in a given subsession.</li>
<li>The <code>active_addons</code> field contains an array of structs, one for each entry in
the <code>environment.addons.activeAddons</code> section of the payload. More detail in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1290181">Bug 1290181</a>.</li>
<li>The <code>disabled_addons_ids</code> field contains an array of strings, one for each entry in
the <code>payload.addonDetails</code> which is not already reported in the <code>environment.addons.activeAddons</code>
section of the payload. More detail in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1390814">Bug 1390814</a>.
Please note that while using this field is generally OK, this was introduced to support
the <a href="https://github.com/mozilla/taar/pulls">TAAR</a> project and you should not count on it
in the future. The field can stay in the <code>main_summary</code>, but we might need to slightly change
the ping structure to something better than <code>payload.addonDetails</code>.</li>
<li>The <code>theme</code> field contains a single struct in the same shape as the items in the
<code>active_addons</code> array. It contains information about the currently active browser
theme.</li>
<li>The <code>user_prefs</code> field contains a struct with values for preferences of interest.</li>
<li>The <code>events</code> field contains an array of event structs.</li>
<li>Dynamically-included histogram fields are present as key-&gt;value maps,
or key-&gt;(key-&gt;value) nested maps for keyed histograms.</li>
</ul>
<a class="header" href="#time-formats" id="time-formats"><h2>Time formats</h2></a>
<p>Columns in <code>main_summary</code> may use one of a handful of time formats with different precisions:</p>
<table><thead><tr><th>Column Name              </th><th> Origin                                   </th><th> Description                                  </th><th> Example                         </th><th> Spark                                                                    </th><th> Presto</th></tr></thead><tbody>
<tr><td><code>timestamp</code>              </td><td> stamped at ingestion                     </td><td> nanoseconds since epoch                      </td><td> <code>1504689165972861952</code>           </td><td> <code>from_unixtime(timestamp/1e9)</code>                                           </td><td> <code>from_unixtime(timestamp/1e9)</code></td></tr>
<tr><td><code>submission_date_s3</code>     </td><td> derived from timestamp                   </td><td> <code>YYYYMMDD</code> date string of timestamp          </td><td> <code>20170906</code>                      </td><td> <code>from_unixtime(unix_timestamp(submission_date, 'yyyyMMdd'))</code>             </td><td> <code>date_parse(submission_date, '%Y%m%d')</code></td></tr>
<tr><td><code>client_submission_date</code> </td><td> derived from HTTP header: <code>Fields[Date]</code> </td><td> HTTP date header string sent with the ping   </td><td> <code>Tue, 27 Sep 2016 16:28:23 GMT</code> </td><td> <code>unix_timestamp(client_submission_date, 'EEE, dd M yyyy HH:mm:ss zzz')</code>  </td><td> <code>date_parse(substr(client_submission_date, 1, 25), '%a, %d %b %Y %H:%i:%s')</code></td></tr>
<tr><td><code>creation_date</code>          </td><td> <code>creationDate</code>                           </td><td> time of ping creation ISO8601 at UTC+0       </td><td> <code>2017-09-06T08:21:36.002Z</code>      </td><td> <code>to_timestamp(creation_date, &quot;yyyy-MM-dd'T'HH:mm:ss.SSSXXX&quot;)</code>            </td><td> <code>from_iso8601_timestamp(creation_date) AT TIME ZONE 'GMT'</code></td></tr>
<tr><td><code>timezone_offset</code>        </td><td> <code>info.timezoneOffset</code>                    </td><td> timezone offset in minutes                   </td><td> <code>120</code>                           </td><td>                                                                          </td></tr>
<tr><td><code>subsession_start_date</code>  </td><td> <code>info.subsessionStartDate</code>               </td><td> hourly precision, ISO8601 date in local time </td><td> <code>2017-09-06T00:00:00.0+02:00</code>   </td><td>                                                                          </td><td> <code>from_iso8601_timestamp(subsession_start_date) AT TIME ZONE 'GMT'</code></td></tr>
<tr><td><code>subsession_length</code>      </td><td> <code>info.subsessionLength</code>                  </td><td> subsession length in seconds                 </td><td> <code>599</code>                           </td><td>                                                                          </td><td> <code>date_add('second', subsession_length, subsession_start_date)</code></td></tr>
<tr><td><code>profile_creation_date</code>  </td><td> <code>environment.profile.creationDate</code>       </td><td> days since epoch                             </td><td> <code>15,755</code>                        </td><td>                                                                          </td><td> <code>from_unixtime(profile_creation_date * 86400)</code></td></tr>
</tbody></table>
<a class="header" href="#code-reference-4" id="code-reference-4"><h1>Code Reference</h1></a>
<p>This dataset is generated by
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/MainSummaryView.scala">telemetry-batch-view</a>.
Refer to this repository for information on how to run or augment the dataset.</p>
<a class="header" href="#new-profile" id="new-profile"><h1>New Profile</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-15" id="introduction-15"><h1>Introduction</h1></a>
<p>The <code>telemetry_new_profile_parquet</code> table is the most direct representation of a new-profile ping.</p>
<a class="header" href="#contents-16" id="contents-16"><h4>Contents</h4></a>
<p>The table contains one row for each ping. Each column represents one field from the new-profile ping payload, though only a subset of all fields are included.</p>
<a class="header" href="#accessing-the-data-24" id="accessing-the-data-24"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://net-mozaws-prod-us-west-2-pipeline-data/telemetry-new-profile-parquet/v2/
</code></pre>
<p>The <code>telemetry_new_profile_parquet</code> is accessible through re:dash.
Here's an <a href="https://sql.telemetry.mozilla.org/queries/5888#table">example query</a>.</p>
<a class="header" href="#further-reading-14" id="further-reading-14"><h4>Further Reading</h4></a>
<p>This dataset is generated automatically using direct to parquet. The configuration responsible for generating this dataset was introduced in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1360256">bug 1360256</a>.</p>
<a class="header" href="#data-reference-11" id="data-reference-11"><h1>Data Reference</h1></a>
<a class="header" href="#schema-10" id="schema-10"><h2>Schema</h2></a>
<p>As of 2018-06-26, the current version of the <code>telemetry_new_profile_parquet</code> dataset is <code>v2</code>, and has a schema as follows:</p>
<pre><code>root
 |-- id: string (nullable = true)
 |-- client_id: string (nullable = true)
 |-- metadata: struct (nullable = true)
 |    |-- timestamp: long (nullable = true)
 |    |-- date: string (nullable = true)
 |    |-- normalized_channel: string (nullable = true)
 |    |-- geo_country: string (nullable = true)
 |    |-- geo_city: string (nullable = true)
 |    |-- geo_subdivision1: string (nullable = true)
 |    |-- geo_subdivision2: string (nullable = true)
 |    |-- creation_timestamp: long (nullable = true)
 |    |-- x_ping_sender_version: string (nullable = true)
 |-- environment: struct (nullable = true)
 |    |-- build: struct (nullable = true)
 |    |    |-- application_name: string (nullable = true)
 |    |    |-- architecture: string (nullable = true)
 |    |    |-- version: string (nullable = true)
 |    |    |-- build_id: string (nullable = true)
 |    |    |-- vendor: string (nullable = true)
 |    |    |-- hotfix_version: string (nullable = true)
 |    |-- partner: struct (nullable = true)
 |    |    |-- distribution_id: string (nullable = true)
 |    |    |-- distribution_version: string (nullable = true)
 |    |    |-- partner_id: string (nullable = true)
 |    |    |-- distributor: string (nullable = true)
 |    |    |-- distributor_channel: string (nullable = true)
 |    |    |-- partner_names: array (nullable = true)
 |    |    |    |-- element: string (containsNull = true)
 |    |-- settings: struct (nullable = true)
 |    |    |-- is_default_browser: boolean (nullable = true)
 |    |    |-- default_search_engine: string (nullable = true)
 |    |    |-- default_search_engine_data: struct (nullable = true)
 |    |    |    |-- name: string (nullable = true)
 |    |    |    |-- load_path: string (nullable = true)
 |    |    |    |-- origin: string (nullable = true)
 |    |    |    |-- submission_url: string (nullable = true)
 |    |    |-- telemetry_enabled: boolean (nullable = true)
 |    |    |-- locale: string (nullable = true)
 |    |    |-- attribution: struct (nullable = true)
 |    |    |    |-- source: string (nullable = true)
 |    |    |    |-- medium: string (nullable = true)
 |    |    |    |-- campaign: string (nullable = true)
 |    |    |    |-- content: string (nullable = true)
 |    |    |-- update: struct (nullable = true)
 |    |    |    |-- channel: string (nullable = true)
 |    |    |    |-- enabled: boolean (nullable = true)
 |    |    |    |-- auto_download: boolean (nullable = true)
 |    |-- system: struct (nullable = true)
 |    |    |-- os: struct (nullable = true)
 |    |    |    |-- name: string (nullable = true)
 |    |    |    |-- version: string (nullable = true)
 |    |    |    |-- locale: string (nullable = true)
 |    |-- profile: struct (nullable = true)
 |    |    |-- creation_date: long (nullable = true)
 |-- payload: struct (nullable = true)
 |    |-- reason: string (nullable = true)
 |-- submission: string (nullable = true)
</code></pre>
<p>For more detail on the raw ping these fields come from, see the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/new-profile-ping.html">raw data</a>.</p>
<a class="header" href="#a1-day-retention" id="a1-day-retention"><h1>1 Day Retention</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
<a class="header" href="#introduction-16" id="introduction-16"><h1>Introduction</h1></a>
<p>The <code>retention</code> table provides client counts relevant to client retention at a
1-day granularity. The project is tracked in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1381840">Bug 1381840</a></p>
<a class="header" href="#contents-17" id="contents-17"><h3>Contents</h3></a>
<p>The <code>retention</code> table contains a set of attribute columns used to specify a
cohort of users and a set of metric columns to describe cohort activity. Each
row contains a permutation of attributes, an approximate set of clients in a
cohort, and the aggregate engagement metrics.</p>
<p>This table uses the HyperLogLog (HLL) sketch to create an approximate set of
clients in a cohort. HLL allows counting across overlapping cohorts in a single
pass while avoiding the problem of double counting. This data-structure has the
benefit of being compact and performant in the context of retention analysis,
at the expense of precision. For example, calculating a 7-day retention period
can be obtained by aggregating over a week of retention data using the union
operation. With SQL primitive, this requires a recalculation of COUNT DISTINCT
over <code>client_id</code>'s in the 7-day window.</p>
<a class="header" href="#background-and-caveats-14" id="background-and-caveats-14"><h4>Background and Caveats</h4></a>
<ol>
<li>The data starts at 2017-03-06, the <a href="https://wiki.mozilla.org/RapidRelease/Calendar">merge date where Nightly started to
track Firefox 55 in Mozilla-Central</a>. However, there was
not a consistent view into the behavior of first session profiles until the
<a href="../new_profile/reference.html"><code>new_profile</code> ping</a>. This means much of the data is inaccurate
before 2017-06-26.</li>
<li>This dataset uses 4 day reporting latency to aggregate at least 99% of the
data in a given submission date. This figure is derived from the
<a href="https://sql.telemetry.mozilla.org/dashboard/telemetry-health">telemetry-health measurements on submission latency</a>, with
the discussion in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1407410">Bug 1407410</a>. This latency metric was reduced
Firefox 55 with the introduction of the shutdown ping-sender mechanism.</li>
<li>Caution should be taken before adding new columns. Additional attribute
columns will grow the number of rows exponentially.</li>
<li>The number of HLL bits chosen for this dataset is 13. This means the default
size of the HLL object is 2^13 bits or 1KiB. This maintains about a 1% error
on average. See <a href="https://github.com/twitter/algebird/blob/develop/algebird-core/src/main/scala/com/twitter/algebird/HyperLogLog.scala#L230-L255">this table from Algebird's HLL implementation</a> for
more details.</li>
</ol>
<a class="header" href="#accessing-the-data-25" id="accessing-the-data-25"><h4>Accessing the Data</h4></a>
<p>The data is primarily available through <a href="https://sql.telemetry.mozilla.org">Re:dash on STMO</a> via
the Presto source. This service has been configured to use predefined HLL
functions.</p>
<p>The column should first be cast to the HLL type. The scalar
<code>cardinality(&lt;hll_column&gt;)</code> function will approximate the number of unique
items per HLL object. The aggregate <code>merge(&lt;hll_column&gt;)</code> function will perform
the set union between all objects in a column.</p>
<p>Example: Cast the count column into the appropriate type.</p>
<pre><code class="language-sql">SELECT cast(hll as HLL) as n_profiles_hll FROM retention
</code></pre>
<p>Count the number of clients seen over all attribute combinations.</p>
<pre><code class="language-sql">SELECT cardinality(cast(hll as HLL)) FROM retention
</code></pre>
<p>Group-by and aggregate client counts over different release channels.</p>
<pre><code class="language-sql">SELECT channel, cardinality(merge(cast(hll AS HLL))
FROM retention
GROUP BY channel
</code></pre>
<p>The HyperLogLog library wrappers are available for use outside of the
configured STMO environment, <a href="https://github.com/mozilla/spark-hyperloglog"><code>spark-hyperloglog</code></a> and
<a href="https://github.com/vitillo/presto-hyperloglog"><code>presto-hyperloglog</code></a>.</p>
<p>Also see the <a href="../client_count_daily/reference.html"><code>client_count_daily</code> dataset</a>.</p>
<a class="header" href="#data-reference-12" id="data-reference-12"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-11" id="example-queries-11"><h2>Example Queries</h2></a>
<p>See the <a href="https://sql.telemetry.mozilla.org/dashboard/firefox-telemetry-retention-dataset-example-usage">Example Usage Dashboard</a> for more usages of datasets of
the same shape.</p>
<a class="header" href="#scheduling-10" id="scheduling-10"><h2>Scheduling</h2></a>
<p>The job is scheduled on Airflow on a daily basis after <code>main_summary</code> is run
for the day. This job requires both <code>mozetl</code> and <code>telemetry-batch-view</code> as
dependencies.</p>
<a class="header" href="#schema-11" id="schema-11"><h2>Schema</h2></a>
<p>As of 2017-10-10, the current version of <code>retention</code> is <code>v1</code> and has a schema
as follows:</p>
<pre><code>root
 |-- subsession_start: string (nullable = true)
 |-- profile_creation: string (nullable = true)
 |-- days_since_creation: long (nullable = true)
 |-- channel: string (nullable = true)
 |-- app_version: string (nullable = true)
 |-- geo: string (nullable = true)
 |-- distribution_id: string (nullable = true)
 |-- is_funnelcake: boolean (nullable = true)
 |-- source: string (nullable = true)
 |-- medium: string (nullable = true)
 |-- content: string (nullable = true)
 |-- sync_usage: string (nullable = true)
 |-- is_active: boolean (nullable = true)
 |-- hll: binary (nullable = true)
 |-- usage_hours: double (nullable = true)
 |-- sum_squared_usage_hours: double (nullable = true)
 |-- total_uri_count: long (nullable = true)
 |-- unique_domains_count: double (nullable = true)
</code></pre>
<a class="header" href="#code-reference-5" id="code-reference-5"><h1>Code Reference</h1></a>
<p>The ETL script for processing the data before aggregation is found in
<a href="https://github.com/mozilla/python_mozetl/blob/master/mozetl/engagement/retention/job.py"><code>mozetl.engagement.retention</code></a>. The aggregate job is found in
<a href="https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/RetentionView.scala">telemetry-batch-view</a> as the <code>RetentionView</code>.</p>
<p>The <a href="https://github.com/acmiyaguchi/telemetry-airflow/blob/1b4b11d23cdd1191ed2d2be905f116d7c3c67533/jobs/retention.sh">runner script</a> performs all the necessary setup to run on
EMR. This script can be used to perform backfill.</p>
<a class="header" href="#socorro-crash-reports" id="socorro-crash-reports"><h1>Socorro Crash Reports</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a></li>
</ul>
<a class="header" href="#introduction-17" id="introduction-17"><h2>Introduction</h2></a>
<p>Public crash statistics for Firefox are available through the Data Platform in a <code>socorro_crash</code> dataset.
The crash data in <a href="https://wiki.mozilla.org/Socorro">Socorro</a> is sanitized and made available to ATMO and STMO.
A nightly import job converts batches of JSON documents into a columnar format using the associated JSON Schema.</p>
<a class="header" href="#contents-18" id="contents-18"><h3>Contents</h3></a>
<a class="header" href="#accessing-the-data-26" id="accessing-the-data-26"><h4>Accessing the Data</h4></a>
<p>The dataset is available in parquet at <code>s3://telemetry-parquet/socorro_crash/v2</code>.
It is also indexed with Athena and Presto with the table name <code>socorro_crash</code>.</p>
<a class="header" href="#data-reference-13" id="data-reference-13"><h2>Data Reference</h2></a>
<a class="header" href="#example" id="example"><h3>Example</h3></a>
<p>The dataset can be queried using SQL.
For example, we can aggregate the number of crashes and total up-time by date and reason.</p>
<pre><code class="language-sql">SELECT crash_date,
       reason,
       count(*) as n_crashes,
       avg(uptime) as avg_uptime,
       stddev(uptime) as stddev_uptime,
       approx_percentile(uptime, ARRAY [0.25, 0.5, 0.75]) as qntl_uptime
FROM socorro_crash
WHERE crash_date='20180520'
GROUP BY 1,
         2
</code></pre>
<p><a href="https://sql.telemetry.mozilla.org/queries/53884/source">STMO Source</a></p>
<a class="header" href="#scheduling-11" id="scheduling-11"><h3>Scheduling</h3></a>
<p>The job is schedule on a nightly basis on airflow.
The dag is available under <a href="https://github.com/mozilla/telemetry-airflow/blob/930790116d8d5c924cd61a07311fc8a34340f3d6/dags/socorro_import.py"><code>mozilla/telemetry-airflow:/dags/socorro_import.py</code></a>.</p>
<a class="header" href="#schema-12" id="schema-12"><h3>Schema</h3></a>
<p>The source schema is available on the <a href="https://raw.githubusercontent.com/mozilla/socorro/master/socorro/schemas/crash_report.json"><code>mozilla/socorro</code> GitHub repository</a>.
This schema is transformed into a Spark-SQL structure and serialized to parquet after transforming column names from <code>camelCase</code> to <code>snake_case</code>.</p>
<a class="header" href="#code-reference-6" id="code-reference-6"><h3>Code Reference</h3></a>
<p>The code is <a href="https://github.com/mozilla-services/data-pipeline/blob/master/reports/socorro_import/ImportCrashData.ipynb">a notebook in the <code>mozilla-services/data-pipeline</code> repository</a>.</p>
<a class="header" href="#ssl-ratios" id="ssl-ratios"><h1>SSL Ratios</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#combining-rows">Combining Rows</a></li>
<li><a href="#schema">Schema</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-18" id="introduction-18"><h1>Introduction</h1></a>
<p>The public SSL dataset publishes the percentage of page loads Firefox users have performed
that were conducted over SSL. This dataset is used to produce graphs like
<a href="https://letsencrypt.org/stats/">Let's Encrypt's</a> to determine SSL adoption on the Web
over time.</p>
<a class="header" href="#content-4" id="content-4"><h4>Content</h4></a>
<p>The public SSL dataset is a table where each row is a distinct set of dimensions, with their
associated SSL statistics. The dimensions are <code>submission_date</code>, <code>os</code>, and <code>country</code>. The
statistics are <code>reporting_ratio</code>, <code>normalized_pageloads</code>, and <code>ratio</code>.</p>
<a class="header" href="#background-and-caveats-15" id="background-and-caveats-15"><h4>Background and Caveats</h4></a>
<ul>
<li>We're using normalized values in <code>normalized_pageloads</code> to obscure absolute page load counts.</li>
<li>This is across the entirety of release, not per-version, because we're looking at Web health,
not Firefox user health.</li>
<li>Any dimension tuple (any given combination of <code>submission_date</code>, <code>os</code>, and <code>country</code>) with
fewer than 5000 page loads is omitted from the dataset.</li>
<li>This is hopefully just a temporary dataset to stopgap release aggregates going away
until we can come up with a better way to publicly publish datasets.</li>
</ul>
<a class="header" href="#accessing-the-data-27" id="accessing-the-data-27"><h4>Accessing the Data</h4></a>
<p>For details on accessing the data, please look at
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1414839">bug 1414839</a>.</p>
<a class="header" href="#data-reference-14" id="data-reference-14"><h1>Data Reference</h1></a>
<a class="header" href="#combining-rows" id="combining-rows"><h2>Combining Rows</h2></a>
<p>This is a dataset of ratios. You can't combine ratios if they have different bases. For example,
if 50% of 10 loads (5 loads) were SSL and 5% of 20 loads (1 load) were SSL, you cannot calculate
that 20% (6 loads) of the total loads (30 loads) were SSL unless you know that the 50% was for
10 and the 5% was for 20.</p>
<p>If you're reluctant, for product reasons, to share the numbers 10 and 20, this gets tricky.</p>
<p>So what we've done is normalize the whole batch of 30 down to 1. That means we tell you that
50% of one-third of the loads (0.333...) was SSL and 5% of the other two-thirds of the loads
(0.666...) was SSL. Then you can figure out the overall 20% figure by this calculation:</p>
<p><code>0.5 * 0.333 + 0.05 * 0.666 = 0.2</code></p>
<p>For this dataset the same rule applies. To combine rows' ratios (to, for example, see what the
SSL ratio was across all <code>os</code> and <code>country</code> for a given <code>submission_date</code>), you must first
multiply them by the rows' <code>normalized_pageviews</code> values.</p>
<p>Or, in JavaScript:</p>
<pre><code class="language-js">let rows = query_result.data.rows;
let ratioForDateInQuestion = rows
  .filter(row =&gt; row.submission_date == dateInQuestion)
  .reduce((row, acc) =&gt; acc + row.normalized_pageloads * row.ratio, 0);
</code></pre>
<a class="header" href="#schema-13" id="schema-13"><h2>Schema</h2></a>
<p>The data is output in re:dash API format:</p>
<pre><code>&quot;query_result&quot;: {
  &quot;retrieved_at&quot;: &lt;timestamp&gt;,
  &quot;query_hash&quot;: &lt;hash&gt;,
  &quot;query&quot;: &lt;SQL&gt;,
  &quot;runtime&quot;: &lt;number of seconds&gt;,
  &quot;id&quot;: &lt;an id&gt;,
  &quot;data_source_id&quot;: 26, // Athena
  &quot;data_scanned&quot;: &lt;some really large number, as a string&gt;,
  &quot;data&quot;: {
    &quot;data_scanned&quot;: &lt;some really large number, as a number&gt;,
    &quot;columns&quot;: [
      {&quot;friendly_name&quot;: &quot;submission_date&quot;, &quot;type&quot;: &quot;datetime&quot;, &quot;name&quot;: &quot;submission_date&quot;},
      {&quot;friendly_name&quot;: &quot;os&quot;, &quot;type&quot;: &quot;string&quot;, &quot;name&quot;: &quot;os&quot;},
      {&quot;friendly_name&quot;: &quot;country&quot;, &quot;type&quot;: &quot;string&quot;, &quot;name&quot;: &quot;country&quot;},
      {&quot;friendly_name&quot;: &quot;reporting_ratio&quot;, &quot;type&quot;: &quot;float&quot;, &quot;name&quot;: &quot;reporting_ratio&quot;},
      {&quot;friendly_name&quot;: &quot;normalized_pageloads&quot;, &quot;type&quot;: &quot;float&quot;, &quot;name&quot;: &quot;normalized_pageloads&quot;},
      {&quot;friendly_name&quot;: &quot;ratio&quot;, &quot;type&quot;: &quot;float&quot;, &quot;name&quot;: &quot;ratio&quot;}
    ],
    &quot;rows&quot;: [
      {
        &quot;submission_date&quot;: &quot;2017-10-24T00:00:00&quot;, // date string, day resolution
        &quot;os&quot;: &quot;Windows_NT&quot;, // operating system family of the clients reporting the pageloads. One of &quot;Windows_NT&quot;, &quot;Linux&quot;, or &quot;Darwin&quot;.
        &quot;country&quot;: &quot;CZ&quot;, // ISO 639 two-character country code, or &quot;??&quot; if we have no idea. Determined by performing a geo-IP lookup of the clients that submitted the pings.
        &quot;reporting_ratio&quot;: 0.006825266611977031, // the ratio of pings that reported any pageloads at all. A number between 0 and 1. See [bug 1413258](https://bugzilla.mozilla.org/show_bug.cgi?id=1413258).
        &quot;normalized_pageloads&quot;: 0.00001759145263985348, // the proportion of total pageloads in the dataset that are represented by this row. Provided to allow combining rows. A number between 0 and 1.
        &quot;ratio&quot;: 0.6916961976822144 // the ratio of the pageloads that were performed over SSL. A number between 0 and 1.
      }, ...
    ]
  }
}
</code></pre>
<a class="header" href="#scheduling-12" id="scheduling-12"><h2>Scheduling</h2></a>
<p>The dataset updates every 24 hours.</p>
<a class="header" href="#code-reference-7" id="code-reference-7"><h2>Code Reference</h2></a>
<p>You can find the query that generates the SSL dataset
<a href="https://sql.telemetry.mozilla.org/queries/49323/source#table">here</a>.</p>
<a class="header" href="#sync-summary-reference" id="sync-summary-reference"><h1>Sync Summary Reference</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#sampling">Sampling</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-19" id="introduction-19"><h1>Introduction</h1></a>
<p>Work in progress.
Work is being tracked
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364171">here</a>.</p>
<a class="header" href="#data-reference-15" id="data-reference-15"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-12" id="example-queries-12"><h2>Example Queries</h2></a>
<p>Work in progress.
Work is being tracked
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364171">here</a></p>
<a class="header" href="#sampling-8" id="sampling-8"><h2>Sampling</h2></a>
<p>Work in progress.
Work is being tracked
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1364171">here</a></p>
<a class="header" href="#scheduling-13" id="scheduling-13"><h2>Scheduling</h2></a>
<p>This dataset is updated daily, shortly after midnight UTC.
The job is scheduled on <a href="https://github.com/mozilla/telemetry-airflow">Airflow</a>.
The DAG is <a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/sync_view.py">here</a>.</p>
<a class="header" href="#schema-14" id="schema-14"><h2>Schema</h2></a>
<pre><code>root
 |-- app_build_id: string (nullable = true)
 |-- app_display_version: string (nullable = true)
 |-- app_name: string (nullable = true)
 |-- app_version: string (nullable = true)
 |-- app_channel: string (nullable = true)
 |-- uid: string
 |-- device_id: string (nullable = true)
 |-- when: integer
 |-- took: integer
 |-- why: string (nullable = true)
 |-- failure_reason: struct (nullable = true)
 |    |-- name: string
 |    |-- value: string (nullable = true)
 |-- status: struct (nullable = true)
 |    |-- sync: string (nullable = true)
 |    |-- status: string (nullable = true)
 |-- devices: array (nullable = true)
 |    |-- element: struct (containsNull = false)
 |    |    |-- id: string
 |    |    |-- os: string
 |    |    |-- version: string
 |-- engines: array (nullable = true)
 |    |-- element: struct (containsNull = false)
 |    |    |-- name: string
 |    |    |-- took: integer
 |    |    |-- status: string (nullable = true)
 |    |    |-- failure_reason: struct (nullable = true)
 |    |    |    |-- name: string
 |    |    |    |-- value: string (nullable = true)
 |    |    |-- incoming: struct (nullable = true)
 |    |    |    |-- applied: integer
 |    |    |    |-- failed: integer
 |    |    |    |-- new_failed: integer
 |    |    |    |-- reconciled: integer
 |    |    |-- outgoing: array (nullable = true)
 |    |    |    |-- element: struct (containsNull = false)
 |    |    |    |    |-- sent: integer
 |    |    |    |    |-- failed: integer
 |    |    |-- validation: struct (containsNull = false)
 |    |    |    |-- version: integer
 |    |    |    |-- checked: integer
 |    |    |    |-- took: integer
 |    |    |    |-- failure_reason: struct (nullable = true)
 |    |    |    |    |-- name: string
 |    |    |    |    |-- value: string (nullable = true)
 |    |    |    |-- problems: array (nullable = true)
 |    |    |    |    |-- element: struct (containsNull = false)
 |    |    |    |    |    |-- name: string
 |    |    |    |    |    |-- count: integer
</code></pre>
<a class="header" href="#update" id="update"><h1>Update</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-20" id="introduction-20"><h1>Introduction</h1></a>
<p>The <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/update-ping.html">update ping</a>
is sent from Firefox Desktop when a browser update is ready to be applied and after it was correctly applied.
It contains the build information and the update blob information, in addition to some information about the
user environment.
The <code>telemetry_update_parquet</code> table is the most direct representation of an update ping.</p>
<a class="header" href="#contents-19" id="contents-19"><h4>Contents</h4></a>
<p>The table contains one row for each ping. Each column represents one field from the update ping payload, though only a subset of all fields are included.</p>
<a class="header" href="#accessing-the-data-28" id="accessing-the-data-28"><h4>Accessing the Data</h4></a>
<p>The data is stored as a parquet table in S3 at the following address.
See <a href="../../../cookbooks/parquet.html">this cookbook</a> to get started working with the data in Spark.</p>
<pre><code>s3://net-mozaws-prod-us-west-2-pipeline-data/telemetry-update-parquet/v1/
</code></pre>
<p>The <code>telemetry_update_parquet</code> is accessible through re:dash.
Here's an <a href="https://sql.telemetry.mozilla.org/queries/31267#table">example query</a>.</p>
<a class="header" href="#further-reading-15" id="further-reading-15"><h4>Further Reading</h4></a>
<p>This dataset is generated automatically using direct to parquet. The configuration responsible for generating this dataset was introduced in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1384861">bug 1384861</a>.</p>
<a class="header" href="#data-reference-16" id="data-reference-16"><h1>Data Reference</h1></a>
<a class="header" href="#schema-15" id="schema-15"><h2>Schema</h2></a>
<p>As of 2017-09-07, the current version of the <code>telemetry_update_parquet</code> dataset is <code>v1</code>, and has a schema as follows:</p>
<pre><code>root
 |-- id: string (nullable = true)
 |-- client_id: string (nullable = true)
 |-- metadata: struct (nullable = true)
 |    |-- timestamp: long (nullable = true)
 |    |-- date: string (nullable = true)
 |    |-- normalized_channel: string (nullable = true)
 |    |-- geo_country: string (nullable = true)
 |    |-- geo_city: string (nullable = true)
 |    |-- creation_timestamp: long (nullable = true)
 |    |-- x_ping_sender_version: string (nullable = true)
 |-- application: struct (nullable = true)
 |    |-- displayVersion: string (nullable = true)
 |-- environment: struct (nullable = true)
 |    |-- build: struct (nullable = true)
 |    |    |-- application_name: string (nullable = true)
 |    |    |-- architecture: string (nullable = true)
 |    |    |-- version: string (nullable = true)
 |    |    |-- build_id: string (nullable = true)
 |    |    |-- vendor: string (nullable = true)
 |    |    |-- hotfix_version: string (nullable = true)
 |    |-- partner: struct (nullable = true)
 |    |    |-- distribution_id: string (nullable = true)
 |    |    |-- distribution_version: string (nullable = true)
 |    |    |-- partner_id: string (nullable = true)
 |    |    |-- distributor: string (nullable = true)
 |    |    |-- distributor_channel: string (nullable = true)
 |    |    |-- partner_names: array (nullable = true)
 |    |    |    |-- element: string (containsNull = true)
 |    |-- settings: struct (nullable = true)
 |    |    |-- telemetry_enabled: boolean (nullable = true)
 |    |    |-- locale: string (nullable = true)
 |    |    |-- update: struct (nullable = true)
 |    |    |    |-- channel: string (nullable = true)
 |    |    |    |-- enabled: boolean (nullable = true)
 |    |    |    |-- auto_download: boolean (nullable = true)
 |    |-- system: struct (nullable = true)
 |    |    |-- os: struct (nullable = true)
 |    |    |    |-- name: string (nullable = true)
 |    |    |    |-- version: string (nullable = true)
 |    |    |    |-- locale: string (nullable = true)
 |    |-- profile: struct (nullable = true)
 |    |    |-- creation_date: long (nullable = true)
 |-- payload: struct (nullable = true)
 |    |-- reason: string (nullable = true)
 |    |-- target_channel: string (nullable = true)
 |    |-- target_version: string (nullable = true)
 |    |-- target_build_id: string (nullable = true)
 |    |-- target_display_version: string (nullable = true)
 |    |-- previous_channel: string (nullable = true)
 |    |-- previous_version: string (nullable = true)
 |    |-- previous_build_id: string (nullable = true)
 |-- submission_date_s3: string (nullable = true)
</code></pre>
<p>For more detail on the raw ping these fields come from, see the
<a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/update-ping.html">raw data</a>.</p>
<a class="header" href="#work-in-progress" id="work-in-progress"><h1>Work in Progress</h1></a>
<p>This article is a work in progress.
The work is being tracked in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1341812">this bug</a>.</p>
<a class="header" href="#guide-to-our-experimental-tools" id="guide-to-our-experimental-tools"><h1>Guide to our Experimental Tools</h1></a>
<a class="header" href="#shield" id="shield"><h2>Shield</h2></a>
<ul>
<li>Shield is an addon-based experimentation platform with fine-tuned enrollment criteria. The system add-on landed in FF 53.</li>
<li>For the moment, it sends back data in its own <code>shield</code> type ping, so there's lots of flexibility in data you can collect.</li>
<li>Uses the Normandy server to serve out study “recipes” (?)</li>
<li>Annotates the main ping in the environment/experiments block</li>
<li>The shield system is itself a system add-on, so rolling out changes to the entire system does not require riding release trains</li>
<li>Strategy and Insights (strategyandinsights@mozilla.com) team are product owners and shepherd the study development and release process along</li>
<li>Opt-out experiments should be available soon?</li>
<li>Further reading:
<ul>
<li>https://wiki.mozilla.org/Firefox/SHIELD</li>
<li>https://wiki.mozilla.org/Firefox/Shield/Shield_Studies</li>
<li><a href="BROKEN:https://mozilla.github.io/shield-studies-docs/study-process/">https://mozilla.github.io/shield-studies-docs/study-process/</a></li>
<li>When should you use SHIELD over other options?</li>
</ul>
</li>
</ul>
<a class="header" href="#preference-flipping-experiments" id="preference-flipping-experiments"><h2>Preference Flipping experiments</h2></a>
<p>Uses Normandy, requires NO additional addon as long as a preference rides the release train</p>
<a class="header" href="#heartbeat" id="heartbeat"><h2>Heartbeat</h2></a>
<p>Survey mechanism, also run via Normandy</p>
<a class="header" href="#telemetry-experiments" id="telemetry-experiments"><h2>Telemetry Experiments</h2></a>
<p>Pre-release only
<a href="BROKEN:https://gecko.readthedocs.io/en/latest/browser/experiments/experiments/index.html">https://gecko.readthedocs.io/en/latest/browser/experiments/experiments/index.html</a></p>
<a class="header" href="#funnelcake" id="funnelcake"><h2>Funnelcake</h2></a>
<p>Custom builds of Firefox that are served to some percentage of the direct download population</p>
<a class="header" href="#work-in-progress-1" id="work-in-progress-1"><h1>Work in Progress</h1></a>
<p>This document is a work in progress.
The work is being tracked in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1358286">this bug</a></p>
<a class="header" href="#search-data" id="search-data"><h1>Search Data</h1></a>
<a class="header" href="#introduction-21" id="introduction-21"><h2>Introduction</h2></a>
<p>This article introduces the datasets we maintain for search analyses.
After reading this article,
you should understand the search datasets well enough to produce moderately complex analyses.</p>
<a class="header" href="#table-of-contents-4" id="table-of-contents-4"><h2>Table of Contents</h2></a>
<ul>
<li><a href="#permissions">Permissions</a></li>
<li><a href="#terminology">Terminology</a>
<ul>
<li><a href="#direct-vs-follow-on-search">Direct vs Follow-on Search</a></li>
<li><a href="#tagged-vs-untagged-searches">Tagged vs Untagged Searches</a></li>
</ul>
</li>
<li><a href="#standard-search-aggregates">Standard Search Aggregates</a>
<ul>
<li><a href="#outlier-filtering">Outlier Filtering</a></li>
</ul>
</li>
<li><a href="#in-content-telemetry-issues">In Content Telemetry Issues</a>
<ul>
<li><a href="#relies-on-whitelists">Relies on whitelists</a></li>
<li><a href="#addon-uptake">Addon uptake</a></li>
<li><a href="#limited-historical-data">Limited historical data</a></li>
</ul>
</li>
</ul>
<a class="header" href="#permissions" id="permissions"><h1>Permissions</h1></a>
<p>Access to both <code>search_aggregates</code> and <code>search_clients_daily</code>
is heavily restricted in re:dash.
We also maintain a restricted group for search on Github and Bugzilla.
If you reach a 404 on Github or don't have access to a re:dash query or bug
this is likely your issue.
To get access permissions, file a bug using the <a href="https://bugzilla.mozilla.org/enter_bug.cgi?assigned_to=rharter%40mozilla.com&amp;bug_file_loc=http%3A%2F%2F&amp;bug_ignored=0&amp;bug_severity=normal&amp;bug_status=NEW&amp;cf_fx_iteration=---&amp;cf_fx_points=---&amp;comment=Please%20add%20the%20following%20user%20to%20the%20Search%20group%3A%0D%0A%0D%0AMozilla%20email%20address%3A%0D%0AGithub%20handle%3A&amp;component=Datasets%3A%20Search&amp;contenttypemethod=autodetect&amp;contenttypeselection=text%2Fplain&amp;defined_groups=1&amp;flag_type-4=X&amp;flag_type-607=X&amp;flag_type-800=X&amp;flag_type-803=X&amp;flag_type-916=X&amp;form_name=enter_bug&amp;maketemplate=Remember%20values%20as%20bookmarkable%20template&amp;op_sys=Linux&amp;priority=--&amp;product=Data%20Platform%20and%20Tools&amp;rep_platform=x86_64&amp;short_desc=Add%20user%20to%20search%20user%20groups&amp;target_milestone=---&amp;version=unspecified">search permissions template</a></p>
<p>Once you have proper permissions,
you'll have access to a new source in re:dash called <code>Presto Search</code>.
<strong>You will not be able to access any of the search datasets
via the standard <code>Presto</code> data source</strong>, even with proper permissions.</p>
<a class="header" href="#terminology-1" id="terminology-1"><h1>Terminology</h1></a>
<a class="header" href="#direct-vs-follow-on-search" id="direct-vs-follow-on-search"><h2>Direct vs Follow-on Search</h2></a>
<p>Searches can be split into two major classes: <em>direct</em> and <em>follow-on</em>.</p>
<p>Direct searches result from a direct interaction with a <code>search access point</code> (SAP),
which is part of the Firefox UI.
These searches are often called SAP searches.
There are currently 6 SAPs:</p>
<ul>
<li><code>urlbar</code> - entering a search query in the Awesomebar</li>
<li><code>searchbar</code> - the main search bar; not present by default for new profiles on Firefox 57+</li>
<li><code>newtab</code> - the search bar on the <code>about:newtab</code> page</li>
<li><code>abouthome</code> - the search bar on the <code>about:home</code> page</li>
<li><code>contextmenu</code> - selecting text and clicking &quot;Search&quot; from the context menu</li>
<li><code>system</code> - starting Firefox from the command line with an option that immediately makes a search</li>
</ul>
<p>Users will often interact with the Search Engine Results Page (SERP)
to create &quot;downstream&quot; queries.
These queries are called <code>follow-on queries</code>.
These are sometimes also referred to as <strong>in-content queries</strong>
since they are initiated from the content of the page itself
and not from the Firefox UI.</p>
<p>For example, follow-on queries can be caused by:</p>
<ul>
<li>Revising a query (<code>restaurants</code> becomes <code>restaurants near me</code>)</li>
<li>Clicking on the &quot;next&quot; button</li>
<li>Accepting spelling suggestions</li>
</ul>
<a class="header" href="#tagged-vs-untagged-searches" id="tagged-vs-untagged-searches"><h2>Tagged vs Untagged Searches</h2></a>
<p>Our partners (search engines) attribute queries to Mozilla using <strong>partner codes</strong>.
When a user issues a query through one of our SAPs,
we include our partner code in the URL of the resulting search.</p>
<p><strong>Tagged queries</strong> are queries that <strong>include one of our partner codes</strong>.</p>
<p><strong>Untagged queries</strong> are queries that <strong>do not include one of our partner codes</strong>.
If a query is untagged,
it's usually because we do not have a partner deal for that search engine and region.</p>
<p>If an SAP query is tagged, any follow-on query should also be tagged.</p>
<a class="header" href="#standard-search-aggregates" id="standard-search-aggregates"><h1>Standard Search Aggregates</h1></a>
<p>We report three types of searches in our search datasets:
<code>SAP</code>, <code>tagged-sap</code>, and <code>tagged-follow-on</code>.
These aggregates show up as columns in the
<code>search_aggregates</code> and <code>search_clients_daily</code> datasets.
Our search datasets are all derived from <code>main_summary</code>.
The aggregate columns are derived from the <code>SEARCH_COUNTS</code> histogram.</p>
<p>The <strong><code>SAP</code> column counts all SAP (or direct) searches</strong>.
<code>SAP</code> search counts are collected via
<a href="https://firefox-source-docs.mozilla.org/browser/browser/BrowserUsageTelemetry.html#search-telemetry">probes</a>
within the Firefox UI
These counts are <strong>very reliable, but do not count follow-on queries</strong>.</p>
<p>In 2017-06 we deployed the [<code>followonsearch</code> addon],
which adds probes for <code>tagged-sap</code> and <code>tagged-follow-on</code> searches.
These columns <strong>attempt to count all tagged searches</strong>
by looking for Mozilla partner codes in the URL of requests to partner search engines.
These search counts are critical to understanding revenue
since they exclude untagged searches and include follow-on searches.
However, these search counts have <strong>important caveats affecting their reliability</strong>.
See <a href="#in-content-telemetry-issues">In Content Telemetry Issues</a> for more information.</p>
<p>In <code>main_summary</code>, all of these searches are stored in <code>search_counts.count</code>,
<strong>which makes it easy to over count searches</strong>.
Avoid using <code>main_summary</code> for search analyses.</p>
<a class="header" href="#outlier-filtering" id="outlier-filtering"><h2>Outlier Filtering</h2></a>
<p>We remove search count observations representing more than
10,000 searches for a single search engine in a single ping.</p>
<a class="header" href="#in-content-telemetry-issues" id="in-content-telemetry-issues"><h1>In Content Telemetry Issues</h1></a>
<p>The [<code>followonsearch</code> addon] implements the probe
used to measure <code>tagged-sap</code> and <code>tagged-follow-on</code> searches.
This probe is critical to understanding our revenue.
It's the only tool that gives us a view of follow-on searches
and differentiates between tagged and untagged queries.
However, it comes with some notable caveats.</p>
<a class="header" href="#relies-on-whitelists" id="relies-on-whitelists"><h2>Relies on whitelists</h2></a>
<p>The [<code>followonsearch</code> addon] attempts to count all tagged searches
by looking for Mozilla partner codes in the URL of requests to partner search engines.
To do this, the addon relies on a whitelist of partner codes and URL formats.
The list of partner codes is incomplete and only covers a few top partners.
These codes also occasionally change so there will be gaps in the data.</p>
<p>Additionally, changes to search engine URL formats can cause problems with our data collection.
See
<a href="https://sql.telemetry.mozilla.org/queries/47631/source#128887">this query</a>
for a notable example.</p>
<a class="header" href="#addon-uptake" id="addon-uptake"><h2>Addon uptake</h2></a>
<p>This probe is shipped as an addon.
Versions 55 and greater have the addon installed by default
(<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1369028">Bug</a>).
The addon was deployed to older versions of Firefox via GoFaster,
but uptake is not 100%.</p>
<a class="header" href="#limited-historical-data" id="limited-historical-data"><h2>Limited historical data</h2></a>
<p>The addon was first deployed in 2017-06.
There is no <code>tagged-*</code> search data available before this.</p>
<a class="header" href="#search-aggregates" id="search-aggregates"><h1>Search Aggregates</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
<a class="header" href="#introduction-22" id="introduction-22"><h1>Introduction</h1></a>
<p><code>search_aggregates</code> is designed to power high level search dashboards.
It's quick and easy to query, but the data are coarse.
In particular, this dataset allows you to segment
by a limited number of client characteristics which are relevant to search markets.
However, it is not possible to normalize by client count.
If you need fine-grained data, consider using <code>search_clients_daily</code>
which breaks down search counts by client</p>
<a class="header" href="#contents-20" id="contents-20"><h4>Contents</h4></a>
<p>Each row of <code>search_aggregates</code> contains
the standard search count aggregations
for each unique combination of the following columns.
Unless otherwise noted, these columns are taken directly from <code>main_summary</code>.</p>
<ul>
<li><code>submission_date</code> - <code>yyyymmdd</code></li>
<li><code>engine</code> - e.g. <code>google</code>, <code>bing</code>, <code>yahoo</code></li>
<li><code>source</code> - The UI component used to issue a search - e.g. <code>urlbar</code>, <code>abouthome</code></li>
<li><code>country</code></li>
<li><code>locale</code></li>
<li><code>addon_version</code> - The installed version of the [<code>followonsearch</code> addon]</li>
<li><code>app_version</code></li>
<li><code>distribution_id</code> - <code>NULL</code> means the standard Firefox build</li>
<li><code>search_cohort</code> - <code>NULL</code> except for small segments relating to search experimentation</li>
</ul>
<p>There are three aggregation columns:
<code>sap</code>, <code>tagged-sap</code>, and <code>tagged-follow-on</code>.
Each of these columns represent different types of searches.
For more details, see the <a href="../../search.html">search data documentation</a>
Note that, if there were no such searches in a row's segment
(i.e. the count would be 0),
the column value is <code>null</code>.</p>
<!--
#### Background and Caveats
-->
<a class="header" href="#accessing-the-data-29" id="accessing-the-data-29"><h4>Accessing the Data</h4></a>
<p>Access to <code>search_aggregates</code> is heavily restricted.
You will not be able to access this table without additional permissions.
For more details see the <a href="../../search.html">search data documentation</a>.</p>
<!--
#### Further Reading
-->
<a class="header" href="#data-reference-17" id="data-reference-17"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-13" id="example-queries-13"><h2>Example Queries</h2></a>
<p><a href="https://sql.telemetry.mozilla.org/queries/51140/source">This query</a>
calculates daily US searches.
If you have trouble viewing this query,
it's likely you don't have the proper permissions.
For more details see the <a href="../../search.html">search data documentation</a>.</p>
<a class="header" href="#scheduling-14" id="scheduling-14"><h2>Scheduling</h2></a>
<p>This job is
<a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/main_summary.py#L135">scheduled on airflow</a>
to run daily.</p>
<a class="header" href="#schema-16" id="schema-16"><h2>Schema</h2></a>
<p>As of 2018-02-13,
the current version of <code>search_aggregates</code> is <code>v3</code>,
and has a schema as follows.
The dataset is backfilled through 2016-06-06</p>
<pre><code>root
 |-- country: string (nullable = true)
 |-- engine: string (nullable = true)
 |-- source: string (nullable = true)
 |-- submission_date: string (nullable = true)
 |-- app_version: string (nullable = true)
 |-- distribution_id: string (nullable = true)
 |-- locale: string (nullable = true)
 |-- search_cohort: string (nullable = true)
 |-- addon_version: string (nullable = true)
 |-- tagged-sap: long (nullable = true)
 |-- tagged-follow-on: long (nullable = true)
 |-- sap: long (nullable = true)
</code></pre>
<a class="header" href="#code-reference-8" id="code-reference-8"><h1>Code Reference</h1></a>
<p>The <code>search_aggregates</code> job is
<a href="https://github.com/mozilla/python_mozetl/blob/master/mozetl/search/aggregates.py">defined in <code>python_mozetl</code></a></p>
<a class="header" href="#search-clients-daily" id="search-clients-daily"><h1>Search Clients Daily</h1></a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
<a class="header" href="#introduction-23" id="introduction-23"><h1>Introduction</h1></a>
<p><code>search_clients_daily</code> is designed to enable client-level search analyses.
Querying this dataset can be slow;
consider using <code>search_aggregates</code> for coarse analyses.</p>
<a class="header" href="#contents-21" id="contents-21"><h4>Contents</h4></a>
<p><code>search_clients_daily</code> has one row for each unique combination of:
(<code>client_id</code>, <code>submission_date</code>, <code>engine</code>, <code>source</code>).</p>
<p>In addition to the standard search count aggregations,
this dataset includes some descriptive data for each client.
For example, we include <code>country</code> and <code>channel</code> for each row of data.
In the event that a client sends multiple pings on a given <code>submission_date</code>
we choose an arbitrary value from the pings for that (<code>client_id</code>, <code>submission_date</code>),
unless otherwise noted.</p>
<p>There are three standard search count aggregation columns:
<code>sap</code>, <code>tagged-sap</code>, and <code>tagged-follow-on</code>.
Note that, if there were no such searches in a row's segment
(i.e. the count would be 0),
the column value is <code>null</code>.
Each of these columns represent different types of searches.
For more details, see the <a href="../../search.html">search data documentation</a></p>
<a class="header" href="#background-and-caveats-16" id="background-and-caveats-16"><h4>Background and Caveats</h4></a>
<p><code>search_clients_daily</code> does not include
(<code>client_id</code> <code>submission_date</code>) pairs
if we did not receive a ping for that <code>submission_date</code>.</p>
<p>We impute a <code>NULL</code> <code>engine</code> and <code>source</code> for pings with no search counts.
This ensures users who never search are included in this dataset.</p>
<p>This dataset is large.
Consider using an <a href="../../../tools/spark.html">ATMO Spark cluster</a> for heavy analyses.
If you're querying this dataset from re:dash,
heavily limit the data you read using <code>submission_date_s3</code> or <code>sample_id</code>.</p>
<a class="header" href="#accessing-the-data-30" id="accessing-the-data-30"><h4>Accessing the Data</h4></a>
<p>Access to <code>search_clients_daily</code> is heavily restricted.
You will not be able to access this table without additional permissions.
For more details see the <a href="../../search.html">search data documentation</a>.</p>
<!--
#### Further Reading
-->
<a class="header" href="#data-reference-18" id="data-reference-18"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-14" id="example-queries-14"><h2>Example Queries</h2></a>
<p><a href="https://sql.telemetry.mozilla.org/queries/51141/source">This query</a>
calculates searches per <code>normalized_channel</code> for US clients on an arbitrary day.
If you have trouble viewing this query,
it's likely you don't have the proper permissions.
For more details see the <a href="../../search.html">search data documentation</a>.</p>
<a class="header" href="#scheduling-15" id="scheduling-15"><h2>Scheduling</h2></a>
<p>This dataset is scheduled on Airflow
(<a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/main_summary.py#L164">source</a>).</p>
<a class="header" href="#schema-17" id="schema-17"><h2>Schema</h2></a>
<p>As of 2018-03-23, the current version of <code>search_clients_daily</code> is <code>v2</code>,
and has a schema as follows.
It's backfilled through 2016-06-07</p>
<pre><code>root
 |-- client_id: string (nullable = true)
 |-- submission_date: string (nullable = true)
 |-- engine: string (nullable = true)
 |-- source: string (nullable = true)
 |-- country: string (nullable = true)
 |-- app_version: string (nullable = true)
 |-- distribution_id: string (nullable = true)
 |-- locale: string (nullable = true)
 |-- search_cohort: string (nullable = true)
 |-- addon_version: string (nullable = true)
 |-- os: string (nullable = true)
 |-- channel: string (nullable = true)
 |-- profile_creation_date: long (nullable = true)
 |-- default_search_engine: string (nullable = true)
 |-- default_search_engine_data_load_path: string (nullable = true)
 |-- default_search_engine_data_submission_url: string (nullable = true)
 |-- sample_id: string (nullable = true)
 |-- sessions_started_on_this_day: long (nullable = true)
 |-- profile_age_in_days: integer (nullable = true)
 |-- subsession_hours_sum: double (nullable = true)
 |-- active_addons_count_mean: double (nullable = true)
 |-- max_concurrent_tab_count_max: integer (nullable = true)
 |-- tab_open_event_count_sum: long (nullable = true)
 |-- active_hours_sum: double (nullable = true)
 |-- tagged-sap: long (nullable = true)
 |-- tagged-follow-on: long (nullable = true)
 |-- sap: long (nullable = true)
 |-- tagged_sap: long (nullable = true)
 |-- tagged_follow_on: long (nullable = true)
 |-- submission_date_s3: string (nullable = true)
</code></pre>
<a class="header" href="#code-reference-9" id="code-reference-9"><h1>Code Reference</h1></a>
<p>The <code>search_clients_daily</code> job is
<a href="https://github.com/mozilla/python_mozetl/blob/master/mozetl/search/aggregates.py">defined in <code>python_mozetl</code></a></p>
<a class="header" href="#other-datasets-1" id="other-datasets-1"><h1>Other Datasets</h1></a>
<p>These datasets are for projects outside of the Firefox telemetry domain.</p>
<a class="header" href="#hgpush" id="hgpush"><h1>hgpush</h1></a>
<p>This dataset records facts about individual commits to the Firefox source tree
in the <a href="https://hg.mozilla.org/mozilla-central/"><code>mozilla-central</code></a> source
code repository.</p>
<a class="header" href="#data-reference-19" id="data-reference-19"><h1>Data Reference</h1></a>
<p>The dataset is accessible via <a href="https://sql.telemetry.mozilla.org"><code>STMO</code></a>.
Use the <code>eng_workflow_hgpush_parquet_v1</code> table with the <code>Athena</code> data source.
(The <code>Presto</code> data source is also available, but much slower.)</p>
<a class="header" href="#field-types-and-descriptions" id="field-types-and-descriptions"><h2>Field Types and Descriptions</h2></a>
<p>See the <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/blob/dev/schemas/eng-workflow/hgpush/hgpush.1.schema.json"><code>hgpush</code> ping schema</a>
for a description of available fields.</p>
<p>Be careful to:</p>
<ul>
<li>Use the latest schema version.  e.g. <code>v1</code>.  Browse the <a href="https://github.com/mozilla-services/mozilla-pipeline-schemas/tree/dev/schemas/eng-workflow/hgpush"><code>hgpush</code> schema directory</a> in the GitHub repo to be sure.</li>
<li>Change dataset field names from <code>camelCaseNames</code> to <code>under_score_names</code> in STMO. e.g. <code>reviewSystemUsed</code> in the ping schema becomes <code>review_system_used</code> in STMO.</li>
</ul>
<a class="header" href="#example-queries-15" id="example-queries-15"><h2>Example Queries</h2></a>
<p>Select the number of commits with an 'unknown' review system in the last 7 days:</p>
<pre><code class="language-sql">select
    count(1)
from
    eng_workflow_hgpush_parquet_v1
where
    review_system_used = 'unknown'
    and date_diff('day', from_unixtime(push_date), now()) &lt; 7
</code></pre>
<a class="header" href="#code-reference-10" id="code-reference-10"><h1>Code Reference</h1></a>
<p>The dataset is populated via the <a href="https://github.com/mozilla-conduit/commit-telemetry-service">Commit Telemetry Service</a>.</p>
<a class="header" href="#obsolete-datasets-1" id="obsolete-datasets-1"><h1>Obsolete Datasets</h1></a>
<p>These datasets are no longer updated or maintained. Please reach out to the Data Platform team
if you think your needs are best met by an obsolete dataset.</p>
<a class="header" href="#heavy-users" id="heavy-users"><h1>Heavy Users</h1></a>
<p><strong><em>As of 2018-05-18, this dataset has been deprecated and is no longer maintained. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1455314">Bug 1455314</a></em></strong></p>
<ul>
<li><a href="#replacement">Replacement</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#data-reference">Data Reference</a>
<ul>
<li><a href="#example-queries">Example Queries</a></li>
<li><a href="#scheduling">Scheduling</a></li>
<li><a href="#schema">Schema</a></li>
</ul>
</li>
<li><a href="#code-reference">Code Reference</a></li>
</ul>
<a class="header" href="#replacement" id="replacement"><h1>Replacement</h1></a>
<p>We've moved to assigning user's an active tag based on <code>total_uri_count</code>, see
the <a href="../../../cookbooks/active_dau.html">Active DAU definition</a>.</p>
<p>The activity of a user based on <code>active_ticks</code> is available in <code>clients_daily</code>
in the <code>active_hours_sum</code> field, which has the <code>sum(active_ticks / 720)</code>.</p>
<p>To retrieve a client's 28-day <code>active_hours</code>, use the following query:</p>
<pre><code class="language-sql">SELECT submission_date_s3,
       client_id,
       SUM(active_hours_sum) OVER (PARTITION BY client_id
                                   ORDER BY submission_date_s3 ASC
                                   ROWS 27 PRECEDING) AS monthly_active_hours
FROM
    clients_daily
</code></pre>
<a class="header" href="#introduction-24" id="introduction-24"><h1>Introduction</h1></a>
<p>The <code>heavy_users</code> table provides information about whether a given <code>client_id</code> is
considered a &quot;heavy user&quot; on each day (using submission date).</p>
<a class="header" href="#contents-22" id="contents-22"><h4>Contents</h4></a>
<p>The <code>heavy_users</code> table contains one row per client-day, where day is
<code>submission_date</code>. A client has a row for a specific <code>submission_date</code> if
they were active at all in the 28 day window ending on that <code>submission_date</code>.</p>
<p>A user is a &quot;heavy user&quot; as of day N if, for the 28 day period ending
on day N, the sum of their <code>active_ticks</code> is in the 90th percentile (or
above) of all clients during that period. For more analysis on this,
and a discussion of new profiles, see
<a href="https://metrics.mozilla.com/protected/sguha/heavy/heavycutoffs5.html">this link</a>.</p>
<a class="header" href="#background-and-caveats-17" id="background-and-caveats-17"><h4>Background and Caveats</h4></a>
<ol>
<li>Data starts at 20170801. There is technically data in the table before
this, but the <code>heavy_user</code> column is <code>NULL</code> for those dates because it
needed to bootstrap the first 28 day window.</li>
<li>Because it is top the 10% of clients for each 28 day period, more
than 10% of clients active on a given <code>submission_date</code> will be
considered heavy users. If you join with another data source
(<code>main_summary</code>, for example), you may see a larger proportion of heavy
users than expected.</li>
<li>Each day has a separate, but related, set of heavy users. Initial
investigations show that approximately 97.5% of heavy users as of a
certain day are still considered heavy users as of the next day.</li>
<li>There is no &quot;fixing&quot; or weighting of new profiles - days before the
profile was created are counted as zero <code>active_ticks</code>. Analyses may
need to use the included <code>profile_creation_date</code> field to take this
into account.</li>
</ol>
<a class="header" href="#accessing-the-data-31" id="accessing-the-data-31"><h4>Accessing the Data</h4></a>
<p>The data is available both via <code>sql.t.m.o</code> and Spark.</p>
<p>In Spark:</p>
<pre><code class="language-python">spark.read.parquet(&quot;s3://telemetry-parquet/heavy_users/v1&quot;)
</code></pre>
<p>In SQL:</p>
<pre><code class="language-sql">SELECT * FROM heavy_users LIMIT 3
</code></pre>
<a class="header" href="#further-reading-16" id="further-reading-16"><h4>Further Reading</h4></a>
<p>The code responsible for generating this dataset is
<a href="BROKEN:https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/HeavyUsersView.scala">here</a></p>
<a class="header" href="#data-reference-20" id="data-reference-20"><h1>Data Reference</h1></a>
<a class="header" href="#example-queries-16" id="example-queries-16"><h2>Example Queries</h2></a>
<p>Example queries:</p>
<ul>
<li><a href="https://sql.telemetry.mozilla.org/queries/47041/source#127382">Join <code>heavy_users</code> with <code>main_summary</code> to get distribution of <code>max_concurrent_tab_count</code> for heavy vs. non-heavy users</a></li>
<li><a href="https://sql.telemetry.mozilla.org/queries/47044/source#127385">Join <code>heavy_users</code> with <code>longitudinal</code> to get crash rates for heavy vs. non-heavy users</a></li>
</ul>
<a class="header" href="#scheduling-16" id="scheduling-16"><h2>Scheduling</h2></a>
<p>This dataset is updated daily via the <a href="https://github.com/mozilla/telemetry-airflow">telemetry-airflow</a> infrastructure.
The job DAG runs every day after <code>main_summary</code> is complete.
You can find the job definition
<a href="https://github.com/mozilla/telemetry-airflow/blob/master/dags/main_summary.py#L187-L195">here</a>.</p>
<a class="header" href="#schema-18" id="schema-18"><h2>Schema</h2></a>
<p>As of 2017-10-05, the current version of the <code>heavy_users</code> dataset is <code>v1</code>, and has a schema as follows:</p>
<pre><code>root
 |-- client_id: string (nullable = true)
 |-- sample_id: integer (nullable = true)
 |-- profile_creation_date: long (nullable = true)
 |-- active_ticks: long (nullable = true)
 |-- active_ticks_period: long (nullable = true)
 |-- heavy_user: boolean (nullable = true)
 |-- prev_year_heavy_user: boolean (nullable = true)
 |-- submission_date_s3: string (nullable = true)
</code></pre>
<a class="header" href="#code-reference-11" id="code-reference-11"><h1>Code Reference</h1></a>
<p>This dataset is generated by
<a href="BROKEN:https://github.com/mozilla/telemetry-batch-view/blob/master/src/main/scala/com/mozilla/telemetry/views/HeavyUsersView.scala">telemetry-batch-view</a>.
Refer to this repository for information on how to run or augment the dataset.</p>
<a class="header" href="#profile-creation---the-technical-part" id="profile-creation---the-technical-part"><h1>Profile Creation - The technical part</h1></a>
<ul>
<li><a href="#what-is-a-profile">What is a profile?</a></li>
<li><a href="#profile-behaviors">Profile Behaviors</a></li>
<li><a href="#profile-creation-date">Profile Creation Date</a></li>
</ul>
<a class="header" href="#what-is-a-profile" id="what-is-a-profile"><h2>What is a profile?</h2></a>
<p>All of the changes a user makes in Firefox, like the home page, what toolbars you use, installed addons, saved passwords and your bookmarks, are all stored in a special folder, called a profile.
Telemetry stores archived and pending pings in the profile directory as well as metadata like the client ID.</p>
<p>Every run of Firefox needs a profile. However a single installation can use multiple profiles for different runs.
The profile folder is stored in a separate place from the Firefox program so that, if something ever goes wrong with Firefox, the profile information will still be there.</p>
<p>Firefox also comes with a Profile Manager, a different run mode to create, migrate and delete the profiles.</p>
<a class="header" href="#profile-behaviors" id="profile-behaviors"><h2>Profile Behaviors</h2></a>
<p>In order to understand the behavior of users and base analysis on things like the profile creation date,
it is essential to understand how a profile is created and identified by the browser.
Also, it is important to understand how user actions with and within profiles affect our ability to reason about profiles from a data perspective.
This includes resetting or deleting profiles or opting into or out of sending Telemetry data.</p>
<p>The different cases are described in more detail in the following sections.</p>
<a class="header" href="#profile-creation" id="profile-creation"><h3>Profile Creation</h3></a>
<p>There are multiple ways a Firefox profile can be created.
Some of these behave slightly differently.</p>
<p>Profiles can be created and managed by the Firefox Profile Manager:</p>
<ul>
<li>New profile on first launch</li>
<li>New profile from Profile Manager</li>
<li><code>--createprofile</code> command line argument</li>
</ul>
<p>Profiles can be created externally and not be managed by the Firefox Profile Manager:</p>
<ul>
<li><code>--profile</code> command line argument</li>
</ul>
<a class="header" href="#managed-first-use" id="managed-first-use"><h4>Managed: First use</h4></a>
<p>When Firefox is opened for the first time after a fresh install, without any prior Firefox profile on disk visible to Firefox, it will create a new profile.
Firefox uses &quot;Default User&quot; as the profile name, creates the profile's directory with a random suffix and marks the new profile as default for subsequent starts of Firefox.
Read <a href="https://support.mozilla.org/en-US/kb/profiles-where-firefox-stores-user-data">where Firefox stores your profile data</a>.</p>
<a class="header" href="#managed-profile-manager-creation" id="managed-profile-manager-creation"><h4>Managed: Profile Manager creation</h4></a>
<p>The user can create a new profile through the Profile Manager.
This can either be done on <code>about:profiles</code> in a running Firefox or by starting Firefox with the <code>--ProfileManager</code> flag.
The Profile Manager will ask for a name for the profile and picks a new directory for it.
The Profile Manager allows the user to create a new profile from an existing directory (in which case any files will be included) or from scratch (in which case the directory will be created).</p>
<p>The <code>--createprofile</code> flag can be used from the command line and works the same as creating a profile through the Profile Manager.</p>
<a class="header" href="#unmanaged-command-line-start" id="unmanaged-command-line-start"><h4>Unmanaged: Command-line start</h4></a>
<p>Firefox can be started on the command line with a path to a profile directory: <code>firefox --profile path/to/directory</code>.
If the directory does not exist it will be created.</p>
<p>A profile created like this will not be picked up by the Profile Manager.
Its data will persist after Firefox is closed, but the Profile Manager will not know about it.
The profile will not turn up in <code>about:profiles</code>.</p>
<a class="header" href="#profile-reset" id="profile-reset"><h3>Profile Reset</h3></a>
<p>A user can reset the profile (see <a href="https://support.mozilla.org/en-US/kb/refresh-firefox-reset-add-ons-and-settings">Refresh Firefox - reset addons and settings</a>).
This will copy over most user data to a new directory, keeping things like the history, bookmarks and cookies, but will remove extensions, modified preferences and added search engines.</p>
<p>A profile reset will not change the Telemetry <code>clientID</code>.
The date of the most recent profile reset is saved and will be contained in Telemetry pings in the <code>profile.resetDate</code> field.</p>
<a class="header" href="#profile-deletion" id="profile-deletion"><h3>Profile Deletion</h3></a>
<p>A profile can be deleted through the Profile Manager, which will delete all stored data from disk.
The profile can also be deleted by simply removing the profile's directory.
We will never know about a deletion. We simply won't see that profile in new Telemetry data anymore.</p>
<p>Uninstalling the Firefox installation will not remove any profile data.</p>
<p><strong>Note:</strong> Removing a profile's directory while it is in use is not recommended and will lead to a corrupt state.</p>
<a class="header" href="#telemetry-opt-out" id="telemetry-opt-out"><h3>Telemetry opt-out</h3></a>
<p>The user can opt out of sending Telemetry data.
When the user opts out, Telemetry sends one <a href="https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/optout-ping.html">&quot;optout&quot; ping</a>, containing an empty payload.
The local <code>clientID</code> is reset to a fixed value.</p>
<p>When a user opts into sending Telemetry data, a new <code>clientID</code> is generated and used in subsequent pings.
The profile itself and the profile creation date are unaffected by this.</p>
<a class="header" href="#profile-creation-date" id="profile-creation-date"><h2>Profile Creation Date</h2></a>
<p>The <em>profile creation date</em> is the assumed date of initial profile creation.
However it proved to be not reliable for all cases.
There are multiple ways this date is determined.</p>
<a class="header" href="#managed-during-profile-creation" id="managed-during-profile-creation"><h3>Managed: During Profile Creation</h3></a>
<p>When a profile is created explicitly the profile directory is created and a <code>times.json</code> containing a timestamp of the current time is stored inside that profile directory<sup class="footnote-reference"><a href="#1">1</a></sup>.
It is read at later times when the profile creation date is used.</p>
<div class="mermaid">graph TD
A[Start Firefox] -->B[Select profile dir, default or defined]
B --> C{Selected dir exist?}
C --> |No| D[Create directory]
C --> |Yes| E[Write times.json]
D --> E
E --> F[Show Browser]
F --> G[ProfileAge.jsm is called]
G --> J[Read time from times.json]
J --> S[Return creation date]
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Relevant parts in the code: <a href="https://searchfox.org/mozilla-central/rev/292d295d6b084b43b70de26a42e68513bb7b36a3/toolkit/xre/nsAppRunner.cpp#2394-2395,2397-2398,2527-2533"><code>nsAppRunner::SelectProfile</code></a> calling <a href="https://searchfox.org/mozilla-central/rev/196560b95f191b48ff7cba7c2ba9237bba6b5b6a/toolkit/profile/nsToolkitProfileService.cpp#789-793"><code>nsToolkitProfileService::CreateProfile</code></a>.</p>
</div>
<a class="header" href="#unmanaged-empty-profile-directory" id="unmanaged-empty-profile-directory"><h3>Unmanaged: Empty profile directory</h3></a>
<p>When <code>--profile path/to/directory</code> is passed on the command line, the directory is created if it does not exist, but no <code>times.json</code> is written<sup class="footnote-reference"><a href="#2">2</a></sup>.
On the first access of the profile creation date (through <code>ProfileAge.jsm</code>) the module will detect that the <code>times.json</code> is missing.
It will then iterate through all files in the current profile's directory, reading file creation or modification timestamps.
The oldest of these timestamps is then assumed to be the profile creation date and written to <code>times.json</code>.
Subsequent runs of Firefox will then use this date.</p>
<div class="mermaid">graph TD
A[Start Firefox --profile path/to/dir] -->H{path/to/dir exist?}
H --> |No| K[Create directory]
K --> F[Show Browser]
H --> |Yes| F
F --> O[ProfileAge.jsm is called]
O --> R{times.json exists?}
R -->|Yes| Q[Read time from times.json]
R -->|No| L[Scan profile dir for oldest file, write to times.json]
L --> S
Q --> S[Return creation date]
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Relevant part in the code: <a href="https://searchfox.org/mozilla-central/rev/292d295d6b084b43b70de26a42e68513bb7b36a3/toolkit/xre/nsAppRunner.cpp#2357-2363"><code>nsAppRunner::SelectProfile</code></a> creating the directory.</p>
</div>
<a class="header" href="#real-world-usage" id="real-world-usage"><h1>Real World Usage</h1></a>
<p>This page backs away from our profile-focused data view and examines what Firefox Desktop usage looks like in the real world. There are many components and layers that exist between a user acquiring and running Firefox, and this documentation will illuminate what those are and how they can affect the meaning of a profile.</p>
<a class="header" href="#real-life-components-of-firefox-desktop-usage" id="real-life-components-of-firefox-desktop-usage"><h2>Real Life Components of Firefox Desktop Usage</h2></a>
<p><img src="images/real-life-usage-components.png" alt="" /></p>
<p>The above image illustrates all the layers that sit between a user acquiring and running Firefox Desktop and the Telemetry pings we receive.</p>
<ul>
<li>1: The user
<ul>
<li>A human being presumably.</li>
</ul>
</li>
<li>2: The machine
<ul>
<li>The physical hardware running Firefox.</li>
</ul>
</li>
<li>3: The disk image / hard drive
<ul>
<li>A single machine could have separate partitions running different OSes.</li>
<li>Multiple machines could run copies of a single disk image</li>
<li>Disk images are also used as backups to restore a machine.</li>
</ul>
</li>
<li>4: OS user profile
<ul>
<li>Most operating systems allow users to log into different user profiles with separate user directories (such as a &quot;Guest&quot; account).</li>
<li>Usually, Firefox is installed into a system directory that all users profiles will share, but Firefox profiles are saved within the user directories, effectively segregating them.</li>
</ul>
</li>
<li>5: Firefox binary / installer
<ul>
<li>The downloaded binary package or stub installer which installs Firefox into the disk image. Users can get these from our website or one of our managed properties, but they can also acquire these from 3rd party sources as well.</li>
<li>Our website is instrumented with Google Analytics to track download numbers, but other properties (FTP) and 3rd party sources are not. Google Analytics data is not directly connected to Telemetry data.</li>
<li>A user can produce multiple installations from a single Firefox binary / installer. For example, if a user copies it to a USB stick or keeps it in cloud storage, they could install Firefox on multiple machines from a single binary / installer.</li>
</ul>
</li>
<li>6: Firefox installation
<ul>
<li>The installed Firefox program on a given disk image.</li>
<li>Since Firefox is usually installed in a system directory, the single installation of Firefox will be shared by all the OS user profiles in the disk image.</li>
<li>Stub installers are instrumented with pings to report new install counts, however, full binaries are not.</li>
</ul>
</li>
<li>7: Firefox profile
<ul>
<li>The profile Firefox uses during a user's session.</li>
<li>A user can create multiple Firefox profiles using the Firefox Profile Manager, or by specifying a custom directory to use at startup. More details <a href="profile_creation.html">here</a>.</li>
<li>This is the entity that we see in Telemetry. Profiles send pings to Telemetry with a client ID as its identifier.</li>
</ul>
</li>
</ul>
<a class="header" href="#desktop-browser-use-cases" id="desktop-browser-use-cases"><h2>Desktop Browser Use Cases</h2></a>
<p>Below are the rough categories of Firefox use cases that we know happen in the real world.</p>
<p>Note, these categories are rough approximations, and are not necessarily mutually exclusive.</p>
<a class="header" href="#regular-user" id="regular-user"><h4>Regular User</h4></a>
<p>What we imagine a typical user to be. Someone who buys a computer, always uses a default OS user profile, downloads Firefox once, installs it, and continues using the default Firefox profile.</p>
<p><img src="images/regular-user.png" alt="" /></p>
<p>In Telemetry, this user would just show up as a single client ID.</p>
<p>Assuming they went through our normal funnel, they should show up once in Google Analytics as a download and once in stub installer pings as a new installation (if they used a stub installer).</p>
<a class="header" href="#multi-profile-user" id="multi-profile-user"><h4>Multi-Profile User</h4></a>
<p>A more advanced user, who uses multiple Firefox profiles in their normal, everyday use, but otherwise is pretty 'normal' (uses the same OS user profile, etc.).</p>
<p><img src="images/multi-profile-user.png" alt="" /></p>
<p>In Telemetry, this user would show up as 2 (or more) separate client IDs.
We would have no way to know they came from the same computer and user without identifying that the subsessions are never overlapping and that large portions of the environment (CPU, GPU, Displays) are identical and that would be no guarantee.</p>
<p>Assuming they went through our normal funnel, they would show up once in Google Analytics as a download and once in stub installer pings as a new installation (if they used a stub installer).</p>
<p>However, any subsequent new Firefox profile creations would not have any corresponding downloads or installations.
Since Firefox 55 however, any newly created profile will send a &quot;new-profile&quot; ping.</p>
<a class="header" href="#shared-computer" id="shared-computer"><h4>Shared Computer</h4></a>
<p>A situation where there is a computer that is shared across multiple users and each user uses a different OS user profile. Since Firefox profiles live at the user directory level, each user would have a separate Firefox profile. Note, users logging in under a &quot;Guest&quot; account in most machines falls into this category.</p>
<p><img src="images/shared-computer.png" alt="" /></p>
<p>In this case, every user who logged into this one computer with a different OS user profile would show up as a different client ID. We have no way of knowing they came from the same computer.</p>
<p>Furthermore, if the computer wiped the user directory after use, like Guest accounts and university computer labs often do, then they would show up as a <strong>new</strong> client ID every time they logged in, even if they have used the same computer multiple times. This use case could inflate new profile counts.</p>
<p>Similar to Multi-Profile Users, in this use case, there would be only one download event and install event (assuming normal funnel and stub installer), but multiple client ID's.</p>
<a class="header" href="#cloned-machines" id="cloned-machines"><h4>Cloned Machines</h4></a>
<p>In this case, there are actually multiple users with computers that all share the same disk image at some point.</p>
<p>Think of the situation where the IT staff sets up the computer for a new hire at a company. Instead of going through to trouble of installing all the required programs and setting them up correctly for each computer, they'll do it once on one computer, save the disk image, and simply copy it over each time they need to issue a new machine.</p>
<p>Or think of the case where the IT staff of a library needs to set up 2 dozen machines at once.</p>
<p><img src="images/cloned-machines.png" alt="" /></p>
<p>In this case, depending on the state of the disk image when it was copied, we could see multiple client ID's for each user+machine, or we could see all the user+machines sharing the same client ID.</p>
<p>If the disk image was copied after a Firefox profile was created, then the old user+machine and new user+machine will share the same client ID, and be submitting pings to us concurrently.</p>
<p>If the disk image was copied after the Firefox installation but before an initial Firefox profile was created, then each user+machine will get their own Firefox profile and client ID when they run Firefox for the first time.</p>
<p>As with the Multi-Profile User and Shared Computer case, even though there could be multiple Firefox profiles in this use case, there will only be one download and install event.</p>
<a class="header" href="#migrations" id="migrations"><h4>Migrations</h4></a>
<a class="header" href="#type-1-migrate-disk-image" id="type-1-migrate-disk-image"><h5>Type 1: Migrate Disk Image</h5></a>
<p>A user has a backup of their disk image and when they switch to a new computer or their current computer crashes, they simply reboot from the old disk image.</p>
<p><img src="images/migration-1.png" alt="" /></p>
<p>In this case, the old machine and the new machine will just share the same client ID (assuming that the disk was copied after a Firefox profile was created). In fact, it will look exactly like the Cloned Machines case, except that instead of sending pings concurrently, they'll be sending us pings first from the old machine and then from the new machine.</p>
<p>Also, it should be noted that their Firefox profile will 'revert' back to the state that it was in when the disk image was copied, essentially starting over from the past, and any unsent pings on the image (if they exist) will be resent.
For instance, we will see another ping with the <code>profile_subsession_count</code> (the count of how many subsessions a profile has seen in its history) we previously saw some time before.</p>
<p>Again, there will only be one download and install associated with this use case (assuming normal funnel and stub installer).</p>
<a class="header" href="#type-2-migrate-os-user-directory" id="type-2-migrate-os-user-directory"><h5>Type 2: Migrate OS User Directory</h5></a>
<p>A user has a backup of their OS user directory and copies it to a new machine.</p>
<p><img src="images/migration-2.png" alt="" /></p>
<p>This is similar to Type 1 migration, but instead of copying the entire disk, the user only copies the OS user directory. Since the Firefox profile lives in the OS user directory, the old machine and new machine will share the same client ID.</p>
<p>The only difference is since the Firefox Installation lives in system directories, the client might have to re-download and re-install the browser. However, if they also copy the Firefox binary / installer, there will not be a download event, only an install event.</p>
<a class="header" href="#type-3-migrate-firefox-binary--installer" id="type-3-migrate-firefox-binary--installer"><h5>Type 3: Migrate Firefox Binary / Installer</h5></a>
<p>A user has the Firefox binary or installer saved on their old machine and copies it over to a new machine to install Firefox.</p>
<p><img src="images/migration-3.png" alt="" /></p>
<p>In this case, there will not be a second download event, but there will be an install event and the new and old machines will have separate client ID's.</p>
<a class="header" href="#type-4-migrate-firefox-profile" id="type-4-migrate-firefox-profile"><h5>Type 4: Migrate Firefox Profile</h5></a>
<p>A user copies their old Firefox profile from their old machine to a new computer, and runs Firefox using the copied Firefox profile.</p>
<p><img src="images/migration-4.png" alt="" /></p>
<p>In this case, since the Firefox profile is being copied over, both the new and the old machine will have profiles with the same client ID. Again, the profile on the new computer will revert back to the point in its history where it was copied.
And since the profile contains any unsent Telemetry pings, we may receive duplicated submissions of pings from the same client ID.</p>
<p>If the Firefox binary / installer was downloaded, there will be a download and install event. If it was migrated via USB stick, it will only have an install event.</p>
<a class="header" href="#profile-history" id="profile-history"><h1>Profile History</h1></a>
<p>A profile's history is simply the progression of that profile's subsessions over its lifetime. We can see this in our main pings by checking:</p>
<ul>
<li><code>profile_subsession_counter</code>
<ul>
<li>A counter which starts at 1 on the very first run of a profile and increments for each subsession. This counter will be reset to 1 if a user resets / refreshes their profile.</li>
</ul>
</li>
<li><code>subsession_start_date</code>
<ul>
<li>The date and time the subsession starts in, truncated to hours. This field is not always reliable due to local clock skew.</li>
</ul>
</li>
<li><code>previous_subsession_id</code>
<ul>
<li>The ID of the previous subsession. Will be <code>null</code> for the very first subsession, or the first subsession after a user resets / refreshes their profile.</li>
</ul>
</li>
<li><code>subsession_id</code>
<ul>
<li>The ID of the current subsession.</li>
</ul>
</li>
<li><code>submission_date_s3</code>
<ul>
<li>The date we received the ping. This date is sourced from the server's time and reliable.</li>
</ul>
</li>
<li><code>profile_reset_date</code>
<ul>
<li>The date the profile was reset. Will be <code>null</code> if the profile was not reset.</li>
</ul>
</li>
</ul>
<p><img src="images/profile-history/basic-example.png" alt="" /></p>
<p>This is a nice clean example of profile history. It has a clear <strong>starting ping</strong> and it progresses linearly, with each subsession connecting to the next via <code>subsession_id</code>. However, due to the fact that profiles can be shared across machines, and restored manually, etc. strange behaviors can arise (see <a href="realworldusage.html">Real World Usage</a>).</p>
<a class="header" href="#profile-history-start-conditions" id="profile-history-start-conditions"><h2>Profile History Start Conditions</h2></a>
<p>Under normal assumptions, we expect to see the <strong>starting ping</strong> in a profile's history in our telemetry data. The starting ping in the profile's history is the ping from their very first subsession. We expect this ping to have <code>profile_subsession_counter = 1</code> and <code>previous_subsession_id is null</code> and <code>profile_reset_date is null</code>.</p>
<p>However, not all profiles appear in our data with a starting ping and instead appear to us mid-history.</p>
<p><img src="images/profile-history/ping-diagram-start-condition.png" alt="" /></p>
<a class="header" href="#history-has-beginning" id="history-has-beginning"><h4>History Has Beginning</h4></a>
<p><img src="images/profile-history/example-starting.png" alt="" /></p>
<p>As you can see, this profile starts with a ping where <code>profile_subsession_counter = 1</code> and <code>previous_subsession_id is null</code>.</p>
<a class="header" href="#history-has-no-beginning" id="history-has-no-beginning"><h4>History Has No Beginning</h4></a>
<p><img src="images/profile-history/example-midhistory.png" alt="" /></p>
<p>In this example, the profile simply appears in our data mid-history, with presumably the 25th subsession in it's history. Its previous history is a mystery.</p>
<a class="header" href="#profile-history-progression-events" id="profile-history-progression-events"><h2>Profile History Progression Events</h2></a>
<p>After a profile appears, in 'normal' conditions, there should be a linear, straightforward progression with each subsession linking to the next.</p>
<p><img src="images/profile-history/ping-diagram-events.png" alt="" /></p>
<p>However, the following abnormal events can occur.</p>
<a class="header" href="#history-gap" id="history-gap"><h4>History Gap</h4></a>
<p>There is a gap in the profile history.</p>
<p>It's possible this behavior is due to dropped pings.</p>
<p><img src="images/profile-history/example-gap.png" alt="" /></p>
<p>Here, we see a gap between the 30th ping and the 41st ping and the 44th ping.</p>
<a class="header" href="#history-splits" id="history-splits"><h4>History Splits</h4></a>
<p>The history of a profile splits, and after a single subsession, there are two (or more) subsessions that link back to it.</p>
<p>This is probably due to cloned machines or disk image restores. Note, after the profile splits, the two branches might continue concurrently or one branch might die while the other continues.
It is very hard to distinguish between the different branches of the same profile.</p>
<ul>
<li>Profile begins</li>
</ul>
<p><img src="images/profile-history/example-splits-1.png" alt="" /></p>
<ul>
<li>Profile splits: branch 1</li>
</ul>
<p><img src="images/profile-history/example-splits-2.png" alt="" /></p>
<ul>
<li>Profile splits: branch 2</li>
</ul>
<p><img src="images/profile-history/example-splits-3.png" alt="" /></p>
<p>In this example, the profile history starts normally, but on the 5th ping, the history splits into two branches that seem to progress concurrently.</p>
<a class="header" href="#history-restarts" id="history-restarts"><h4>History Restarts</h4></a>
<p>The history of a profile suddenly starts over, with a brand new starting ping.</p>
<ul>
<li>Profile begins</li>
</ul>
<p><img src="images/profile-history/example-restart-1.png" alt="" /></p>
<ul>
<li>Profile restarts</li>
</ul>
<p><img src="images/profile-history/example-restart-2.png" alt="" /></p>
<p>Here, we see the profile start their history normally, but then they begin a new, totally unconnected branch with a starting ping that is <strong>not</strong> the same as the original starting ping (different <code>subsession_id</code>s).</p>
<a class="header" href="#history-reruns" id="history-reruns"><h4>History Reruns</h4></a>
<p><a href="https://github.com/mozilla/firefox-data-docs/issues/169">(Work in Progress)</a></p>
<a class="header" href="#how-to-order-history" id="how-to-order-history"><h2>How to Order History</h2></a>
<p><a href="https://github.com/mozilla/firefox-data-docs/issues/170">(Work in Progress)</a></p>
<a class="header" href="#contributing" id="contributing"><h1>Contributing</h1></a>
<p>Documentation is critical to making a usable data platform.
When surveying our users,
their most common complaint has been our lack of documentation.
It's important that we improve our documentation as often as possible.</p>
<a class="header" href="#bug-reports" id="bug-reports"><h2>Bug reports</h2></a>
<p>If you see an error in the documentation or want to extend a chapter, please
<a href="https://bugzilla.mozilla.org/enter_bug.cgi?assigned_to=nobody%40mozilla.org&amp;bug_file_loc=http%3A%2F%2F&amp;bug_ignored=0&amp;bug_severity=normal&amp;bug_status=NEW&amp;cf_fx_iteration=---&amp;cf_fx_points=---&amp;component=Documentation%20and%20Knowledge%20Repo%20%28RTMO%29&amp;contenttypemethod=autodetect&amp;contenttypeselection=text%2Fplain&amp;defined_groups=1&amp;flag_type-4=X&amp;flag_type-607=X&amp;flag_type-800=X&amp;flag_type-803=X&amp;flag_type-916=X&amp;form_name=enter_bug&amp;maketemplate=Remember%20values%20as%20bookmarkable%20template&amp;op_sys=Linux&amp;priority=--&amp;product=Data%20Platform%20and%20Tools&amp;rep_platform=x86_64&amp;target_milestone=---&amp;version=unspecified">file a bug</a>.</p>
<a class="header" href="#getting-the-raw-documentation" id="getting-the-raw-documentation"><h2>Getting the Raw Documentation</h2></a>
<p>The documentation is intended to be read as HTML at
<a href="https://docs.telemetry.mozilla.org"><code>docs.telemetry.mozilla.org</code></a>.
However, we store the documentation in raw text files in the
<a href="https://github.com/mozilla/firefox-data-docs"><code>firefox-data-docs</code> repo</a>.
To begin contributing to the docs, fork the <code>firefox-data-docs</code> repo.</p>
<a class="header" href="#building-the-documentation" id="building-the-documentation"><h2>Building the Documentation</h2></a>
<p>The documentation is rendered with <a href="https://github.com/rust-lang-nursery/mdBook">mdBook</a>
To build the documentation locally,
you'll need to install the <code>mdbook-dtmo</code> wrapper.
Binary builds are provided at <a href="https://github.com/badboy/mdbook-dtmo/releases">https://github.com/badboy/mdbook-dtmo/releases</a>.</p>
<p>You can install a binary build directly:</p>
<pre><code class="language-bash">curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git badboy/mdbook-dtmo
</code></pre>
<p>If you have <a href="https://www.rust-lang.org/">Rust</a> installed, you can build and install <code>mdbook-dtmo</code>:</p>
<pre><code class="language-bash">cargo install --git https://github.com/badboy/mdbook-dtmo
</code></pre>
<p>You can then serve the documentation locally with:</p>
<pre><code>mdbook-dtmo serve
</code></pre>
<p>The complete documentation for the mdBook toolchain is at: <a href="https://rust-lang-nursery.github.io/mdBook/">https://rust-lang-nursery.github.io/mdBook/</a>.
If you run into any technical limitations, let me (<code>@harterrt</code>) know.
I'm happy to change the tooling to make it as much fun as possible to write.</p>
<a class="header" href="#adding-a-new-article" id="adding-a-new-article"><h2>Adding a new article</h2></a>
<p>Be sure to link to your new article from <code>SUMMARY.md</code>, or mdBook will not render the file.</p>
<p>The structure of the repository is outlined in <a href="./structure.html">this article</a>.</p>
<p>This documentation is under active development,
so we may already be working on the documentation you need.
Take a look at
<a href="https://bugzilla.mozilla.org/buglist.cgi?product=Data%20Platform%20and%20Tools&amp;component=Documentation%20and%20Knowledge%20Repo%20%28RTMO%29&amp;resolution=---">this bug component</a>
to check.</p>
<a class="header" href="#style-guide" id="style-guide"><h2>Style Guide</h2></a>
<p>Articles should be written in
<a href="https://daringfireball.net/projects/markdown/syntax">Markdown</a>
(not <a href="http://asciidoctor.org/docs/asciidoc-syntax-quick-reference/">AsciiDoc</a>).
Markdown is usually powerful enough and is a more common technology than AsciiDoc.</p>
<p>Limit lines to <strong>100 characters</strong> where possible.
Try to split lines at the end of sentences,
or use <a href="http://rhodesmill.org/brandon/2012/one-sentence-per-line/">Semantic Line Breaks</a>.
This makes it easier to reorganize your thoughts later.</p>
<p>This documentation is meant to be read digitally.
Keep in mind that people read digital content much differently than other media.
Specifically, readers are going to skim your writing,
so make it easy to identify important information.</p>
<p>Use <strong>visual markup</strong> like <strong>bold text</strong>, <code>code blocks</code>, and section headers.
Avoid long paragraphs.
Short paragraphs that describe one concept each makes finding important information easier.</p>
<a class="header" href="#spell-checking" id="spell-checking"><h2>Spell checking</h2></a>
<p>Articles should use proper spelling, and pull requests will be automatically checked for spelling
errors.</p>
<p>Technical articles often contain words that are not recognized by common dictionaries, if this
happens you may either put specialized terms in <code>code blocks</code>, or you may add an exception to
the <code>.spelling</code> file in the code repository.</p>
<p>For things like dataset names or field names, <code>code blocks</code> should be preferred. Things like
project names or common technical terms should be added to the <code>.spelling</code> file.</p>
<p>To run the spell checker locally,
<a href="https://www.npmjs.com/package/markdown-spellcheck">install the <code>markdown-spellcheck</code> library</a>,
then run the <code>scripts/spell_check.sh</code> script from the root of the repository.</p>
<p>You may also remove the <code>--report</code> parameter to begin an interactive fixing session. In this
case, it is highly recommended to also add the <code>--no-suggestions</code> parameter, which greatly
speeds things up.</p>
<a class="header" href="#link-checking" id="link-checking"><h2>Link checking</h2></a>
<p>Any web links should be valid. A dead link might not be your fault, but you will earn a lot
of good karma by fixing a dead link!</p>
<p>To run the link checker locally, <a href="https://github.com/tcort/markdown-link-check#installation">install the <code>markdown-link-check</code> library</a>, then run the <code>scripts/link_check.sh</code> script from the root of the repository.</p>
<a class="header" href="#supported-plugins" id="supported-plugins"><h2>Supported Plugins</h2></a>
<a class="header" href="#mermaid" id="mermaid"><h3>Mermaid</h3></a>
<p>You may use <a href="https://mermaidjs.github.io/"><code>mermaid.js</code></a> diagrams in code blocks:</p>
<pre><code>graph LR
  you --&gt;|write|docs
  docs --&gt; profit!
</code></pre>
<p>Which will be rendered as:</p>
<div class="mermaid">graph LR
  you -->|write|docs
  docs --> profit!
</div>
<a class="header" href="#review" id="review"><h2>Review</h2></a>
<p>Once you're happy with your contribution, please open a PR and flag <code>@harterrt</code> for review.
Please squash your changes  into meaningful commits  and follow these
<a href="https://chris.beams.io/posts/git-commit/">commit message guidelines</a>.</p>
<a class="header" href="#publishing" id="publishing"><h2>Publishing</h2></a>
<p>The documentation is hosted on <a href="https://pages.github.com/">Github Pages</a>.</p>
<p>Updates to the documentation are automatically published to
<a href="https://docs.telemetry.mozilla.org"><code>docs.telemetry.mozilla.org</code></a> when changes are merged.</p>
<p>To publish to your own fork of this repo, changes need to be pushed manually.
Use the <a href="https://github.com/mozilla/firefox-data-docs/blob/master/scripts/deploy.sh">deploy script</a>
to publish new changes.</p>
<p>This script depends on
<a href="https://github.com/davisp/ghp-import"><code>ghp-import</code></a>.</p>
<p>Keep in mind that this will deploy the docs to your <code>origin</code> repo.
If you're working from a fork (which you should be),
<code>deploy.sh</code> will update the docs hosted from your fork - not the production docs.</p>
<a class="header" href="#colophon" id="colophon"><h1>Colophon</h1></a>
<p>This document's structure is heavily influenced by
<a href="https://docs.djangoproject.com/en/1.11/internals/contributing/writing-documentation/">Django's Documentation Style Guide</a>.</p>
<p>You can find more context for this document in
<a href="http://blog.harterrt.com/lit-review.html">this blog post</a>.</p>
<a class="header" href="#documentation-structure" id="documentation-structure"><h1>Documentation Structure</h1></a>
<p>The directory structure is meant to feel comfortable for those
familiar with the data platform:</p>
<pre><code>.
|--src
   |--datasets - contains dataset level documentation
   |--tools - contains tool level documentation
   |--concepts - contains tutorials meant to introduce a new concept to the reader
   |--cookbooks - focused code examples for reference
</code></pre>
<p>The prose documentation is meant to take the reader from beginner to expert.
To this end, the rendered documentation has an order different from the directory structure:</p>
<ul>
<li>Getting Started: Get some simple analysis completed so the user understands
the amount of work involved / what the product feels like</li>
<li>Tutorials
<ul>
<li>Data Tutorials: tutorials meant to give the reader a complete understanding
of a specific dataset. Start with a high level overview, then move on to
completely document the data including Data source, Sampling, Common Issues,
and where the reader can find the code.</li>
<li>Tools tutorials: Tutorials meant to introduce a single data tool or
analysis best practice.</li>
</ul>
</li>
<li>Cookbooks</li>
<li>Reference material - TBD</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="mermaid.min.js"></script>
        
        <script type="text/javascript" src="mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
